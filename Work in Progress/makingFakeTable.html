<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Video Data\makingFakeTable.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>Video Data\makingFakeTable.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ol>
<li><a href="#creating-a-fake-table-using-hashsets">Creating a fake Table using hashSets</a></li>
<li><a href="#generics">Generics</a></li>
<li><a href="#fake-table,-but-better-?">Fake Table, but better ?</a></li>
<li><a href="#overloading">Overloading</a></li>
<li><a href="#tuple-unpacking">Tuple Unpacking</a></li>
</ol>
<h2>INTRO - GREETING</h2>
<ul>
<li>TITLE: Creating a fake Table using hashSets and Generics(overloading in depth)</li>
<li>ALT TITLE: More on hashSets and overloading in depth</li>
</ul>
<h2>Brainstorming/To do</h2>
<p>Here go all thoughts on what the video will be like and how it will be made etc,
before being organized below.</p>
<pre><code>Chapters/sub topics of this video will be:
  Creating a fake Table using hashSets
    Generics
      Generic Procs
      Generic Tuples
      Generic Objects
    Overloading with Generics
    Fake Table, but better ?
  Tuple Unpacking
</code></pre>
<h2>INTRO - FOREWORDS</h2>
<p><b>(What is the purpose of this video ?)</b></p>
<ul>
<li>In this video we will create a fakeTable using hashSets,
which will function like a hashTable, but with all of the great Set operations.
We won't go trough all of the operations a hashSet can have,
but we will make all of the ones normal Sets can use work.
Also <code>tuple unpacking</code>.</li>
</ul>
<p>The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.</p>
<p><a name = "creating-a-fake-table-using-hashsets"></a></p>
<h1>Creating a fake Table using hashSets</h1>
<hr />
<p>In order to create this fakeTable using hashSets,
we will have to use <code>tuples</code>.
Tuples, because they are a 2x field data structure just like Tables are.
We will also have to use <code>generics</code> to overload existing procs and operators that Sets use,
in order for the (key, value) tuples, to be able to be of any Nim's data type,
without having to overload an insane number of times.</p>
<p><a name = "generics"></a></p>
<h1>Generics</h1>
<hr />
<p>Generics in Nim, are used to parametrize procs, iterators or types with type parameters.
<code>[]</code> are used along with capital letters inside of them, separated by commas,
after a type's name, proc or iterator to tell the compiler that this will be a <code>generic</code>:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
    ndata: <span class="hljs-built_in">string</span>

<span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>]() =
  <span class="hljs-keyword">discard</span>

<span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>]() =
  <span class="hljs-keyword">discard</span></code></pre>
<p>The above examples are incomplete, they will not work just yet.
Again, using <code>[]</code> with a capital letter inside will just &quot;mark&quot; the <code>type, proc, iterator</code> as a generic.
Now we require to use that <code>T</code>(can be any capital letter) in the arguments of the <code>proc</code>, <code>iterator</code>,
and on the fields of a <code>type</code> like so:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
    data: <span class="hljs-type">T</span>

<span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericTuple</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">tuple</span>
    name: <span class="hljs-type">A</span>
    age: <span class="hljs-type">B</span>

<span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>) =
  <span class="hljs-keyword">discard</span>

<span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">discard</span></code></pre>
<p><strong>And also for generic containers example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> genericContainerProc[<span class="hljs-type">T</span>](anyTypeContainer: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]) =
  <span class="hljs-keyword">discard</span></code></pre>
<p>Now let's see how to use this <code>generic object</code></p>
<p><strong>Generic Object:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> genericObject = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">string</span>](data: <span class="hljs-string">&quot;A String&quot;</span>)
<span class="hljs-keyword">var</span> genericObject2 = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">int</span>](data: <span class="hljs-number">101</span>)

<span class="hljs-keyword">echo</span> genericObject, <span class="hljs-string">&quot; of type &quot;</span>, genericObject.typeof
<span class="hljs-keyword">echo</span> genericObject2, <span class="hljs-string">&quot; of type &quot;</span>, genericObject2.typeof</code></pre><pre class="nb-output">(data: &quot;A String&quot;) of type GenericObject[system.string]
(data: 101) of type GenericObject[system.int]</pre>
<p><strong>Generic Tuple</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> genericTuple: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>)
<span class="hljs-keyword">var</span> genericTuple2: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">seq</span>[<span class="hljs-built_in">float</span>], <span class="hljs-built_in">bool</span>] = (@[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">3.25</span>], <span class="hljs-literal">true</span>)

<span class="hljs-keyword">echo</span> genericTuple, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple.typeof
<span class="hljs-keyword">echo</span> genericTuple2, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple2.typeof</code></pre><pre class="nb-output">(name: &quot;Bob&quot;, age: 20) of type GenericTuple[system.string, system.int]
(name: @[0.5, 1.1, 3.25], age: true) of type GenericTuple[seq[float], system.bool]</pre>
<p>One example for generic <code>iterators</code> and lots for generic <code>procs</code> will be shown making this <code>fakeTable</code>.
Calling generic procs and iterators is exactly the same as non generic versions,
unlike structures like <code>objects</code> and <code>tuples</code>(shown above).</p>
<p><a name = "fake-table,-but-better-?"></a></p>
<h1>Fake Table, but better ?</h1>
<hr />
<p>First of, we need to define our FakeTable and then overload the <code>hash</code> proc,
and make a custom <code>iterator</code> that uses that overloaded <code>hash</code> proc,
just like in the previous video of <code>hashSets, more on hash Tables and Hashing</code>,
but with generics.</p>
<p><strong>First the definition of our tuple to serve as our (key, value),
and then the <code>FakeTable</code>, which is also easier to read and write than,
<code>HashSet[KeyValue[K, V]]</code></strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/hashes, std/sets

<span class="hljs-keyword">type</span>
  <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-keyword">tuple</span>
    key: <span class="hljs-type">K</span>
    value: <span class="hljs-type">V</span>
  
  <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">HashSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]</code></pre>
  <h6>(From now on, when you see fakeTable or fake Table, i mean the idea, implementation of a "fake table",
  and NOT the `FakeTable` type)</h6>
<p><strong>Now the <code>hash</code> proc overload which is almost exactly the same as in the previous video,
except for the generic part and the &quot;runnableExamples&quot;:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> xAtom <span class="hljs-keyword">in</span> fakeTable.elements:
    h = h !&amp; xAtom <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
  <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

    keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
    keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e</code></pre>
<p>In order to achieve a fakeTable with hashSets, we must again use hashSets,
and so this <code>hash</code> proc takes a <code>HashSet</code> of type <code>KeyValue</code> with generic parameters of <code>K, V</code>,
so that this fakeTable can function like a Table, which can use just about any data type.</p>
<p>The <code>runnableExamples:</code> part is ignored by the <code>debug</code>(what we are using) and the <code>release</code> versions,
of our programs. It's simply an area meant for examples of the proc, iterator etc.</p>
<p><strong>Now the custom <code>iterator elements</code> for this <code>hash</code> proc overload:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">iterator</span> elements[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">yield</span> hash(tup.key)
    <span class="hljs-keyword">yield</span> hash(tup.value)</code></pre>
<p>Again the first changes to this custom iterator are the generic parts.
The second change is because we are giving this iterator,
instead of fields of an object, a <code>FakeTable</code> type which is a <code>HashSet</code> container of type <code>KeyValue</code>, our tuple.
And so we must first <code>unwrap</code> this <code>FakeTable</code> with a simple <code>for loop</code>,
to get the tuple elements, and then it works as before, hashing the 2x fields of our <code>KeyValue</code> tuple instead of an object.</p>
<p><strong>Now let's try that <code>runnableExamples:</code>'s example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e</code></pre><pre class="nb-output">keyValue.elements: 277569625
keyValue.elements: -103088068849849363
keyValue.elements: 2624693060
keyValue.elements: 9147201994791625791</pre>
<p>Here we go, both fields of the 2x tuples hashed.</p>
<p><strong>Here is the <code>hash</code> proc version without the custom iterator,
which does not take our <code>FakeTable</code> type, because that would mean it would require an iterator:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyValue: <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

  h = h !&amp; hash(keyValue.key) <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
  h = h !&amp; hash(keyValue.value)
  <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

    keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
    keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValue:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hashing tuple: &quot;</span>, tup
      <span class="hljs-keyword">echo</span> tup.hash</code></pre>
<p>Now let's make a <code>constructor proc</code> to make creation/initialization of our <code>FakeTable</code>,
easier and faster than having to write <code>HashSet[KeyValue[K, V]]</code>,
AND, to actually use a <code>FakeTable</code> type, since <code>HashSet[KeyValue[K, V]]</code>,
is NOT a <code>FakeTable</code></p>
<p>This proc will once again be a generic, since a Table's key and value can be of almost any data type,
we need 2x generic arguments <code>[K, V]</code> for the (key, value) fields of our <code>KeyValue</code> tuple.
Then we give it 2x arguments of type <code>typedesc</code>, which is short for <code>typedescription</code>.
<code>typedesc</code> which is a meta type to denote a type description and is required to make our fakeTable.
If we instead make our 2x arguments: &quot;keyType: K, valueType: V&quot;,
when we will try to use this proc, the Nim's VS Code extension will tell us that we have,
a variable with <code>typedesc type, typedesc type</code>, instead of <code>type, type</code>.
This is because we are giving types to our proc to make our HashSet[KeyValue[type, type]],
and not some operation working with values of types already <code>initialized</code> outside of the <code>proc</code></p>
<p>And then we simply use the initialization proc for hashSets <code>initHashSet</code> of type KeyValue[type, type],
to initialize our fakeTable of type <code>FakeTable</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> newFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-literal">result</span> = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]() <span class="hljs-comment">#Have to use `result =` with `runnableExamples:` present</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
    fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof</code></pre>
<p><strong>Now let's run the runnable example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
<span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof</code></pre><pre class="nb-output">{(key: 'a', value: 10)} FakeTable[system.char, system.int]</pre>
<p><strong>As you can see, initializing our fakeTable is much simpler than the original of:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()</code></pre>
<p><strong>Making a <code>OrderedSet</code> version of our constructor proc:</strong>
First we make another type just like with we did for our FakeTable type,
but instead of using a <code>HashSet</code>, we use a <code>OrderedSet</code>.
And then lastly, we simply rename the return type to <code>FakeOrderedTable</code></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">OrderedSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]

<span class="hljs-keyword">proc</span> newOrderedFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  initOrderedSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]()

  runnableExamples:
    <span class="hljs-keyword">var</span> fakeOrderedTable = newOrderedFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
    fakeOrderedTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">echo</span> fakeOrderedTable, <span class="hljs-string">&quot; &quot;</span>, fakeOrderedTable.typeof</code></pre>
<p><a name = "overloading"></a></p>
<h1>Overloading</h1>
<hr />
<p>Now let's move on to overloading ALL of the operations normal <code>sets</code> can use,
here is the list from the <code>sets video</code>:</p>
<ul>
<li><span style="color:pink"><b>incl</b></span>(A, e)	same as A = A + e</li>
<li><span style="color:pink"><b>excl</b></span>(A, e)	same as A = A - e</li>
<li><span style="color:pink"><b>card</b></span>(A)	the cardinality of A (number of elements in A)</li>
<li><span style="color:pink"><b>contains</b></span>(A, e)	A contains element e</li>
<li>e <span style="color:pink"><b>in</b></span> A	set membership (A contains element e)</li>
<li>e <span style="color:pink"><b>notin</b></span> A	A does not contain element e</li>
<li>a <span style="color:pink"><b>*</b></span> b	Intersection</li>
<li>a <span style="color:pink"><b>+</b></span> b	Union</li>
<li>a <span style="color:pink"><b>-</b></span> b	Difference</li>
<li>a <span style="color:pink"><b>==</b></span> b	Set equality</li>
<li>a <span style="color:pink"><b>&lt;=</b></span> b	subset relation (a is subset of b or equal to b)</li>
<li>a <span style="color:pink"><b>&lt;</b></span> b	Check if a is a subset of b</li>
</ul>
<p><strong>As well as:</strong></p>
<ul>
<li>`[]`(<code>[]</code> with apostrophes) so that we can find the value of a key, by supplying the key.
Otherwise we have to supply the entire <code>tuple</code>.</li>
</ul>
<p><strong>And</strong> <code>missingOrExcl(HashSet, key)</code> as an extra(only for hashSets, not normal Sets)</p>
<p>Let's start with <code>contains(container, key)</code>, which is an alias for the <code>in</code> operator.
So that we can easily find a <code>key</code> inside our <code>FakeTable</code>'s <code>KeyValue</code> tuple,
and with that <code>key</code>, it's `value:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># `in` is an alias for `contains`, </span>
<span class="hljs-keyword">proc</span> contains[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">if</span> tup.key == k:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></code></pre>
<p>As you can see, we make it a <code>generic</code> proc that takes our <code>FakeTable</code> type,
unwraps the <code>fakeTable</code>, and then checks every <code>KeyValue</code> tuple's first field of <code>key</code>,
against <code>k</code>, the key we are looking for, and then returns true or false if it found it or not.</p>
<p><strong>Here is an example of it's usage:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fakeTableContains = newFakeTable(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)

fakeTableContains.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>) <span class="hljs-comment">#elements as tuples</span>
fakeTableContains.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>) <span class="hljs-comment">#elements as tuples</span>

<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Key 2&quot;</span> <span class="hljs-keyword">in</span> fakeTableContains:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SUCCESS: Key 2 is in fakeTableContains&quot;</span></code></pre><pre class="nb-output">SUCCESS: Key 2 is in fakeTableContains</pre>
<p>Now let's overload the `[]`(<code>[]</code> with apostrophes),
to again, be able to easily find a <code>key</code> inside our <code>FakeTable</code>'s <code>KeyValue</code> tuple,
and with that <code>key</code>, it's `value:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `[]`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-type">V</span> {.inline.} =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">if</span> tup.key == k:
      <span class="hljs-keyword">return</span> tup.value</code></pre>
<p>Very similar to the <code>contains</code>(<code>in</code> is the alias) overload.
The strange part here is the <code>{.inline.}</code> pragma,
which is simply there to mark it for the compiler(which will warn us) and us,
that we should not call this proc <code>[]</code> directly,
as in like a proc <code>[](arg1, arg2)</code>.</p>
<p><strong>Here is the example of what that overload enables us:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> fakeTableContains
<span class="hljs-keyword">echo</span> fakeTableContains[<span class="hljs-string">&quot;Key 1&quot;</span>]</code></pre><pre class="nb-output">{(key: &quot;Key 2&quot;, value: 202), (key: &quot;Key 1&quot;, value: 101)}
101</pre>
<p><strong>NOTE:</strong> All of these overloads have to focus on the <code>key</code> part of the <code>KeyValue</code> tuple,
in order to achieve the functionality of a <code>Table</code>.
Meaning, these overloads must make it so that we only work with the <code>keys</code>,
and not <code>tuples</code>.</p>
<p>Now let's overload the <code>+</code> operator(proc), which is the <code>union</code> between Set1 and Set2,
meaning both sets.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key != tupB.key:
        <span class="hljs-literal">result</span>.incl tupA
        <span class="hljs-literal">result</span>.incl tupB</code></pre>
<p>The overload proc's head, could also put both arguments together like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-keyword">discard</span></code></pre>
<p><strong>How it works:</strong> Well, first of we unwrap the first <code>FakeTable</code>(HashSet[KeyValue[K, V]]) with a for loop,
then we unwrap the second with another for loop on the second <code>FakeTable</code> of <code>b</code>,
in order to -&gt; elementOfSet1.key != elementOfSet1.key -&gt; elementOfSet1.key != elementOfSet<code>2</code>.key -&gt;
and so on, until we compare every element's key of <code>a</code> against every element's key of <code>b</code>,
in order to find only the <code>keys</code>, both <code>FakeTables</code> share,
to return a <code>result</code> of the <code>union</code> of both <code>FakeTables</code>.</p>
<p>Remember that <code>sets</code> do not allow for duplicate keys.
Checking without the <code>.key</code> part, could result in duplicate keys,
because, even though our <code>FakeTable</code> is a <code>HashSet</code> which doesn't allow for duplicate elements,
it can only do so, if the <code>(key, value)</code> tuple elements we have in it,
have both fields of our <code>KeyValue</code> tuple <code>(key, value)</code> exactly the same,
as another <code>KeyValue</code> tuple <code>(key, value)</code>.
Tuples are only equal if both tuples have both fields identical.</p>
<p>This is why we must provide &quot;help&quot; to our <code>FakeTable</code>'s overload procs.</p>
<p><strong>Now let's finally see an example of the <code>+</code> operator(proc) overload:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fTableA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> fTableB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

fTableA.incl (<span class="hljs-string">'A'</span>, <span class="hljs-number">1</span>)
fTableA.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)

fTableB.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)
fTableB.incl (<span class="hljs-string">'C'</span>, <span class="hljs-number">3</span>)

<span class="hljs-keyword">echo</span> fTableA + fTableB</code></pre><pre class="nb-output">{(key: 'C', value: 3), (key: 'B', value: 2), (key: 'A', value: 1)}</pre>
<p>Here we go, all the elements of both <code>FakeTables</code>, without duplicates.</p>
<p>Now let's overload the <code>-</code> operator(proc) - Difference - Returns the elements that <code>fTableA</code> has,
but <code>fTableB</code> does not.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `-`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">var</span> tempA = a
  <span class="hljs-keyword">var</span> tempB = b

  <span class="hljs-comment">#De-duplication</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key == tupB.key:
        tempA.excl(tupA)
        tempB.excl(tupB)

  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> tempA:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> tempB:
      <span class="hljs-keyword">if</span> tupA.key != tupB.key:
        <span class="hljs-keyword">if</span> tupA <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
          <span class="hljs-keyword">discard</span>
        <span class="hljs-keyword">else</span>:
          <span class="hljs-literal">result</span>.incl tupA</code></pre>
<p>First of, we copy the 2 <code>FakeTable</code>s of <code>a</code> and <code>b</code> into temporary variables of <code>tempA</code> and <code>tempB</code>,
because want to de-duplicate the <code>FakeTable</code>s and only return different elements,
and we can't do that with the <code>FakeTables</code> we supplied to the 2x arguments of <code>a</code> and <code>b</code>Àô,
because you can't modify arguments received.
We also can't use <code>var</code> before <code>FakeTable</code> as in <code>a: var FakeTable</code>,
because we would be modifying the original <code>FakeTable</code>s, which we don't want to do.</p>
<p>So the second part marked with the #De-duplication comment,
is where we unwrap both of the <code>FakeTables</code>,
and check all the <code>keys</code> of the <code>KeyValue</code> tuples for identical keys/duplicates,
and then remove them from both, because this isn't just to find and remove duplicates,
but also because the <code>-</code> operator(proc), is supposed to only return the elements,
that are not in <code>FakeTable</code> <code>b</code> - any duplicates/shared elements.</p>
<p>And lastly, the third part then unwraps both <code>temp</code> <code>FakeTable</code>s,
and looks for <code>different keys</code>, and also checks the <code>result</code> variable,
because checking if the keys are not equal and then including <code>tupA</code>,
the remaining keys WILL be different, and if both <code>FakeTable</code>s have 2x elements each,
then both of the elements of <code>tupA</code>, would be added twice,
requiring further de-duplication. Checking the <code>result</code> variable, fixes that.</p>
<p><strong>Here is an example of manually going trough this overloaded <code>-</code> operator(proc):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">discard</span> <span class="hljs-comment">#nimib requires a return</span>
<span class="hljs-comment">#a b c #a: FakeTable</span>
<span class="hljs-comment">#c d e #b: FakeTable</span>
<span class="hljs-comment">#De-duplication</span>
<span class="hljs-comment">#a b</span>
<span class="hljs-comment">#d e</span>
<span class="hljs-comment">#1 a != d -&gt; yes adding `a`</span>
<span class="hljs-comment">#2 a != e -&gt; yes adding `a` -&gt; duplicated `a` -&gt; hashSet detects that, removes it. BUT tuples != if not all fields are equal</span>
<span class="hljs-comment">#3 b != d -&gt; yes adding `b`</span>
<span class="hljs-comment">#4 b != e -&gt; yes adding `b`</span>
<span class="hljs-comment">#result = {'a', 'a', 'b', 'b'} -&gt; correct if we deduplicate... this could go on to infinity.</span>
<span class="hljs-comment">#So checking the `result` variable fixes the above problem</span></code></pre>
<p>And here is the code for the above manual explanation:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> ftA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> ftB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

ftA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
ftA.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
ftA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

ftB.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)
ftB.incl (<span class="hljs-string">'d'</span>, <span class="hljs-number">40</span>)
ftB.incl (<span class="hljs-string">'e'</span>, <span class="hljs-number">50</span>)

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA: &quot;</span>, ftA
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB: &quot;</span>, ftB

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA - ftB = &quot;</span>, ftA - ftB</code></pre><pre class="nb-output">ftA: {(key: 'c', value: 30), (key: 'a', value: 10), (key: 'b', value: 20)}
ftB: {(key: 'c', value: 30), (key: 'd', value: 40), (key: 'e', value: 50)}
ftA - ftB = {(key: 'a', value: 10), (key: 'b', value: 20)}</pre>
<p>And the reverse:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB - ftA = &quot;</span>, ftB - ftA</code></pre><pre class="nb-output">ftB - ftA = {(key: 'd', value: 40), (key: 'e', value: 50)}</pre>
<p>Now we will overload the <code>*</code> operator(proc) - intersection - returns only shared elements.
This one is very simple, simply compare the keys, and add one of them into the <code>result</code>(since both are the same):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `*`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key == tupB.key:
        <span class="hljs-literal">result</span>.incl tupA</code></pre>
<p>Example:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> ftA * ftB</code></pre><pre class="nb-output">{(key: 'c', value: 30)}</pre>
<p>Next is <code>&lt;</code> operator(proc) overload - <code>a</code> subset of <code>b</code>
First of, when using this operator, the <code>subset</code> HAS to be smaller than the set(FakeTable) we are comparing against.</p>
<p>Which is easily achieved by first checking the lengths of the 2x <code>FakeTable</code>s:
<code>if a.len &gt;= b.len: return false</code>, <code>else:</code> we continue.
Then we set the <code>result</code> variable to <code>false</code>, unwrap the 2x <code>FakeTable</code>s,
make a <code>block subsetA</code> statement, so that we can easily break out of the second loop once we find an identical key,
after setting the <code>result</code> variable to <code>true</code>Àô.</p>
<p><strong>This is for 2x reasons:</strong> The first is for reasons of speed, we are checking every element of <code>FakeTable</code> <code>a</code>,
against every element of <code>FakeTable</code> <code>b</code>, there are no duplicates, so once found, it's a waste to continue.</p>
<p>And secondly, because we have to set the <code>result</code> variable to <code>false</code> if the keys are not identical,
so that once loop 2 ends, and loop 1 is about to start another run of loop 2 with the next element,
and we found no matching <code>keys</code>, then <code>FakeTable</code> <code>a</code> is NOT a subset of <code>FakeTable</code> <code>Àôb</code>.
And because of that, if we don't break out back to loop 1 using the <code>labeled block</code> statement,
we could find a matching key, but then on the second element override it to false!</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `&lt;`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">if</span> a.len &gt;= b.len:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">block</span> subsetA:
        <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">if</span> tupA.key == tupB.key:
            <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
          <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span></code></pre>
<p>Here is an example:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">#ftA has 'a', 'b', 'c'</span>
<span class="hljs-keyword">var</span> subsetOfA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

subsetOfA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
subsetOfA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

<span class="hljs-keyword">echo</span> ftA
<span class="hljs-keyword">echo</span> subsetOfA
<span class="hljs-keyword">echo</span> subsetOfA &lt; ftA

<span class="hljs-keyword">var</span> subsetofA2 = ftA
<span class="hljs-keyword">echo</span> subsetofA2 &lt; ftA</code></pre><pre class="nb-output">{(key: 'c', value: 30), (key: 'a', value: 10), (key: 'b', value: 20)}
{(key: 'c', value: 30), (key: 'a', value: 10)}
true
false</pre>
<p><code>subsetofA2 is false because it is equal in size of </code>ftA`, again, has to be smaller.</p>
<p>This isn't true for the <code>&lt;=</code> operator(proc), which does the exact same as <code>&lt;</code>,
except that the subset can be equal in size.</p>
<p><strong>Here is the code to overload <code>&lt;=</code> operator(proc):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `&lt;=`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">if</span> system.`&lt;=`(a.len, b.len): <span class="hljs-comment">#Can't do this: if a.len &lt;= b.len: -&gt; for some reason this overload calls itself instead of the system &lt;=</span>
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">block</span> subsetA:
        <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">if</span> tupA.key == tupB.key:
            <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
          <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></code></pre>
<p>The only real change here compared to the <code>&lt;</code> overload,
is that instead of checking for the <code>subset</code> to be smaller,
we check for smaller or equal.
Here i found a bit of a problem. For some reason when using the <code>&lt;=</code> operator,
Nim calls the version we are in right now, instead of the <code>system</code> module one.
So in order to tell it to use the correct one,
we have to explicitly specify that with <code>system.</code> + <strong>`&lt;=`</strong> + <code>(a.len, b.len)</code>,
instead of simply <code>a.len &lt;= b.len</code>.</p>
<p><strong>Now let's also overload the <code>==</code> operator(proc)</strong>,
so that we are no longer comparing tuples, which require both fields to be equal for equivalence.
With this overload we would only require the <code>keys</code>.</p>
<p>With this overload, we also have to use the <code>system.</code> way of explicitly calling the system module's <code>==</code> operator.
I am pretty sure, that the reason this happens, is for reasons of <code>recursion</code>,
proc calling itself, like in the famous fibonacci sequence.</p>
<p>In this overload's code i've also used the <code>in</code> alias of the <code>contains</code> overload we have done earlier,
to make this easier, as well as a <code>continue</code> statement, instead of reversing that logic with a <code>notin</code> template.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `==`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">#until false</span>

  <span class="hljs-keyword">if</span> system.`==`(a.len, b.len): <span class="hljs-comment">#Cannot use: if a.len == b.len: -&gt; because of reasons of recursion</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">if</span> tupA.key <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">continue</span>
      <span class="hljs-keyword">else</span>:
        <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>: 
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span></code></pre>
<p>And an example:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> a = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> b = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> c = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

a.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); a.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
b.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); b.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)

c.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); c.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

<span class="hljs-keyword">echo</span> a == b
<span class="hljs-keyword">echo</span> a == c</code></pre><pre class="nb-output">true
false</pre>
<p>Here i have also used <code>;</code> which is optional in Nim,
and allows for multiple operations to be used on a single line.
I think it's quite useful for such small operations that work the same,
to be put on a single line, instead of heavily spreading vertically.
I don't recommend using the optional semicolon <code>;</code> for large operations,
or different ones, most people don't like that,
and it will hurt clarity and readability. But again, for same operations of such small scale, yes.</p>
<p><strong>Now let's overload the <code>excl</code> proc(for Sets/HashSets)</strong>, in order to simplify removal of <code>KeyValue</code> tuples,
based on the <code>key</code> provided. <code>del</code> is the proc for doing this for <code>Tables</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> excl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>) =
  <span class="hljs-comment">#Since excluding/removing an element of a container while iterating over it with a `for` loop is an error,</span>
    <span class="hljs-comment">#iterating over a copy, and using the copy's data to remove from the original will avoid that problem</span>
  <span class="hljs-keyword">var</span> temp = fakeTable

  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> temp:
    <span class="hljs-keyword">if</span> tup.key == k:
      fakeTable.excl(tup)</code></pre>
<p>We have to use the <code>var</code> keyword in the overload's definition/head for our <code>FakeTable</code> in order to remove a <code>key</code>,
from the supplied <code>FakeTable</code>. Without <code>var</code> you only copy the argument's data.</p>
<p>Example(using variables from above):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> a
a.excl(<span class="hljs-string">'a'</span>)
<span class="hljs-keyword">echo</span> a</code></pre><pre class="nb-output">{(key: 'a', value: 10), (key: 'b', value: 20)}
{(key: 'b', value: 20)}</pre>
<p><strong>Now we will overload the <code>missingOrExcl</code> proc, that is available only to hashSets, NOT normal Sets.</strong>
<code>missingOrExcl</code> again, first excludes a <code>key</code> from a <code>HashSet</code>, and tells you if the <code>key</code> was already missing:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> missingOrExcl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
  <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> fakeTable:
    fakeTable.excl(k)
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span></code></pre>
<p>Quite simple with the <code>excl</code> and <code>contains</code> proc overloads.
Without them, it would of been quite longer and harder to understand.</p>
<p><strong>Here is an example from the <code>sets</code> module's example for <code>missingOrExcl</code> for <code>HashSet</code>s:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> s = newFakeTable(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)
s.incl (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); s.incl (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); s.incl (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>); s.incl (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);

<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">4</span>) <span class="hljs-comment">#should be: true</span>
<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: false</span>
<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: true</span></code></pre><pre class="nb-output">true
false
true</pre>
<p><a name = "tuple-unpacking"></a></p>
<h1>Tuple Unpacking</h1>
<hr />
<p>Since we have been dealing with <code>tuples</code> quite a lot in this video,
it's time to explain and demonstrate <code>tuple unpacking</code>, which i did not show in the <code>Tuples video</code>,
nor did it find any use in this one.</p>
<p>Tuple unpacking is quite simple.</p>
<p>You can use them to give values to multiple variables(<code>var</code>), constants(<code>const</code>) or immutable variable(<code>let</code>),
at once. Like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> (v1, c1, l1) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

<span class="hljs-keyword">echo</span> v1
<span class="hljs-keyword">echo</span> c1
<span class="hljs-keyword">echo</span> l1</code></pre><pre class="nb-output">var
const
let</pre>
<p>You may also ommit assignment of any of them:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> (v2, _, l2) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

<span class="hljs-keyword">let</span> (_, _, _) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)</code></pre>
<p>Not sure why anyone would ommit all of them... but you can!</p>
<p>All of this is treated as syntatic sugar for basically the following code(look at the first example):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span>
  temporaryTuple = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
  v3 = temporaryTuple[<span class="hljs-number">0</span>]
  c3 = temporaryTuple[<span class="hljs-number">1</span>]
  l3 = temporaryTuple[<span class="hljs-number">2</span>]</code></pre>
<p>I don't think i have ever shown this before, but yes, you can access any field of a <code>tuple</code>,
without knowing the name of the field, especially useful for <code>anonymous</code> tuples like here(fields without names).
I do recommend though, that you do use the <code>names</code> of the fields over the <code>index</code> when the <code>names</code> are present.</p>
<p>(When tuple unpacking with tuples with numbers(literals) into <code>var</code> and <code>let</code> variables,
they get assigned their values without a <code>temporaryTuple</code>)</p>
<p>Since you can nest any container withing another container(array, seq, set, table, etc),
as well as data structure in a data structure(object, tuple),
you can also use nested tuples for tuple unpacking, like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> returnsNestedTuple(): (<span class="hljs-built_in">int</span>, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>), <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) = (<span class="hljs-number">4</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-keyword">let</span> (x, (_, y), _, z) = returnsNestedTuple()</code></pre>
<p>I have NO ideas of a good example of tuple unpacking... in this entire endeavour of making a FakeTable,
i had no use for it.</p>
<p>This script is complete from our standpoint, time to send for review,
and find what to do next.</p>
<h2>OUTRO - AFTERWORDS</h2>
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also follow me on twitter of the same name, and support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of offline tutorial.</p>
<h3>Thanks to my past and current Patrons</h3>
<p><b>Past Patrons:</b></p>
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<p><b>Current Patrons</b></p>
<ul>
<li>None</li>
</ul>
<p><b>Compiler information</b></p>
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option</li>
<li>Timestamps:
<ul>
<li>00:15 Start of video example</li>
</ul>
</li>
</ul>
<p><b>LINKS:</b></p>
<ul>
<li><a href="https://twitter.com/Kiloneie" title="My Twitter">Twitter</a></li>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<p><b>LINKS to this video's subject:</b></p>
<ul>
<li><a href="https://nim-lang.org/docs/manual.html#special-types-typedesc-t" title="typedesc">typedesc</a></li>
<li><a href="https://wiki.libsdl.org/APIByCategory" title="Example link to an example video's subject">E.G.2. SDL2 documentation(in case SDL2_nim documentation missed something)</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>

<span class="hljs-keyword">import</span> nimib, std/strutils <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 

<span class="hljs-comment">#Do NOT forget to have the .html file OPEN at all times, otherwise </span>
  <span class="hljs-comment">#live preview will NOT work! ANY live preview!</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd or hlMdf enables nimiboost's markdown highlight mode</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;
## INTRO - GREETING
- TITLE: Creating a fake Table using hashSets and Generics(overloading in depth)
- ALT TITLE: More on hashSets and overloading in depth

## Brainstorming/To do
Here go all thoughts on what the video will be like and how it will be made etc,
before being organized below.

    Chapters/sub topics of this video will be:
      Creating a fake Table using hashSets
        Generics
          Generic Procs
          Generic Tuples
          Generic Objects
        Overloading with Generics
        Fake Table, but better ?
      Tuple Unpacking

## INTRO - FOREWORDS
&lt;b&gt;(What is the purpose of this video ?)&lt;/b&gt;
- In this video we will create a fakeTable using hashSets,
  which will function like a hashTable, but with all of the great Set operations.
  We won't go trough all of the operations a hashSet can have,
  but we will make all of the ones normal Sets can use work.
  Also `tuple unpacking`.
   
The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Creating a fake Table using hashSets&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In order to create this fakeTable using hashSets,
    we will have to use `tuples`.
    Tuples, because they are a 2x field data structure just like Tables are.
    We will also have to use `generics` to overload existing procs and operators that Sets use, 
    in order for the (key, value) tuples, to be able to be of any Nim's data type, 
    without having to overload an insane number of times.
&quot;&quot;&quot;</span>
  
nbSection <span class="hljs-string">&quot;Generics&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Generics in Nim, are used to parametrize procs, iterators or types with type parameters.
  `[]` are used along with capital letters inside of them, separated by commas,
  after a type's name, proc or iterator to tell the compiler that this will be a `generic`:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
      ndata: <span class="hljs-built_in">string</span>

  <span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>]() =
    <span class="hljs-keyword">discard</span>
  
  <span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>]() =
    <span class="hljs-keyword">discard</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  The above examples are incomplete, they will not work just yet.
  Again, using `[]` with a capital letter inside will just &quot;mark&quot; the `type, proc, iterator` as a generic.
  Now we require to use that `T`(can be any capital letter) in the arguments of the `proc`, `iterator`,
  and on the fields of a `type` like so:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
      data: <span class="hljs-type">T</span>

  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericTuple</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">tuple</span>
      name: <span class="hljs-type">A</span>
      age: <span class="hljs-type">B</span>

  <span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>) =
    <span class="hljs-keyword">discard</span>
  
  <span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **And also for generic containers example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> genericContainerProc[<span class="hljs-type">T</span>](anyTypeContainer: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]) =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's see how to use this `generic object`

  **Generic Object:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> genericObject = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">string</span>](data: <span class="hljs-string">&quot;A String&quot;</span>)
  <span class="hljs-keyword">var</span> genericObject2 = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">int</span>](data: <span class="hljs-number">101</span>)

  <span class="hljs-keyword">echo</span> genericObject, <span class="hljs-string">&quot; of type &quot;</span>, genericObject.typeof
  <span class="hljs-keyword">echo</span> genericObject2, <span class="hljs-string">&quot; of type &quot;</span>, genericObject2.typeof

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Generic Tuple**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> genericTuple: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>)
  <span class="hljs-keyword">var</span> genericTuple2: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">seq</span>[<span class="hljs-built_in">float</span>], <span class="hljs-built_in">bool</span>] = (@[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">3.25</span>], <span class="hljs-literal">true</span>)

  <span class="hljs-keyword">echo</span> genericTuple, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple.typeof
  <span class="hljs-keyword">echo</span> genericTuple2, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple2.typeof

nbText: <span class="hljs-string">&quot;&quot;&quot;
  One example for generic `iterators` and lots for generic `procs` will be shown making this `fakeTable`.
  Calling generic procs and iterators is exactly the same as non generic versions,
  unlike structures like `objects` and `tuples`(shown above).
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Fake Table, but better ?&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  First of, we need to define our FakeTable and then overload the `hash` proc,
  and make a custom `iterator` that uses that overloaded `hash` proc,
  just like in the previous video of `hashSets, more on hash Tables and Hashing`,
  but with generics.

  **First the definition of our tuple to serve as our (key, value),
  and then the `FakeTable`, which is also easier to read and write than,
  `HashSet[KeyValue[K, V]]`**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/hashes, std/sets

  <span class="hljs-keyword">type</span>
    <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-keyword">tuple</span>
      key: <span class="hljs-type">K</span>
      value: <span class="hljs-type">V</span>
    
    <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">HashSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]
nbText: <span class="hljs-string">&quot;&quot;&quot;
  &lt;h6&gt;(From now on, when you see fakeTable or fake Table, i mean the idea, implementation of a &quot;fake table&quot;,
  and NOT the `FakeTable` type)&lt;/h6&gt;

  **Now the `hash` proc overload which is almost exactly the same as in the previous video,
  except for the generic part and the &quot;runnableExamples&quot;:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> xAtom <span class="hljs-keyword">in</span> fakeTable.elements:
      h = h !&amp; xAtom <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
    <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

      keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
      keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

      <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In order to achieve a fakeTable with hashSets, we must again use hashSets,
  and so this `hash` proc takes a `HashSet` of type `KeyValue` with generic parameters of `K, V`,
  so that this fakeTable can function like a Table, which can use just about any data type.

  The `runnableExamples:` part is ignored by the `debug`(what we are using) and the `release` versions,
  of our programs. It's simply an area meant for examples of the proc, iterator etc.

  **Now the custom `iterator elements` for this `hash` proc overload:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">iterator</span> elements[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">yield</span> hash(tup.key)
      <span class="hljs-keyword">yield</span> hash(tup.value)
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Again the first changes to this custom iterator are the generic parts.
  The second change is because we are giving this iterator,
  instead of fields of an object, a `FakeTable` type which is a `HashSet` container of type `KeyValue`, our tuple.
  And so we must first `unwrap` this `FakeTable` with a simple `for loop`,
  to get the tuple elements, and then it works as before, hashing the 2x fields of our `KeyValue` tuple instead of an object.

  **Now let's try that `runnableExamples:`'s example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

  keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
  keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here we go, both fields of the 2x tuples hashed.

  **Here is the `hash` proc version without the custom iterator,
  which does not take our `FakeTable` type, because that would mean it would require an iterator:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyValue: <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

    h = h !&amp; hash(keyValue.key) <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
    h = h !&amp; hash(keyValue.value)
    <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

      keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
      keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

      <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValue:
        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hashing tuple: &quot;</span>, tup
        <span class="hljs-keyword">echo</span> tup.hash
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's make a `constructor proc` to make creation/initialization of our `FakeTable`,
  easier and faster than having to write `HashSet[KeyValue[K, V]]`,
  AND, to actually use a `FakeTable` type, since `HashSet[KeyValue[K, V]]`,
  is NOT a `FakeTable`

  This proc will once again be a generic, since a Table's key and value can be of almost any data type,
  we need 2x generic arguments `[K, V]` for the (key, value) fields of our `KeyValue` tuple.
  Then we give it 2x arguments of type `typedesc`, which is short for `typedescription`.
  `typedesc` which is a meta type to denote a type description and is required to make our fakeTable.
  If we instead make our 2x arguments: &quot;keyType: K, valueType: V&quot;,
  when we will try to use this proc, the Nim's VS Code extension will tell us that we have,
  a variable with `typedesc type, typedesc type`, instead of `type, type`.
  This is because we are giving types to our proc to make our HashSet[KeyValue[type, type]],
  and not some operation working with values of types already `initialized` outside of the `proc`

  And then we simply use the initialization proc for hashSets `initHashSet` of type KeyValue[type, type],
  to initialize our fakeTable of type `FakeTable`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> newFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-literal">result</span> = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]() <span class="hljs-comment">#Have to use `result =` with `runnableExamples:` present</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
      fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
      <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Now let's run the runnable example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
  <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **As you can see, initializing our fakeTable is much simpler than the original of:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Making a `OrderedSet` version of our constructor proc:**
  First we make another type just like with we did for our FakeTable type,
  but instead of using a `HashSet`, we use a `OrderedSet`.
  And then lastly, we simply rename the return type to `FakeOrderedTable`
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">OrderedSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]

  <span class="hljs-keyword">proc</span> newOrderedFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    initOrderedSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]()

    runnableExamples:
      <span class="hljs-keyword">var</span> fakeOrderedTable = newOrderedFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
      fakeOrderedTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
      <span class="hljs-keyword">echo</span> fakeOrderedTable, <span class="hljs-string">&quot; &quot;</span>, fakeOrderedTable.typeof

nbSection <span class="hljs-string">&quot;Overloading&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's move on to overloading ALL of the operations normal `sets` can use,
  here is the list from the `sets video`:

  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;incl&lt;/b&gt;&lt;/span&gt;(A, e)	same as A = A + e
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;excl&lt;/b&gt;&lt;/span&gt;(A, e)	same as A = A - e
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;card&lt;/b&gt;&lt;/span&gt;(A)	the cardinality of A (number of elements in A)
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;contains&lt;/b&gt;&lt;/span&gt;(A, e)	A contains element e
  -  e &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;in&lt;/b&gt;&lt;/span&gt; A	set membership (A contains element e)
  -  e &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;notin&lt;/b&gt;&lt;/span&gt; A	A does not contain element e
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;*&lt;/b&gt;&lt;/span&gt; b	Intersection
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;+&lt;/b&gt;&lt;/span&gt; b	Union
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;-&lt;/b&gt;&lt;/span&gt; b	Difference
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;==&lt;/b&gt;&lt;/span&gt; b	Set equality
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;&lt;=&lt;/b&gt;&lt;/span&gt; b	subset relation (a is subset of b or equal to b)
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;&lt;&lt;/b&gt;&lt;/span&gt; b	Check if a is a subset of b

  **As well as:**
  - \`[]\`(`[]` with apostrophes) so that we can find the value of a key, by supplying the key.
    Otherwise we have to supply the entire `tuple`.

  **And** `missingOrExcl(HashSet, key)` as an extra(only for hashSets, not normal Sets)

  Let's start with `contains(container, key)`, which is an alias for the `in` operator.
  So that we can easily find a `key` inside our `FakeTable`'s `KeyValue` tuple,
  and with that `key`, it's `value:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment"># `in` is an alias for `contains`, </span>
  <span class="hljs-keyword">proc</span> contains[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">if</span> tup.key == k:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, we make it a `generic` proc that takes our `FakeTable` type,
  unwraps the `fakeTable`, and then checks every `KeyValue` tuple's first field of `key`,
  against `k`, the key we are looking for, and then returns true or false if it found it or not.

  **Here is an example of it's usage:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fakeTableContains = newFakeTable(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)

  fakeTableContains.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>) <span class="hljs-comment">#elements as tuples</span>
  fakeTableContains.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>) <span class="hljs-comment">#elements as tuples</span>

  <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Key 2&quot;</span> <span class="hljs-keyword">in</span> fakeTableContains:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SUCCESS: Key 2 is in fakeTableContains&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's overload the \`[]\`(`[]` with apostrophes),
  to again, be able to easily find a `key` inside our `FakeTable`'s `KeyValue` tuple,
  and with that `key`, it's `value:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `[]`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-type">V</span> {.inline.} =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">if</span> tup.key == k:
        <span class="hljs-keyword">return</span> tup.value

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Very similar to the `contains`(`in` is the alias) overload.
  The strange part here is the `{.inline.}` pragma,
  which is simply there to mark it for the compiler(which will warn us) and us,
  that we should not call this proc `[]` directly,
  as in like a proc `[](arg1, arg2)`.

  **Here is the example of what that overload enables us:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> fakeTableContains
  <span class="hljs-keyword">echo</span> fakeTableContains[<span class="hljs-string">&quot;Key 1&quot;</span>]

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **NOTE:** All of these overloads have to focus on the `key` part of the `KeyValue` tuple,
  in order to achieve the functionality of a `Table`.
  Meaning, these overloads must make it so that we only work with the `keys`,
  and not `tuples`.

  Now let's overload the `+` operator(proc), which is the `union` between Set1 and Set2,
  meaning both sets.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key != tupB.key:
          <span class="hljs-literal">result</span>.incl tupA
          <span class="hljs-literal">result</span>.incl tupB
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The overload proc's head, could also put both arguments together like this:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **How it works:** Well, first of we unwrap the first `FakeTable`(HashSet[KeyValue[K, V]]) with a for loop,
  then we unwrap the second with another for loop on the second `FakeTable` of `b`,
  in order to -&gt; elementOfSet1.key != elementOfSet1.key -&gt; elementOfSet1.key != elementOfSet`2`.key -&gt; 
  and so on, until we compare every element's key of `a` against every element's key of `b`,
  in order to find only the `keys`, both `FakeTables` share,
  to return a `result` of the `union` of both `FakeTables`.

  Remember that `sets` do not allow for duplicate keys.
  Checking without the `.key` part, could result in duplicate keys,
  because, even though our `FakeTable` is a `HashSet` which doesn't allow for duplicate elements,
  it can only do so, if the `(key, value)` tuple elements we have in it,
  have both fields of our `KeyValue` tuple `(key, value)` exactly the same,
  as another `KeyValue` tuple `(key, value)`.
  Tuples are only equal if both tuples have both fields identical.

  This is why we must provide &quot;help&quot; to our `FakeTable`'s overload procs.

  **Now let's finally see an example of the `+` operator(proc) overload:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fTableA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> fTableB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  fTableA.incl (<span class="hljs-string">'A'</span>, <span class="hljs-number">1</span>)
  fTableA.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)

  fTableB.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)
  fTableB.incl (<span class="hljs-string">'C'</span>, <span class="hljs-number">3</span>)

  <span class="hljs-keyword">echo</span> fTableA + fTableB
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here we go, all the elements of both `FakeTables`, without duplicates.

  Now let's overload the `-` operator(proc) - Difference - Returns the elements that `fTableA` has,
  but `fTableB` does not.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `-`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">var</span> tempA = a
    <span class="hljs-keyword">var</span> tempB = b

    <span class="hljs-comment">#De-duplication</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key == tupB.key:
          tempA.excl(tupA)
          tempB.excl(tupB)

    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> tempA:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> tempB:
        <span class="hljs-keyword">if</span> tupA.key != tupB.key:
          <span class="hljs-keyword">if</span> tupA <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
            <span class="hljs-keyword">discard</span>
          <span class="hljs-keyword">else</span>:
            <span class="hljs-literal">result</span>.incl tupA
nbText: <span class="hljs-string">&quot;&quot;&quot;
  First of, we copy the 2 `FakeTable`s of `a` and `b` into temporary variables of `tempA` and `tempB`,
  because want to de-duplicate the `FakeTable`s and only return different elements,
  and we can't do that with the `FakeTables` we supplied to the 2x arguments of `a` and `b`Àô,
  because you can't modify arguments received.
  We also can't use `var` before `FakeTable` as in `a: var FakeTable`,
  because we would be modifying the original `FakeTable`s, which we don't want to do.

  So the second part marked with the #De-duplication comment,
  is where we unwrap both of the `FakeTables`,
  and check all the `keys` of the `KeyValue` tuples for identical keys/duplicates,
  and then remove them from both, because this isn't just to find and remove duplicates,
  but also because the `-` operator(proc), is supposed to only return the elements,
  that are not in `FakeTable` `b` - any duplicates/shared elements.

  And lastly, the third part then unwraps both `temp` `FakeTable`s,
  and looks for `different keys`, and also checks the `result` variable,
  because checking if the keys are not equal and then including `tupA`,
  the remaining keys WILL be different, and if both `FakeTable`s have 2x elements each,
  then both of the elements of `tupA`, would be added twice,
  requiring further de-duplication. Checking the `result` variable, fixes that.

  **Here is an example of manually going trough this overloaded `-` operator(proc):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">discard</span> <span class="hljs-comment">#nimib requires a return</span>
  <span class="hljs-comment">#a b c #a: FakeTable</span>
  <span class="hljs-comment">#c d e #b: FakeTable</span>
  <span class="hljs-comment">#De-duplication</span>
  <span class="hljs-comment">#a b</span>
  <span class="hljs-comment">#d e</span>
  <span class="hljs-comment">#1 a != d -&gt; yes adding `a`</span>
  <span class="hljs-comment">#2 a != e -&gt; yes adding `a` -&gt; duplicated `a` -&gt; hashSet detects that, removes it. BUT tuples != if not all fields are equal</span>
  <span class="hljs-comment">#3 b != d -&gt; yes adding `b`</span>
  <span class="hljs-comment">#4 b != e -&gt; yes adding `b`</span>
  <span class="hljs-comment">#result = {'a', 'a', 'b', 'b'} -&gt; correct if we deduplicate... this could go on to infinity.</span>
  <span class="hljs-comment">#So checking the `result` variable fixes the above problem</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  And here is the code for the above manual explanation:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> ftA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> ftB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  ftA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
  ftA.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
  ftA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

  ftB.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)
  ftB.incl (<span class="hljs-string">'d'</span>, <span class="hljs-number">40</span>)
  ftB.incl (<span class="hljs-string">'e'</span>, <span class="hljs-number">50</span>)

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA: &quot;</span>, ftA
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB: &quot;</span>, ftB

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA - ftB = &quot;</span>, ftA - ftB
nbTexT: <span class="hljs-string">&quot;&quot;&quot;
  And the reverse:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB - ftA = &quot;</span>, ftB - ftA

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now we will overload the `*` operator(proc) - intersection - returns only shared elements.
  This one is very simple, simply compare the keys, and add one of them into the `result`(since both are the same):
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `*`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key == tupB.key:
          <span class="hljs-literal">result</span>.incl tupA

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Example:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> ftA * ftB

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Next is `&lt;` operator(proc) overload - `a` subset of `b`
  First of, when using this operator, the `subset` HAS to be smaller than the set(FakeTable) we are comparing against.

  Which is easily achieved by first checking the lengths of the 2x `FakeTable`s:
    `if a.len &gt;= b.len: return false`, `else:` we continue.
  Then we set the `result` variable to `false`, unwrap the 2x `FakeTable`s,
  make a `block subsetA` statement, so that we can easily break out of the second loop once we find an identical key,
  after setting the `result` variable to `true`Àô.

  **This is for 2x reasons:** The first is for reasons of speed, we are checking every element of `FakeTable` `a`,
  against every element of `FakeTable` `b`, there are no duplicates, so once found, it's a waste to continue.

  And secondly, because we have to set the `result` variable to `false` if the keys are not identical,
  so that once loop 2 ends, and loop 1 is about to start another run of loop 2 with the next element,
  and we found no matching `keys`, then `FakeTable` `a` is NOT a subset of `FakeTable` `Àôb`.
  And because of that, if we don't break out back to loop 1 using the `labeled block` statement,
  we could find a matching key, but then on the second element override it to false!
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `&lt;`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">if</span> a.len &gt;= b.len:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">block</span> subsetA:
          <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
            <span class="hljs-keyword">if</span> tupA.key == tupB.key:
              <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
              <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
            <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here is an example:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">#ftA has 'a', 'b', 'c'</span>
  <span class="hljs-keyword">var</span> subsetOfA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  subsetOfA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
  subsetOfA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

  <span class="hljs-keyword">echo</span> ftA
  <span class="hljs-keyword">echo</span> subsetOfA
  <span class="hljs-keyword">echo</span> subsetOfA &lt; ftA

  <span class="hljs-keyword">var</span> subsetofA2 = ftA
  <span class="hljs-keyword">echo</span> subsetofA2 &lt; ftA
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `subsetofA2 is false because it is equal in size of `ftA`, again, has to be smaller.

  This isn't true for the `&lt;=` operator(proc), which does the exact same as `&lt;`,
  except that the subset can be equal in size.

  **Here is the code to overload `&lt;=` operator(proc):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `&lt;=`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">if</span> system.`&lt;=`(a.len, b.len): <span class="hljs-comment">#Can't do this: if a.len &lt;= b.len: -&gt; for some reason this overload calls itself instead of the system &lt;=</span>
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">block</span> subsetA:
          <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
            <span class="hljs-keyword">if</span> tupA.key == tupB.key:
              <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
              <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
            <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The only real change here compared to the `&lt;` overload,
  is that instead of checking for the `subset` to be smaller,
  we check for smaller or equal.
  Here i found a bit of a problem. For some reason when using the `&lt;=` operator,
  Nim calls the version we are in right now, instead of the `system` module one.
  So in order to tell it to use the correct one,
  we have to explicitly specify that with `system.` + **\`&lt;=\`** + `(a.len, b.len)`,
  instead of simply `a.len &lt;= b.len`.

  **Now let's also overload the `==` operator(proc)**,
  so that we are no longer comparing tuples, which require both fields to be equal for equivalence.
  With this overload we would only require the `keys`.

  With this overload, we also have to use the `system.` way of explicitly calling the system module's `==` operator.
  I am pretty sure, that the reason this happens, is for reasons of `recursion`,
  proc calling itself, like in the famous fibonacci sequence.

  In this overload's code i've also used the `in` alias of the `contains` overload we have done earlier,
  to make this easier, as well as a `continue` statement, instead of reversing that logic with a `notin` template.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `==`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">#until false</span>

    <span class="hljs-keyword">if</span> system.`==`(a.len, b.len): <span class="hljs-comment">#Cannot use: if a.len == b.len: -&gt; because of reasons of recursion</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">if</span> tupA.key <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">else</span>:
          <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>: 
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  And an example:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> a = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> b = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> c = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  a.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); a.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
  b.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); b.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)

  c.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); c.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

  <span class="hljs-keyword">echo</span> a == b
  <span class="hljs-keyword">echo</span> a == c
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here i have also used `;` which is optional in Nim,
  and allows for multiple operations to be used on a single line.
  I think it's quite useful for such small operations that work the same,
  to be put on a single line, instead of heavily spreading vertically.
  I don't recommend using the optional semicolon `;` for large operations,
  or different ones, most people don't like that,
  and it will hurt clarity and readability. But again, for same operations of such small scale, yes.

  **Now let's overload the `excl` proc(for Sets/HashSets)**, in order to simplify removal of `KeyValue` tuples,
  based on the `key` provided. `del` is the proc for doing this for `Tables`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> excl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>) =
    <span class="hljs-comment">#Since excluding/removing an element of a container while iterating over it with a `for` loop is an error,</span>
      <span class="hljs-comment">#iterating over a copy, and using the copy's data to remove from the original will avoid that problem</span>
    <span class="hljs-keyword">var</span> temp = fakeTable

    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> temp:
      <span class="hljs-keyword">if</span> tup.key == k:
        fakeTable.excl(tup)

nbText: <span class="hljs-string">&quot;&quot;&quot;
  We have to use the `var` keyword in the overload's definition/head for our `FakeTable` in order to remove a `key`,
  from the supplied `FakeTable`. Without `var` you only copy the argument's data.

  Example(using variables from above):
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> a
  a.excl(<span class="hljs-string">'a'</span>)
  <span class="hljs-keyword">echo</span> a

nbText <span class="hljs-string">&quot;&quot;&quot;
  **Now we will overload the `missingOrExcl` proc, that is available only to hashSets, NOT normal Sets.**
  `missingOrExcl` again, first excludes a `key` from a `HashSet`, and tells you if the `key` was already missing:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> missingOrExcl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> fakeTable:
      fakeTable.excl(k)
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Quite simple with the `excl` and `contains` proc overloads. 
  Without them, it would of been quite longer and harder to understand.

  **Here is an example from the `sets` module's example for `missingOrExcl` for `HashSet`s:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> s = newFakeTable(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)
  s.incl (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); s.incl (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); s.incl (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>); s.incl (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);

  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">4</span>) <span class="hljs-comment">#should be: true</span>
  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: false</span>
  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: true</span>

<span class="hljs-comment">#These sections are more of ideas or a guideline, they will probably change(update the above brainstorming when they do)</span>
<span class="hljs-comment">#missingOrExcl() is the last overload to do</span>
nbSection <span class="hljs-string">&quot;Tuple Unpacking&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  Since we have been dealing with `tuples` quite a lot in this video,
  it's time to explain and demonstrate `tuple unpacking`, which i did not show in the `Tuples video`,
  nor did it find any use in this one.

  Tuple unpacking is quite simple.

  You can use them to give values to multiple variables(`var`), constants(`const`) or immutable variable(`let`),
  at once. Like this:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> (v1, c1, l1) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

  <span class="hljs-keyword">echo</span> v1
  <span class="hljs-keyword">echo</span> c1
  <span class="hljs-keyword">echo</span> l1
nbText: <span class="hljs-string">&quot;&quot;&quot;
  You may also ommit assignment of any of them:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> (v2, _, l2) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

  <span class="hljs-keyword">let</span> (_, _, _) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Not sure why anyone would ommit all of them... but you can!

  All of this is treated as syntatic sugar for basically the following code(look at the first example):
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span>
    temporaryTuple = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
    v3 = temporaryTuple[<span class="hljs-number">0</span>]
    c3 = temporaryTuple[<span class="hljs-number">1</span>]
    l3 = temporaryTuple[<span class="hljs-number">2</span>]
nbText: <span class="hljs-string">&quot;&quot;&quot;
  I don't think i have ever shown this before, but yes, you can access any field of a `tuple`,
  without knowing the name of the field, especially useful for `anonymous` tuples like here(fields without names).
  I do recommend though, that you do use the `names` of the fields over the `index` when the `names` are present.

  (When tuple unpacking with tuples with numbers(literals) into `var` and `let` variables,
  they get assigned their values without a `temporaryTuple`)

  Since you can nest any container withing another container(array, seq, set, table, etc), 
  as well as data structure in a data structure(object, tuple),
  you can also use nested tuples for tuple unpacking, like this:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> returnsNestedTuple(): (<span class="hljs-built_in">int</span>, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>), <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) = (<span class="hljs-number">4</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

  <span class="hljs-keyword">let</span> (x, (_, y), _, z) = returnsNestedTuple()

nbText: <span class="hljs-string">&quot;&quot;&quot;
  I have NO ideas of a good example of tuple unpacking... in this entire endeavour of making a FakeTable,
  i had no use for it.

  This script is complete from our standpoint, time to send for review,
  and find what to do next.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
## OUTRO - AFTERWORDS

  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also follow me on twitter of the same name, and support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of offline tutorial.

### Thanks to my past and current Patrons
&lt;b&gt;Past Patrons:&lt;/b&gt;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)

&lt;b&gt;Current Patrons&lt;/b&gt;
- None

&lt;b&gt;Compiler information&lt;/b&gt;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option
- Timestamps:
  - 00:15 Start of video example
  
&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;

&lt;b&gt;LINKS:&lt;/b&gt;
- [Twitter](https://twitter.com/Kiloneie &quot;My Twitter&quot;)
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)

&lt;b&gt;LINKS to this video's subject:&lt;/b&gt;
- [typedesc](https://nim-lang.org/docs/manual.html#special-types-typedesc-t &quot;typedesc&quot;)
- [E.G.2. SDL2 documentation(in case SDL2_nim documentation missed something)](https://wiki.libsdl.org/APIByCategory &quot;Example link to an example video's subject&quot;)

&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>