<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css" integrity="sha512-USp+nLNMZ1hR0Ll/LpYDxIq47Ypcm3KfjIleOnyFrB1N5KfHLXjfPQD1wQlhv7kVHRRgPvNVtendDS72LyHviA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/monokai.min.css" integrity="sha512-z8wQkuDRFwCBfoj7KOiu1MECaRVoXx6rZQWL21x0BsVVH7JkqCp1Otf39qve6CrCycOOL5o9vgfII5Smds23rg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
    
    .nimislides-li {
      position: relative;
    }

    .nimislides-li::before {
      position: absolute;
    }
  
    </style>
  </head>
  <body>
  <div class="reveal">
    <div class="slides">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css" integrity="sha512-USp+nLNMZ1hR0Ll/LpYDxIq47Ypcm3KfjIleOnyFrB1N5KfHLXjfPQD1wQlhv7kVHRRgPvNVtendDS72LyHviA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/monokai.min.css" integrity="sha512-z8wQkuDRFwCBfoj7KOiu1MECaRVoXx6rZQWL21x0BsVVH7JkqCp1Otf39qve6CrCycOOL5o9vgfII5Smds23rg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.js" integrity="sha512-9dFFU5pcR8K4bvw4ng6mLMW5IjslYbA57amHEMtHn3TT9RkKivsDabKffqjUUJ4pCaojAyH05T1OESld199Gcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js" integrity="sha512-RCedMo/DOyawQOh4zYtqEHTZAfgrrVQctN3LVCX5kELGsN52TOdwZ8inRY0l9Mo4vtyDFn6oOAgRUilWXgb+wA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js" integrity="sha512-MZ7Ehjbh2soaeCZJGaw6vBNAa7+eunl0SUmRPNESchLlboH73lHLEeUa6pZJ2Pcui4NcpDFatr6M+VlcmaH1QA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/math/math.min.js" integrity="sha512-skPZpuRwuUAnF9iEEFBXc4zJaucKcHUDgY1wDBTv0ILy82C2gn8MJsbcinzj2u8r/iZjD/78HRgw2/n//poOhQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
      <style>
table tbody tr:nth-child(2n) {
  background: 0;
}
</style>
      <section data-nimib-slide-number="1" >
      <h2>Table of Contents:</h2>
<ol>
<li><a href="#what-is-hashing-?">What is hashing ?</a></li>
<li><a href="#hashing-in-nim">Hashing in Nim</a></li>
<li><a href="#hashing-keys-with-hashtables">Hashing keys with hashTables</a></li>
<li><a href="#hashsets">hashSets</a></li>
<li><a href="#hashset-use-cases">hashSet use cases</a></li>
</ol>
      </section>
      <section data-nimib-slide-number="2" >
      <section data-nimib-slide-number="3" >
      <h2 class="r-fit-text"> <p>hashSets, more on hashTables and hashing</p> </h2>
      </section>
      <section data-nimib-slide-number="4" >
      <aside class="notes">
  <p>(What is the purpose of this video ?)</p>

</aside>
      <p>In this video, we will go over hashSets and hashes that are used with hashSets, as well as hashing in general in the world.
We will also refresh our memory on Tables(hashTables), and add some more on that knowledge.</p>
      </section>
      <section data-nimib-slide-number="5" >
      <p>The code for this video and it's script/documentation styled with nimib, is in the link in the description as a form of offline tutorial.</p>
      </section>
      </section>
      <section data-nimib-slide-number="6" >
      <section data-nimib-slide-number="7" >
      <p><a name = "what-is-hashing-?"></a></p>
<h1>What is hashing ?</h1>
<hr />
      </section>
      <section data-nimib-slide-number="8" >
      <div class="fragment fade-in" data-fragment-index="0" data-fragment-index-nimib="0"> 
  
      <p>First of, we have already used a bit of hashing in my Tables video without even knowing it.</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="1" data-fragment-index-nimib="1"> 
  
      <p>The 'tables' module uses variants of an efficient hashTable(dictionaries in other programming languages).</p>
      </div>
  
      </section>
      <section data-nimib-slide-number="9" >
      <p>Hashing is the process of transforming any given key or string, into a usually another shorter and more efficient value, by the use of a one way mathematical hashing algorithm/function.</p>
      </section>
      <section data-nimib-slide-number="10" >
      <p>One way algorithms are used, because Hashes are also used for encrypting data, and a 2 way algorithm would fail that.</p>
      </section>
      <section data-nimib-slide-number="11" >
      <p>The most popular use for hashing, is the usage of hash tables.</p>
      </section>
      <section data-nimib-slide-number="12" >
      <div class="fragment fade-in" data-fragment-index="2" data-fragment-index-nimib="2"> 
  
      <p>A hash table stores key and value pairs, in a list that is accessible trough it's index.</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="3" data-fragment-index-nimib="3"> 
  
      <p>Because key and value pairs are unlimited, the hash function will map the keys to the table size. A hash value then becomes the index for a specific element.</p>
      </div>
  
      </section>
      <section data-nimib-slide-number="13" >
      <div class="fragment fade-in" data-fragment-index="4" data-fragment-index-nimib="4"> 
  
      <p>Hashing is used in data indexing and retrieval, digital signatures, cybersecurity and cryptography.</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="5" data-fragment-index-nimib="5"> 
  
      <p>They are also used on some websites, especially those dedicated to Linux OSs and programs,</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="6" data-fragment-index-nimib="6"> 
  
      <p>to check your checksum(Secure Hash Algorithm/SHA, Message-Digest functions/MD), against the one on their website,</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="7" data-fragment-index-nimib="7"> 
  
      <p>to ensure it is exactly the same, without any tampering by a malicious person.</p>
      </div>
  
      </section>
      <section data-nimib-slide-number="14" >
      <div class="fragment fade-in" data-fragment-index="8" data-fragment-index-nimib="8"> 
  
      <p>There are several modules in nim, for dealing with hash function algorithms:</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="9" data-fragment-index-nimib="9"> 
  
      <p><code>nimble install checksum</code> before use, of the <code>Sha</code> and <code>MD5</code> modules</p>
      </div>
  
      <div style="text-align: left;">
      <ol>
      <div class="fragment fade-in" data-fragment-index="10" data-fragment-index-nimib="10"> 
  
      <li class="fragment fade-in-then-semi-out  nimislides-li" data-fragment-index="10" data-fragment-index-nimib="10">
      <p>Sha1(old, used for legacy purposes</p>
      </li>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="11" data-fragment-index-nimib="11"> 
  
      <li class="fragment fade-in-then-semi-out  nimislides-li" data-fragment-index="11" data-fragment-index-nimib="11">
      <p>Sha2(newer, but still insufficient for data security)</p>
      </li>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="12" data-fragment-index-nimib="12"> 
  
      <li class="fragment fade-in-then-semi-out  nimislides-li" data-fragment-index="12" data-fragment-index-nimib="12">
      <p>Sha3(newest, use this one)</p>
      </li>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="13" data-fragment-index-nimib="13"> 
  
      <li class="fragment fade-in-then-semi-out  nimislides-li" data-fragment-index="13" data-fragment-index-nimib="13">
      <p>MD5</p>
      </li>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="14" data-fragment-index-nimib="14"> 
  
      <li class="fragment fade-in-then-semi-out  nimislides-li" data-fragment-index="14" data-fragment-index-nimib="14">
      <p>Base64(for encoding and decoding data)</p>
      </li>
      </div>
  
      </ol>
      </div>
      <div class="fragment fade-in" data-fragment-index="15" data-fragment-index-nimib="15"> 
  
      <p>The usage of hashing in data structure, is used for the reasons of speed.</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="16" data-fragment-index-nimib="16"> 
  
      <p>It is much faster to find something if the value, is much smaller than the original in a large database</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="17" data-fragment-index-nimib="17"> 
  
      <p>There is a phenomenon called <code>collision</code>, which is when 2x or more hashes manage to generate an identical hash.</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="18" data-fragment-index-nimib="18"> 
  
      <p>Different hash functions have different margin of collisions. To address this, there are methods like:</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="19" data-fragment-index-nimib="19"> 
  
      <p>Double hashing</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="20" data-fragment-index-nimib="20"> 
  
      <p>Linear probing</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="21" data-fragment-index-nimib="21"> 
  
      <p>Quadratic probing</p>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="22" data-fragment-index-nimib="22"> 
  
      <p>Separate chaining(making every hash table cell point to linked lists of records with identical hash function values)</p>
      </div>
  
      </section>
      <section data-nimib-slide-number="15" >
      <pre><code>In cybersecurity, they can go a step further with the term Salting.
Which is adding random data into the hash function. It helps with attackers from accessing non-unique passwords,
by the use of rainbow tables(reverse engineered data)
</code></pre>
      </section>
      </section>
      <section data-nimib-slide-number="16" >
      <p><a name = "hashing-in-nim"></a></p>
<h1>Hashing in Nim</h1>
<hr />
      <p>Hey Araq, what is the default hash function used with hash() procs ?</p>
      <div class="fragment fade-in" data-fragment-index="23" data-fragment-index-nimib="23"> 
  
      <pre><code>  First of, hashSets are allocated on the heap.
</code></pre>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="24" data-fragment-index-nimib="24"> 
  
      <pre><code>  You can hash just about any data type in Nim. 
  There is no list of what you can, but mostly everything. 
</code></pre>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="25" data-fragment-index-nimib="25"> 
  
      <pre><code>  You can easily hash your own data types, 
  but first you must use a bit of skeleton/boilerplate code to do so.
</code></pre>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="26" data-fragment-index-nimib="26"> 
  
      <pre><code>  The following 2 examples are taken from the hashes module page, 
  that are required for your own data types:
</code></pre>
      </div>
  
      <section data-nimib-slide-number="17" >
      <aside class="notes">
  <p>Show, don't tell</p>

</aside>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> std/hashes

<span class="hljs-keyword">type</span>
  <span class="hljs-type">Something</span> = <span class="hljs-keyword">object</span>
    foo: <span class="hljs-built_in">int</span>
    bar: <span class="hljs-built_in">string</span>

<span class="hljs-keyword">iterator</span> items(x: <span class="hljs-type">Something</span>): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">yield</span> hash(x.foo)
  <span class="hljs-keyword">yield</span> hash(x.bar)

<span class="hljs-keyword">proc</span> hash(x: <span class="hljs-type">Something</span>): <span class="hljs-type">Hash</span> =
  <span class="hljs-comment">## Computes a Hash from `x`.</span>
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>
  <span class="hljs-comment"># Iterate over parts of `x`.</span>
  <span class="hljs-keyword">for</span> xAtom <span class="hljs-keyword">in</span> x:
    <span class="hljs-comment"># Mix the atom with the partial hash.</span>
    h = h !&amp; xAtom
  <span class="hljs-comment"># Finish the hash.</span>
  <span class="hljs-literal">result</span> = !$h</code></pre>
      </section>
      <div class="fragment fade-in" data-fragment-index="27" data-fragment-index-nimib="27"> 
  
      <pre><code>If your custom types contain fields for which there already is a &quot;hash&quot; proc,
you can simply hash together the hash values of the individual fields,
no need for the overload of the &quot;items&quot; iterator:
</code></pre>
      <aside class="notes">
  <p>Show, don't tell</p>

</aside>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> std/hashes

<span class="hljs-keyword">type</span>
  <span class="hljs-type">Something2</span> = <span class="hljs-keyword">object</span>
    foo: <span class="hljs-built_in">int</span>
    bar: <span class="hljs-built_in">string</span>

<span class="hljs-keyword">proc</span> hash(x: <span class="hljs-type">Something2</span>): <span class="hljs-type">Hash</span> =
  <span class="hljs-comment">## Computes a Hash from `x`.</span>
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>
  h = h !&amp; hash(x.foo)
  h = h !&amp; hash(x.bar) <span class="hljs-comment"># &quot;!&amp;&quot; Mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value(only for custom types)</span>
  <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># &quot;!$&quot; Finishes the computation of the hash value(only for custom types)</span></code></pre>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="28" data-fragment-index-nimib="28"> 
  
      <pre><code>**Important:** Use -d:nimPreviewHashRef to enable hashing refs.
It is expected that this behaviour becomes the new default in upcoming versions.

**Note:** If the type has &quot;==&quot; operator, the following must hold:
If two values compare equal, their hashes must also be equal.

- Now let's continue by hashing some simple data types that normal Sets can't use,
like strings, sequences and objects(don't forget to import the hashes module).
</code></pre>
      </div>
  
      <div class="fragment fade-in" data-fragment-index="29" data-fragment-index-nimib="29"> 
  
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> std/hashes

<span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;Hello, World&quot;</span>
<span class="hljs-keyword">let</span> hashedData = data.hash

<span class="hljs-keyword">echo</span> data
<span class="hljs-keyword">echo</span> hashedData</code></pre><pre style="width: 100%;"><samp class="hljs">Hello, World
1798448400</samp></pre>
      </div>
  
      <p>As you can see, the hashed result is a random like number, which we could use with tables as a hashed key.</p>
<p>Now let's how it looks like for sequences:
(show, don't tell)</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">let</span> seqData = @[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]
<span class="hljs-keyword">let</span> hashedSeqData = seqData.hash

<span class="hljs-keyword">echo</span> seqData
<span class="hljs-keyword">echo</span> hashedSeqData</code></pre><pre style="width: 100%;"><samp class="hljs">@[1, 3, 5, 7]
-5765842931636332056</samp></pre>
      <p>And now for objects:
(show, don't tell)</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">type</span>
  <span class="hljs-type">Student</span> = <span class="hljs-keyword">object</span>
    name: <span class="hljs-built_in">string</span>
    id: <span class="hljs-built_in">int</span>

<span class="hljs-keyword">let</span> person = <span class="hljs-type">Student</span>(name: <span class="hljs-string">&quot;Kiloneie&quot;</span>, id: <span class="hljs-number">404</span>)
<span class="hljs-keyword">let</span> hashedPerson = person.hash

<span class="hljs-keyword">echo</span> person
<span class="hljs-keyword">echo</span> hashedPerson</code></pre><pre style="width: 100%;"><samp class="hljs">(name: &quot;Kiloneie&quot;, id: 404)
-1951849001622500428</samp></pre>
      <p>Lots of quite long random looking, hashed values.</p>
<p>Now let's try using a hashTable, hash the key, then reinsert to get the value.</p>
      </section>
      <section data-nimib-slide-number="18" >
      <p><a name = "hashing-keys-with-hashtables"></a></p>
<h1>Hashing keys with hashTables</h1>
<hr />
      <p>Now we are going to play around with hashTables a bit,
to have you understand what you can do with hashes,
other than be more efficient values and enable hashSets to have just about any data type.</p>
<p>But first, let me tell you about all the different variants of hash tables.
Besides the normal hash tables i have shown in the Tables video(Table),
there is also OrderedTable which remembers the element insertion order.
Then there is the CountTable for mapping from a key to it's number of occurrences.</p>
<p>And lastly, there a Ref/Reference versions of each, with &quot;Ref&quot; affixed/appended at the end like so:
- TableRef
- OrderedTableRef
- CountTableRef</p>
<p>In case it wasn't clear on when to use Tables(hashTables) in Nim, here are a few examples/use cases:
- Whenever you have 2 pieces of data that you want linked together(e.g. your phone contacts -&gt; name : number)
- Games/music listing on your computer(name of the game/music as key : value as location)
- When generating JSON(lightweight data-interchange format), before it gets stringified, it's represented as a Table(dictionary)
- Nested Tables(example 2 below)</p>
<p>Now let's make a new hashTable and hash one of it's keys and then reinsert it back:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> tables

<span class="hljs-keyword">var</span> tData = {<span class="hljs-number">1.</span>hash: <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;two&quot;</span>}.toTable
<span class="hljs-keyword">echo</span> tData

<span class="hljs-keyword">echo</span> tData[<span class="hljs-number">8641844181895329213</span>]
<span class="hljs-keyword">echo</span> tData[<span class="hljs-number">2</span>]</code></pre><pre style="width: 100%;"><samp class="hljs">{8641844181895329213: &quot;one&quot;, 2: &quot;two&quot;}
one
two</samp></pre>
      <p>Here we go, it worked perfectly.</p>
<p>Example 2: You can nest hashTables to create accounts that have usernames and passwords linked together like this:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> passwordIndex = {<span class="hljs-string">&quot;Account 1&quot;</span> : {<span class="hljs-string">&quot;Username&quot;</span> : <span class="hljs-string">&quot;littleMouse&quot;</span>, <span class="hljs-string">&quot;Password&quot;</span> : <span class="hljs-string">&quot;Ter3456fgdgh&quot;</span>}.toTable, 
                    <span class="hljs-string">&quot;Account 2&quot;</span> : {<span class="hljs-string">&quot;Username&quot;</span> : <span class="hljs-string">&quot;bigDog&quot;</span>, <span class="hljs-string">&quot;Password&quot;</span> : <span class="hljs-string">&quot;mashthatkeyboard&quot;</span>}.toTable}.toTable

<span class="hljs-keyword">echo</span> passwordIndex</code></pre><pre style="width: 100%;"><samp class="hljs">{&quot;Account 2&quot;: {&quot;Password&quot;: &quot;mashthatkeyboard&quot;, &quot;Username&quot;: &quot;bigDog&quot;}, &quot;Account 1&quot;: {&quot;Password&quot;: &quot;Ter3456fgdgh&quot;, &quot;Username&quot;: &quot;littleMouse&quot;}}</samp></pre>
      <p>Obviously if you don't like the random order, you can make an ordered table instead.</p>
<p>Now let's proceed to hashSets.</p>
      </section>
      <section data-nimib-slide-number="19" >
      <p><a name = "hashsets"></a></p>
<h1>hashSets</h1>
<hr />
      <p>Now let's make the simplest hashSet data type a normal Set cannot use, String.
We cannot declare an empty hashSets, it can only be initialized.
So this example is just for show, since every hashSet is always initialized
in this same way by default anyways.
We are going to need the &quot;sets&quot; module for all hashSets.</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> sets
<span class="hljs-keyword">var</span> emptyHashSet = initHashSet[<span class="hljs-built_in">string</span>]()

<span class="hljs-keyword">echo</span> emptyHashSet</code></pre><pre style="width: 100%;"><samp class="hljs">{}</samp></pre>
      <p>Now the initialization version:
(show, don't tell)</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> hashedString = [<span class="hljs-string">&quot;Hello, World!&quot;</span>].toHashSet

<span class="hljs-keyword">echo</span> hashedString</code></pre><pre style="width: 100%;"><samp class="hljs">{&quot;Hello, World!&quot;}</samp></pre>
      <p>Now remember that the order of the elements is unordered, not the value of an element.</p>
<p>Now let's have a look on how hashSets and hashTables look like in procs:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">proc</span> paramHashSet(data: <span class="hljs-type">HashSet</span>): <span class="hljs-type">HashSet</span> = <span class="hljs-comment"># data: initHashSet[string]() does NOT work</span>
  data

<span class="hljs-keyword">proc</span> paramHashTable(data: <span class="hljs-type">Table</span>): <span class="hljs-type">Table</span> = <span class="hljs-comment">#same for hashTables</span>
  data

<span class="hljs-keyword">proc</span> initParamHashTable(data = {<span class="hljs-number">1</span>: <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;two&quot;</span>}.toTable) =
  <span class="hljs-keyword">echo</span> data <span class="hljs-comment">#We have to use this &quot;data&quot;, the compiler will not let us return it with the &quot;result&quot; variable, it must be used right here</span>

<span class="hljs-keyword">echo</span> paramHashSet([<span class="hljs-number">3.14</span>].toHashSet)
<span class="hljs-keyword">echo</span> paramHashTable({<span class="hljs-number">1</span>: <span class="hljs-string">&quot;one&quot;</span>}.toTable)
initParamHashTable()</code></pre><pre style="width: 100%;"><samp class="hljs">{3.14}
{1: &quot;one&quot;}
{2: &quot;two&quot;, 1: &quot;one&quot;}</samp></pre>
      <p>There is an additional operation you can do with hashSets that you cannot do with normal Sets, which is symmetricDifference(s1, s2).
symmetricDifference(s1, s2). &quot;-+-&quot; is the alias for that proc. This proc gives you only the elements that are not present in both sets at the same time.
E.g. if setA['a', 'b'] -+- setB['b', 'c'] = ['a', 'c'] because 'a' is only in one of them, and the same goes for 'c'. 'b' is in both of them so it gets excluded from this list.</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">let</span> setSD1 = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">20</span>)].toHashSet <span class="hljs-comment">#Anonymous tuple - must be inside [], and tuples require (,) -&gt; [()]</span>
<span class="hljs-keyword">let</span> setSD2 = [(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-number">20</span>), (<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-number">30</span>)].toHashSet

<span class="hljs-keyword">echo</span> setSD1
<span class="hljs-keyword">echo</span> setSD2
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>
<span class="hljs-keyword">echo</span> setSD1 -+- setSD2</code></pre><pre style="width: 100%;"><samp class="hljs">{(&quot;key1&quot;, 10), (&quot;key2&quot;, 20)}
{(&quot;key3&quot;, 30), (&quot;key2&quot;, 20)}

{(&quot;key3&quot;, 30), (&quot;key1&quot;, 10)}</samp></pre>
      <p>There is also disjoint(s1, s2: bool) returns true if the sets s1 and s2 have no items in common,</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">let</span> setD1 = [<span class="hljs-number">9223372036854775807</span>, -<span class="hljs-number">9223372036854775807</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].toHashSet <span class="hljs-comment">#9,223,372,036,854,775,807 or -/negative of that value is the max value of int64</span>
<span class="hljs-keyword">let</span> setD2 = [<span class="hljs-number">2147483648</span>, -<span class="hljs-number">2147483648</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].toHashSet <span class="hljs-comment">#2,147,483,647 or -/negative of that value, is the max value of int32, had to add +1 and -1 at the end  to make them int64, otherwise disjoint won't work</span>

<span class="hljs-keyword">echo</span> setD1
<span class="hljs-keyword">echo</span> setD2
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>
<span class="hljs-keyword">echo</span> disjoint(setD1, setD2)</code></pre><pre style="width: 100%;"><samp class="hljs">{2, 9223372036854775807, -9223372036854775807, 1}
{2147483648, 2, -2147483648, 1}

false</samp></pre>
      <p>missingOrExcl(s, key) Excludes a key and tells you if the key was already missing from &quot;s&quot;. (no proc for missingOrIncl)</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> setMOE = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].toOrderedSet <span class="hljs-comment">#So we can see the content of the set easier</span>

<span class="hljs-keyword">echo</span> setMOE

<span class="hljs-keyword">if</span> setMOE.missingOrExcl(<span class="hljs-number">1</span>) == <span class="hljs-literal">true</span>:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>, <span class="hljs-string">&quot; true&quot;</span>
<span class="hljs-keyword">else</span>: <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;false&quot;</span>

<span class="hljs-keyword">if</span> setMOE.missingOrExcl(<span class="hljs-number">1</span>) == <span class="hljs-literal">true</span>:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>, <span class="hljs-string">&quot; true&quot;</span>
<span class="hljs-keyword">else</span>: <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;false&quot;</span>

<span class="hljs-keyword">echo</span> setMOE</code></pre><pre style="width: 100%;"><samp class="hljs">{1, 2, 3, 4, 5}
false
1 true
{2, 3, 4, 5}</samp></pre>
      <p>containsOrIncl(s, key) Includes a key in the set &quot;s&quot; and tells if key was already in &quot;s&quot;.
Inverse of missingOrExcl(s, key)</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> setCOI = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].toOrderedSet <span class="hljs-comment">#So we can see the content of the set easier</span>

<span class="hljs-keyword">echo</span> setCOI

<span class="hljs-keyword">block</span> <span class="hljs-type">COI</span>:
  <span class="hljs-keyword">if</span> setCOI.containsOrIncl(<span class="hljs-number">6</span>) == <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;6 was already in setCOI&quot;</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;6 is not is setCOI, adding&quot;</span>

  <span class="hljs-keyword">if</span> setCOI.containsOrIncl(<span class="hljs-number">6</span>) == <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;6 was already in setCOI&quot;</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;6 is not is setCOI, adding&quot;</span></code></pre><pre style="width: 100%;"><samp class="hljs">{1, 2, 3, 4, 5}
6 is not is setCOI, adding
6 was already in setCOI</samp></pre>
      <p>map(data, op) Returns a new set after applying &quot;op&quot; proc(anonymous proc) on each of the elements of &quot;data&quot;set.
Here is a simple example from the Sets module that demonstrates the &quot;map&quot; proc very well:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">let</span> <span class="hljs-comment">#using &quot;let&quot; since we wont be changing it with &quot;b&quot;</span>
  a = toHashSet([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
  b = a.map(<span class="hljs-keyword">proc</span> (x: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">string</span> = $x)

<span class="hljs-keyword">echo</span> a
<span class="hljs-keyword">echo</span> b</code></pre><pre style="width: 100%;"><samp class="hljs">{3, 2, 1}
{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}</samp></pre>
      <p>And here is my example at this proc:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">let</span> setM = [<span class="hljs-string">&quot;lowercase&quot;</span>, <span class="hljs-string">&quot;UPPERCASE&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>].toHashSet <span class="hljs-comment">#using &quot;let&quot; since we wont be changing it</span>

<span class="hljs-keyword">let</span> setNewL = setM.map(<span class="hljs-keyword">proc</span> (elem: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> = 
  <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> elem:
    <span class="hljs-keyword">if</span> c.isLowerAscii == <span class="hljs-literal">true</span>:
      <span class="hljs-literal">result</span> = elem)

<span class="hljs-keyword">let</span> setNewU = setM.map(<span class="hljs-keyword">proc</span> (elem: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> = 
  <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> elem:
    <span class="hljs-keyword">if</span> c.isLowerAscii != <span class="hljs-literal">true</span>:
      <span class="hljs-literal">result</span> = elem)
  
<span class="hljs-keyword">echo</span> setNewL
<span class="hljs-keyword">echo</span> setNewU</code></pre><pre style="width: 100%;"><samp class="hljs">{&quot;&quot;, &quot;l&quot;, &quot;lowercase&quot;}
{&quot;U&quot;, &quot;&quot;, &quot;UPPERCASE&quot;}</samp></pre>
      <p>Not sure why there is a third empty &quot;&quot; element in the new sets...</p>
      <p>clear(s) Clears the hashSet back to an empty state, without shrinking any of the existing storage.</p>
<p>QUESTION FOR ARAQ, DO READ THIS PLEASE:
Araq, does this mean that the size is of type X's size + whatever the extra size of making it a hashSet is ?
or does it mean that if we had 10x elements of type &quot;string&quot;, the size will be default hashSet size + 10x string elements ?</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">discard</span></code></pre>
      <p>pop(s) Removes and returns an element from the set &quot;s&quot;. Not sure what this is useful for,
since it gives us no control. We can have some control with an ordered hashSet,
but popping a specific element would take a long of computing time...</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> myHashSet = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>].toHashSet
<span class="hljs-keyword">var</span> orderedSet = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>].toOrderedSet

<span class="hljs-keyword">echo</span> myHashSet.pop <span class="hljs-comment">#Doesn't let me specify what to pop... proc pop only has 1x argument</span>
<span class="hljs-keyword">echo</span> myHashSet.pop
<span class="hljs-keyword">echo</span> myHashSet.pop

<span class="hljs-keyword">if</span> myHashSet.len != <span class="hljs-number">0</span>:
  <span class="hljs-keyword">echo</span> myHashSet.pop
<span class="hljs-keyword">else</span>:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;myHashSet is empty&quot;</span></code></pre><pre style="width: 100%;"><samp class="hljs">a
b
c
myHashSet is empty</samp></pre>
      <p>There is a use case for the &quot;pop&quot; proc. For example if you have a pool of jobs to be done in no particular order.
Let's say that on weekends you clean your room, do your laundry, change the sheets, etc. That job only requires to be done once.
So you would use a doTheJob()/processJob() proc that woould &quot;pop&quot; a job from your pool of jobs and execute it.
Once all the jobs are done, you can put the exact same ones back in when weekend comes, or some relatives are coming to visit.
Here is an example:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">proc</span> executeJob(job: <span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">echo</span> job, <span class="hljs-string">&quot; finished&quot;</span>

<span class="hljs-keyword">var</span> jobs = [<span class="hljs-string">&quot;laundry&quot;</span>, <span class="hljs-string">&quot;sh8eets&quot;</span>, <span class="hljs-string">&quot;cleaning&quot;</span>].toHashSet

<span class="hljs-keyword">while</span> jobs.len != <span class="hljs-number">0</span>:
  <span class="hljs-keyword">let</span> job = jobs.pop
  job.executeJob</code></pre><pre style="width: 100%;"><samp class="hljs">sh8eets finished
cleaning finished
laundry finished</samp></pre>
      <p>And lastly &quot;[]&quot; - Which returns the element that is actually stored in &quot;s&quot; which has the same value as &quot;key&quot; or raises the &quot;KeyError&quot; exception.
This is useful when one overloaded the &quot;hash&quot; proc and the &quot;==&quot; operator, but still needs reference semantics for sharing.</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">var</span> setWithAKey = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;tree&quot;</span>].toHashSet
<span class="hljs-keyword">echo</span> setWithAKey[<span class="hljs-string">&quot;one&quot;</span>], <span class="hljs-string">&quot; &quot;</span>, setWithAKey[<span class="hljs-string">&quot;one&quot;</span>].<span class="hljs-keyword">type</span></code></pre><pre style="width: 100%;"><samp class="hljs">one string</samp></pre>
      </section>
      <section data-nimib-slide-number="20" >
      <p><a name = "hashset-use-cases"></a></p>
<h1>hashSet use cases</h1>
<hr />
      <p>One of the hashSet uses cases is very similar to the last use case example of the previous video of normal Sets.
The example being, splitting a string based on character elements as separators.
With hashSets, we can go a step further. We can use whole words as separators.
So let's use the split() proc we made in the last tutorial and update it for string hashSets.
We are also going to add another argument of type bool, to tell the proc if we are working with set[char],
or hashSet[string]. Currently the compiler cannot infer which to use,
since the second argument of &quot;seps&quot; is not an argument we can give, since it is already initialized.</p>
      <p>Original version:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> strutils

<span class="hljs-keyword">proc</span> split(s: <span class="hljs-built_in">string</span>; seps: <span class="hljs-built_in">set</span>[<span class="hljs-built_in">char</span>] =  {<span class="hljs-string">' '</span>, <span class="hljs-string">'!'</span>, <span class="hljs-string">'?'</span>}): <span class="hljs-built_in">string</span> = 
  <span class="hljs-keyword">var</span> splitString = s
  <span class="hljs-keyword">var</span> c: <span class="hljs-built_in">int</span>

  <span class="hljs-keyword">for</span> sep <span class="hljs-keyword">in</span> seps:
    c = splitString.find(sep)
    splitString.delete(c, c)
  
  <span class="hljs-literal">result</span> = splitString
        
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">&quot;Hello , World !?&quot;</span> 
<span class="hljs-keyword">echo</span> myString

<span class="hljs-keyword">echo</span> myString.split</code></pre><pre style="width: 100%;"><samp class="hljs">Hello , World !?
Hello, World </samp></pre>
      <p>Modified version:</p>
      <pre style="width: 100%"><code class="nim hljs" data-noescape data-line-numbers><span class="hljs-keyword">import</span> strutils

<span class="hljs-keyword">proc</span> split(s: <span class="hljs-built_in">string</span>; useNormalSet: <span class="hljs-built_in">bool</span>): <span class="hljs-built_in">string</span> = 
  <span class="hljs-keyword">if</span> useNormalSet == <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">var</span> seps: <span class="hljs-built_in">set</span>[<span class="hljs-built_in">char</span>] =  {<span class="hljs-string">' '</span>, <span class="hljs-string">'!'</span>, <span class="hljs-string">'?'</span>}
    <span class="hljs-keyword">var</span> splitString = s
    <span class="hljs-keyword">var</span> c: <span class="hljs-built_in">int</span>

    <span class="hljs-keyword">for</span> sep <span class="hljs-keyword">in</span> seps:
      c = splitString.find(sep)
      splitString.delete(c, c) 
      
    <span class="hljs-literal">result</span> = splitString
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">discard</span>
    <span class="hljs-keyword">var</span> seps = [<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>].toHashSet
    <span class="hljs-keyword">var</span> splitString = s
    <span class="hljs-keyword">var</span> c: <span class="hljs-built_in">int</span>

    <span class="hljs-keyword">for</span> sep <span class="hljs-keyword">in</span> seps:
      c = splitString.find(sep)

      <span class="hljs-keyword">if</span> (c + sep.len) &lt; splitString.len:
        splitString.delete(c, c+sep.len)
  
    <span class="hljs-literal">result</span> = splitString
        
<span class="hljs-keyword">echo</span> myString.split(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;I have a var, a const, and a let me in pony&quot;</span>.split(<span class="hljs-literal">false</span>) <span class="hljs-comment">#43 length</span></code></pre><pre style="width: 100%;"><samp class="hljs">Hello, World 
I have a  a  and a me in pony</samp></pre>
      </section>
      <section data-nimib-slide-number="21" >
      <h2>OUTRO - AFTERWORDS</h2>
<pre><code>Okay, that's it for this video, thanks for watching like, share and subscribe, 
  aswell as click the bell icon if you liked it and want more, 
  you can also follow me on twitter of the same name, and support me on Patreon. 
  If you had any problems with any part of the video, 
  let me know in the comment section, 
  the code of this video, script and documentation, are in the link in the description,
  as a form of offline tutorial.
</code></pre>
<h3>Thanks to my past and current Patrons</h3>
<p><b>Past Patrons:</b></p>
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<p><b>Current Patrons</b></p>
<ul>
<li>None</li>
</ul>
<p><b>Compiler information</b></p>
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option</li>
<li>Timestamps:
<ul>
<li>00:15 Start of video example</li>
</ul>
</li>
</ul>
      <p><b>LINKS:</b></p>
<ul>
<li><a href="https://twitter.com/Kiloneie" title="My Twitter">Twitter</a></li>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li>Video's script/documentation with all of the code styled with nimib as a form of offline tutorial:</li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<p><b>LINKS to this video's subject:</b></p>
<ul>
<li><a href="https://vladar4.github.io/sdl2_nim/" title="Example link to an example video's subject">E.G.1. SDL2_nim documentation</a></li>
<li><a href="https://wiki.libsdl.org/APIByCategory" title="Example link to an example video's subject">E.G.2. SDL2 documentation(in case SDL2_nim documentation missed something)</a></li>
</ul>
      </section>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.js" integrity="sha512-9dFFU5pcR8K4bvw4ng6mLMW5IjslYbA57amHEMtHn3TT9RkKivsDabKffqjUUJ4pCaojAyH05T1OESld199Gcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js" integrity="sha512-RCedMo/DOyawQOh4zYtqEHTZAfgrrVQctN3LVCX5kELGsN52TOdwZ8inRY0l9Mo4vtyDFn6oOAgRUilWXgb+wA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js" integrity="sha512-MZ7Ehjbh2soaeCZJGaw6vBNAa7+eunl0SUmRPNESchLlboH73lHLEeUa6pZJ2Pcui4NcpDFatr6M+VlcmaH1QA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/math/math.min.js" integrity="sha512-skPZpuRwuUAnF9iEEFBXc4zJaucKcHUDgY1wDBTv0ILy82C2gn8MJsbcinzj2u8r/iZjD/78HRgw2/n//poOhQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    Reveal.initialize({
      plugins: [ 
        RevealHighlight,
        RevealNotes,
        RevealMath.KaTeX,
      ],
      mouseWheel: true,
      slideNumber: 'c/t',
    });
  </script>
  </body>
</html>
