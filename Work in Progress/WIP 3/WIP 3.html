<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>NimsDebuggingMethods.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>NimsDebuggingMethods.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ul>
<li>1. <a href="#debugging-your-programs">Debugging your programs</a>
<ul>
<li>1.1. <a href="#simple-debugging-methods(`echo`,-`assert`,-`doassert`)">Simple debugging methods(<code>echo</code>, <code>assert</code>, <code>doAssert</code>)</a></li>
<li>1.2. <a href="#`debugecho`-and-no-side-effects-programming"><code>debugEcho</code> and No Side Effects programming</a></li>
<li>1.3. <a href="#sugar-module's-`dump`-macro">Sugar module's <code>dump</code> macro</a></li>
<li>1.4. <a href="#sugar-module's-`dumptostring`-macro">Sugar module's <code>dumpToString</code> macro</a></li>
<li>1.5. <a href="#`asttostr-proc`"><code>astToStr proc</code></a></li>
</ul>
</li>
<li>2. <a href="#unit-testing">Unit testing</a>
<ul>
<li>2.1. <a href="#stack-tracing">Stack tracing</a></li>
</ul>
</li>
<li>3. <a href="#code-usage-profiling">Code Usage Profiling</a></li>
<li>4. <a href="#time-elapsed-profiling/benchmarking">Time Elapsed Profiling/Benchmarking</a></li>
<li>5. <a href="#debugging-modules-by-nim's-community-members">Debugging modules by Nim's community members</a></li>
</ul>
      <meta name = "viewport" content = "width = device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      </style>
      <body>

      <button onclick = "topFunction()" id = "toTop" title = "Go to top">Top</button>
      <button onclick = "topFunction()" id = "toTopMobile" title = "Go to top">Top</button>

      <script>
        // Get the button
        let myButton = document.getElementById("toTop");
        let myButtonMobile = document.getElementById("toTopMobile");
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName("body"); //gives a query object

        //myButton.style.color = "red"; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop > 20 || document.documentElement.scrollTop > 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if ("maxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints > 0;
          } 
        else if ("msMaxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints > 0;
          } 
        else 
          {
            var mQ = window.matchMedia && matchMedia("(pointer:coarse)");

            if (mQ && mQ.media === "(pointer:coarse)") 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              currentButton.style.display = "block";
            } else {currentButton.style.display = "none";}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      </script>
    
<h2>INTRO - GREETING</h2>
<ul>
<li><strong>Title</strong>: Nim's Debugging Methods</li>
<li><strong>Alt Title</strong>: Part 1 of 2(Part 1 is Nim's Debugging Methods); Part 2 is using external debuggers and profilers</li>
<li><strong>Prerequired knowledge:</strong> Up to and including: Nim for Beginners List Comprehensions with sugar.collect vs Python's List Comprehensions</li>
</ul>
<h2>INTRO - FOREWORDS</h2>
<p><strong>(What is the purpose of this video ?)</strong></p>
<ul>
<li>Nim's Debugging Methods:
<ul>
<li>In this video we will go over all the debugging methods Nim has specifically.
Actual debuggers and profilers are the subject of a part 2 video.</li>
</ul>
</li>
</ul>
<p>The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.</p>
<p><a name = "debugging-your-programs"></a></p>
<h1>1. Debugging your programs</h1>
<hr />
<p><a name = "simple-debugging-methods(`echo`,-`assert`,-`doassert`)"></a></p>
<h2>¬†¬†1.1. Simple debugging methods(<code>echo</code>, <code>assert</code>, <code>doAssert</code>)</h2>
<hr />
<p>We have been using <code>echo</code> for debugging our programs for a long while now.
But there is also <code>assert</code> and <code>doAssert</code></p>
<p><strong>Here is an example of <code>assert</code>:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>How this works is that, if the condition is true, nothing will happen, the program will simply continue.
But if the condition is false, then you will get an error like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span></code></pre>
<img src = "images\assertError.png">
<p><code>assert</code> only works in the default debug mode <code>-d:debug</code>(terminal, config.nims gets extra <code>-</code> --d:debug).
It gets ignored by the compiler.</p>
<p>Now there is also <code>doAssert</code>, which stays in the release version <code>-d:release</code> of your program.</p>
<p><a name = "`debugecho`-and-no-side-effects-programming"></a></p>
<h2>¬†¬†1.2. <code>debugEcho</code> and No Side Effects programming</h2>
<hr />
<p>There is another type of <code>echo</code> called <code>debugEcho</code> which pretends to be of no side effects,
in order for it to work with <code>procs</code> marked with {.noSideEffect.} pragma.</p>
<p><code>func</code> keyword that can be used in place of <code>proc</code>, simply means <code>proc myProc(arg: type) {.noSideEffect.} =</code>.
And {.noSideEffect.} pragma means that this proc will use the <code>functional</code> programming paradigm's,
no side effects term. Which means, that if a proc with no side effects pragma or a func,
is given parameters, and if those parameters are the same, it should always return the same output.
And it should NOT modify any outside state, e.g. writting to the <code>stdout</code>.</p>
<p>This is MOSTLY true in Nim, but Nim is NOT a functional programming language.
It only has some features of one as an addon to make it better.</p>
<p><strong>Here is an example:</strong>
Let's demonstrate this no side effects term, by making a proc that writes to the <code>stdout</code>,
by either using <code>echo</code> or <code>stdout.write</code>/<code>.writeln</code>, running it, and then changing the proc to a <code>func</code>,
and or adding the {.noSideEffect.} pragma:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout() =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">Hello</pre></code></pre>

<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">func</span> writeToStdout2() =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout2()</code></pre>
<img src = "images\sideEffects.png">
<img src = "images\sideEffectsError.png">
<p>Error, will not compile.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout3() {.noSideEffect.} =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout3()</code></pre>
<img src = "images\sideEffects2.png">
<img src = "images\sideEffectsError2.png">
<p>Error, will not compile.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout4() {.noSideEffect.} =
  debugEcho <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout4()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">Hello</pre></code></pre>

<p>Now the warning is silenced, and we can compile, <strong>BUT it will have side effects!</strong></p>
  <h6>(you may double check that yourself)</h6>
<p><a name = "sugar-module's-`dump`-macro"></a></p>
<h2>¬†¬†1.3. Sugar module's <code>dump</code> macro</h2>
<hr />
<p><code>dump</code> macro takes identifiers/variables and uses <code>echo</code> to,
print out the name and the value of the variables given in the following pattern <code>(a, b) = (aVal, bVal)</code>.
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/sugar

<span class="hljs-keyword">var</span> aVar = <span class="hljs-number">101</span>
<span class="hljs-keyword">let</span> aLet = <span class="hljs-number">202</span>
<span class="hljs-keyword">const</span> aConst = <span class="hljs-number">303</span>
dump (aVar, aLet, aConst) <span class="hljs-comment">#Requires parentheses</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">(aVar, aLet, aConst) = (101, 202, 303)</pre></code></pre>

<p>I don't recommend using it with multiple variables with complex values at the same time.
It will get confusing, because you will read the variable on the left,
then search trough a lot of data on the right, instead of simply having each variable on it's own line.</p>
<p>I recommend using it for a single variable at a time, and with that, the pattern is simply <code>varName = value</code>.
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim">aVar.dump</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">aVar = 101</pre></code></pre>

<p><a name = "sugar-module's-`dumptostring`-macro"></a></p>
<h2>¬†¬†1.4. Sugar module's <code>dumpToString</code> macro</h2>
<hr />
<p><code>dumpToString</code> macro functions differently to the <code>dump</code> macro.
It does not call <code>echo</code> to display variable names and their values.
Instead it returns a string, whilst also expanding templates and macros(similar to calling repr on them).
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">MyObject</span> = <span class="hljs-keyword">object</span>
    name: <span class="hljs-built_in">string</span>
    value: <span class="hljs-built_in">int</span>

<span class="hljs-keyword">var</span> myObject = <span class="hljs-type">MyObject</span>(name: <span class="hljs-string">&quot;Hello&quot;</span>, value: <span class="hljs-number">101</span>)
<span class="hljs-keyword">echo</span> myObject.dumpToString

<span class="hljs-keyword">var</span> someVar = <span class="hljs-number">101</span>
<span class="hljs-keyword">echo</span> someVar.dumpToString
<span class="hljs-keyword">echo</span> myObject.dumpToString, someVar.dumpToString</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">myObject: myObject = (name: &quot;Hello&quot;, value: 101)
someVar: someVar = 101
myObject: myObject = (name: &quot;Hello&quot;, value: 101)someVar: someVar = 101</pre></code></pre>

<p>A little bit of an odd output, the name of the variable is outputted twice...
I personally prefer the <code>dump</code> macro for singular variables,
but since this one doesn't call <code>echo</code> and expands templates and macros,
you can use it in more freeing and useful ways.</p>
<p><strong>Here is an example with calling <code>dumpToString</code> on a template calling a proc:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> sum(a, b: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
  a + b
  
<span class="hljs-keyword">template</span> varPassTrough(variable: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  sum(variable, variable)

<span class="hljs-keyword">echo</span> varPassTrough(someVar)
<span class="hljs-keyword">echo</span> varPassTrough(someVar).dumpToString</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">202
sum(someVar, someVar): sum(someVar, someVar) = 202</pre></code></pre>

<p>With <code>dumpToString</code> you will know what is going on within your templates etc,
by seeing the name of procs being used and with what arguments.</p>
<p><a name = "`asttostr-proc`"></a></p>
<h2>¬†¬†1.5. <code>astToStr proc</code></h2>
<hr />
<p><code>astToStr</code> proc takes the name of an identifier like <code>var</code> and <code>let</code>,
and returns the name of the identifier. This is very useful for debugging,
because, let's say that you had lots of variables you wanted to know their values of at all times.
Now you would first form 1x echo call, then copy paste it and then change the variables.
And if you also wanted to know what variable's value you are displaying,
you would have to manually write it as a string. But with <code>astToStr</code> you wouldn't have to.</p>
<p><strong>For that reason, here in an example of <code>astToStr</code> with a template for displaying the name of the variable,
the type, and it's value:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> dbgMsg(varName: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">echo</span> varName.astToStr, <span class="hljs-string">&quot; of type &quot;</span>, varName.typeof, <span class="hljs-string">&quot; of value &quot;</span>, varName

<span class="hljs-keyword">var</span> myVar: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
<span class="hljs-keyword">let</span> myLet: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
<span class="hljs-keyword">const</span> myConst: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
myVar.dbgMsg
myLet.dbgMsg
myConst.dbgMsg <span class="hljs-comment">#Doesn't work with constants, returns the value instead of the name</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">myVar of type float of value 0.99
myLet of type float of value 0.99
0.99 of type float of value 0.99</pre></code></pre>

<p><a name = "unit-testing"></a></p>
<h1>2. Unit testing</h1>
<hr />
<p>A more advanced way of debugging your programs is called <code>unit testing</code> by the usage of the <code>unittest</code> module.
Unit testing works somewhat like using <code>assert</code>, but it has more options like not quiting on a failed test.
Unit testing is not meant to stay in your programs in release versions, but to iron out the bugs before it gets to that.
To start a unit test, you need to call the <code>suite</code> template to start a block of unit testing code like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/unittest

suite <span class="hljs-string">&quot;My tests&quot;</span>:
  <span class="hljs-keyword">discard</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
</span></pre>
<p>Then we use the <code>test</code> template for our tests, which starts a block of code,
and then using the <code>require</code> template of type bool, we specify what value we want it to be, true or false,
and this condition needs to be true otherwise the test fails. This is meant for code that is crucial for your program,
that if it fails, there is no point in running anymore tests.</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  test <span class="hljs-string">&quot;Must be true&quot;</span>:
    require(<span class="hljs-literal">true</span>)</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Must be true</pre>
<p>Showing an image from VS Code to show that the tests are colorized(green for success, red for failure)</p>
<p>Now to test values there is the <code>check</code> template.
You can also use the <code>setup</code> section for a <code>suite</code>, to for example declare variables you want to use in testing,
these variables will be available to ALL the tests. You can also create variables inside tests,
but those will be local/available only to that test.</p>
<p><strong>Here is an example of <code>check</code> and <code>setup</code> templates:</strong></p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  setup:
    <span class="hljs-keyword">let</span> fruit = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>]
    <span class="hljs-keyword">var</span> kFruit: <span class="hljs-built_in">string</span>
  test <span class="hljs-string">&quot;Must be true&quot;</span>:
    require(<span class="hljs-literal">true</span>)
  test <span class="hljs-string">&quot;&quot;&quot;Fruit starting with the letter &quot;k&quot; &quot;&quot;&quot;</span>:
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fruit:
      <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;k&quot;</span>:
        kFruit = f
    check kFruit == <span class="hljs-string">&quot;kiwi&quot;</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Must be true
  <span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Fruit starting with the letter \"k\" </pre>
<p>There is also the <code>expect</code> template which tries to catch an exception(a type of error),
and if a specified exception is raised/caught, the test of <code>expect</code> will pass,
otherwise if the exception/error is NOT of the type specified, or if there isn't one at all, it will fail.</p>
<p><strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  test <span class="hljs-string">&quot;Index out of bounds&quot;</span>:
    <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">#Does NOT work with [0, 1, 2] array - no exceptions for IOOB arrays</span>
    expect(<span class="hljs-type">IndexDefect</span>):        <span class="hljs-comment"># IOOB - index out of bounds, because IOOB on arrays,</span>
      <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">3</span>]        <span class="hljs-comment"># can always be found at compilation</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Index out of bounds</pre>
<p>Here is an example of a failed <code>check</code> and a failed <code>expect</code>:</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Failed expect and check&quot;</span>:
  test <span class="hljs-string">&quot;Failed check&quot;</span>:
      check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)
  test <span class="hljs-string">&quot;Failed expect&quot;</span>: <span class="hljs-comment">#Because it expects IndexDefect(IOOB)</span>
    <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
    expect(<span class="hljs-type">IndexDefect</span>):
      <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">0</span>]</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Failed expect and check
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(556, 16): Check failed: 1 == 2
  </span><span style = "color: rgba(255, 0, 0, 1)">[FAILED]</span> Failed check
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(559, 13): Expect Failed, no exception was thrown.
  <span style = "color: rgba(255, 0, 0, 1)">[FAILED]</span> Failed expect</pre>
<p>There is also the <code>checkpoint</code> proc which will print out all of the checkpoints set,
if a <code>test</code> or <code>check</code> fails:</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
  checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
  check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>))
  checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>)</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Checkpoints
    Checkpoint Start
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(571, 32): Check failed: (101, \"Hello World!\") == (1, \"Hello\")
</span></pre>
<p><a name = "stack-tracing"></a></p>
<h2>¬†¬†2.1. Stack tracing</h2>
<hr />
<p>Stack tracing is getting a report of the current active frame being executed by the compiler.
The stack meaning, all the code we write that isn't a <code>string, sequence</code>,
and other data types that live on the heap, or ones we explicitly mark to be on the heap.
#TODO is this correct ???</p>
<p>The frame simply means a collection of code on the stack.
That stack inside the frame(with a frameMsg),
contains the name of the <code>proc</code> being executed, the line it's from,
and the filename(for when your program is split into multiple and using modules).</p>
<p>With all that said, getting a <code>stack traceback</code> can be very useful for debugging,
because you can get the information on where the code crashed,
when the compiler can't, and ESPECIALLY in release mode, which has a lot of the safety measures for debugging,
turned off for reasons of speed. But this has to be done manually by basically setting checkpoints.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">#Stack tracing</span>
<span class="hljs-keyword">proc</span> a1() =
  writeStackTrace()

<span class="hljs-keyword">proc</span> a() =
  a1()

a()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><a name = "code-usage-profiling"></a></p>
<h1>3. Code Usage Profiling</h1>
<hr />
<p>This method will measure in % the amount of processing was spent of the total on a given call.
To do this, we will have to <code>import std/nimprof</code> Nim's profiler,
and enable it and stack tracing with <strong>the following flags inside a <code>config.nims</code> file:</strong></p>
<pre><code class="nohighlight hljs nim">--profiler:on 
--stackTrace:on</code></pre>
<p>The following is a sample program that we are going to be using for code usage profiling:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/nimprof 
<span class="hljs-keyword">import</span> std/strutils 

<span class="hljs-keyword">proc</span> letters() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found letter&quot;</span>)

<span class="hljs-keyword">proc</span> numbers() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found number&quot;</span>)

<span class="hljs-keyword">proc</span> different() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found something else&quot;</span>)

<span class="hljs-keyword">proc</span> analyse(data: <span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> index &lt; data.len:
    <span class="hljs-keyword">case</span> data[index]
    <span class="hljs-keyword">of</span> <span class="hljs-type">Letters</span>: letters()
    <span class="hljs-keyword">of</span> {<span class="hljs-string">'0'</span> .. <span class="hljs-string">'9'</span>}: numbers()
    <span class="hljs-keyword">else</span>: different()
    index.inc

<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. <span class="hljs-number">1000</span>: 
  analyse(<span class="hljs-string">&quot;uyguhijkmnbreadv44354gasuygi456donkey456uiolkno,.,Ochyqudsayd12635uha&quot;</span>)</code></pre>
<p>The above code's results will be inside <code>profile_results.txt</code> file.
<strong>Here are the results after completion:</strong></p>
<img src = "images\codeUsageProfilingResults.png">
<p><a name = "time-elapsed-profiling/benchmarking"></a></p>
<h1>4. Time Elapsed Profiling/Benchmarking</h1>
<hr />
<p>I have already shown this in the <code>List Comprehensions with sugar.collect vs Python's List Comprehensions</code> tutorial.
But for completioning reasons, let's cover this here as well.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

<span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = cpuTime()

    <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
      code

    <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
    <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
    <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
  <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
    list.add j

benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
  <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

  <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
    list[index] = index

benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-keyword">var</span> list = collect:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      i</code></pre>
<pre>
CPU Time [add    ] x 10000 = 0.000142300000s
CPU Time [index  ] x 10000 = 0.000157300000s
CPU Time [collect] x 10000 = 0.000142400000s
</pre>
<p><a name = "debugging-modules-by-nim's-community-members"></a></p>
<h1>5. Debugging modules by Nim's community members</h1>
<hr />
<h1>Outro - Afterwords</h1>
<hr />
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of written tutorial.</p>
<h1>Thanks to my past and current Patrons</h1>
<hr />
<h2>Past Patrons</h2>
<hr />
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<h2>Current Patrons</h2>
<hr />
<ul>
<li>jaap groot (from October 2023)</li>
<li>Dimitri Lesnoff (from October 2023)</li>
</ul>
<h2>Compiler Information</h2>
<hr />
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option(mm:orc)</li>
</ul>
<h2>My and General Links</h2>
<hr />
<ul>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<h2>Links to this video's subject:</h2>
<hr />
<ul>
<li><a href="https://vladar4.github.io/sdl2_nim/" title="Example link to an example video's subject">E.G.1. SDL2_nim documentation</a></li>
<li><a href="https://wiki.libsdl.org/APIByCategory" title="Example link to an example video's subject">E.G.2. SDL2 documentation(in case SDL2_nim documentation missed something)</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>
<span class="hljs-comment">#nbShow is super useful!</span>
<span class="hljs-comment">#&lt;code&gt;&lt;/code&gt; makes text with a background</span>

<span class="hljs-comment">#https://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals raw strings r&quot;&quot;</span>

<span class="hljs-keyword">import</span> nimib, std/strutils, std/strformat <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment">#Overriding nimib's nbCode -&gt; with a version that has horizontal scroll for overflowing output</span>
<span class="hljs-keyword">import</span> nimib / [capture]

<span class="hljs-keyword">template</span> nbCode(body: <span class="hljs-built_in">untyped</span>) {.used.} =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCode&quot;</span>, body): <span class="hljs-comment">#Writes to stdout `lineNumb typeOfNBblock: a bit of first line</span>
    captureStdout(nb.blk.output):
      body

nb.partials[<span class="hljs-string">&quot;nbCode&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
{{&gt;nbCodeSource}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot; style = &quot;color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;&quot;&gt;{{&gt;nbCodeOutput}}&lt;/code&gt;&lt;/pre&gt;
&quot;&quot;&quot;</span> 
nb.renderPlans[<span class="hljs-string">&quot;nbCode&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>] <span class="hljs-comment"># default partial automatically escapes output (code is escaped when highlighting)</span>
                                              <span class="hljs-comment"># Required to show the code that then gets it's output shown aswell, if empty, empty &lt;code&gt;&lt;/code&gt; line</span>

<span class="hljs-keyword">template</span> colorizeLines(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">var</span> bodyColorized = body.repr

  <span class="hljs-keyword">var</span> timesToColorize: <span class="hljs-built_in">int</span>
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[Suite]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[Suite]&quot;</span>)
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>)
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>)

  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">var</span> suiteFinalStage = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">var</span> currentIndex: <span class="hljs-built_in">int</span>

  <span class="hljs-keyword">while</span> index &lt; <span class="hljs-number">1</span>:
    <span class="hljs-comment"># [Suite]   </span>
    <span class="hljs-keyword">if</span> suiteFinalStage == <span class="hljs-literal">false</span>:
      bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(0, 132, 255, 1)&quot;&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[Suite]&quot;</span>))
      bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&lt;span style = &quot;color:white&quot;;&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[Suite]&quot;</span>) + <span class="hljs-string">&quot;[Suite]&quot;</span>.len)
      suiteFinalStage = <span class="hljs-literal">true</span>

      <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>) &gt; <span class="hljs-number">0</span>:
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[OK]&quot;</span>))
        currentIndex = bodyColorized.find(<span class="hljs-string">&quot;[OK]&quot;</span>) + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>.len-<span class="hljs-number">1</span> <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
      <span class="hljs-keyword">elif</span> bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>) &gt; <span class="hljs-number">0</span>:
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[FAILED]&quot;</span>))
        currentIndex = bodyColorized.find(<span class="hljs-string">&quot;[FAILED]&quot;</span>) + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>.len-<span class="hljs-number">1</span> <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
      <span class="hljs-keyword">else</span>: <span class="hljs-comment">#If it only has [Suite] end it, no need to increase the index</span>
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.len-<span class="hljs-number">1</span>) <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
    <span class="hljs-comment">#-[OK] and [FAILED]</span>
    bodyColorized = bodyColorized.replaceWord(<span class="hljs-string">&quot;[OK]&quot;</span>, <span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(0, 255, 0, 1)&quot;&gt;[OK]&lt;/span&gt;&quot;&quot;&quot;</span>)
    bodyColorized = bodyColorized.replaceWord(<span class="hljs-string">&quot;[FAILED]&quot;</span>, <span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(255, 0, 0, 1)&quot;&gt;[FAILED]&lt;/span&gt;&quot;&quot;&quot;</span>)
    
    <span class="hljs-comment">#Temporary improvement</span>
    <span class="hljs-keyword">if</span> bodyColorized.startsWith(<span class="hljs-string">&quot;&quot;&quot;&quot;\n&quot;&quot;&quot;</span>):
      bodyColorized.delete(<span class="hljs-number">0.</span>.<span class="hljs-number">2</span>)
    <span class="hljs-keyword">if</span> bodyColorized.endsWith(<span class="hljs-string">&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>):
      bodyColorized.delete(bodyColorized.len-<span class="hljs-number">1.</span>.bodyColorized.len-<span class="hljs-number">1</span>)

    <span class="hljs-comment">#Removing raw \n, which are the ones shown</span>
    bodyColorized = bodyColorized.replace(<span class="hljs-string">r&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)

    <span class="hljs-comment">#Not sure why, but it errors without it</span>
    bodyColorized.stripLineEnd 
    
  bodyColorized

<span class="hljs-keyword">var</span> output: <span class="hljs-built_in">string</span>
<span class="hljs-keyword">template</span> nbColorizeOutputUT() =
  output = nb.blk.output
  output = output.colorizeLines

  <span class="hljs-comment">#Clearing old output</span>
  nb.blk.output = <span class="hljs-string">&quot;&quot;</span>
  nb.blk.context[<span class="hljs-string">&quot;output&quot;</span>] = <span class="hljs-string">&quot;&quot;</span>

  nbRawHtml: &amp;<span class="hljs-string">&quot;&quot;&quot;&lt;pre class = &quot;&quot; style = &quot;overflow-x: auto;&quot;&gt;{output}&lt;/pre&gt;&quot;&quot;&quot;</span> <span class="hljs-comment">#class = &quot;&quot; so we don't get green font</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">var</span> index = (section: <span class="hljs-number">0</span>, subsection: <span class="hljs-number">0</span>)

<span class="hljs-keyword">template</span> nbSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  index.section.inc
  index.subsection = <span class="hljs-number">0</span> <span class="hljs-comment">#Reset on a new nbSection</span>

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;. &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;- &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> <span class="hljs-comment">#&amp;#92; is HTML code for &quot;\&quot;, you can also &quot;\\&quot; or r&quot;\&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbSubSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbUoSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbUoSubSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbCodeSnippet(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>, body):
    nb.blk.output = body

nb.partials[<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;&lt;pre&gt;&lt;code class=&quot;hlNim&quot;&gt;{{&amp;output}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>
nb.renderPlans[<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>]

<span class="hljs-comment">#Updating the same file is shown instantly once deployed via Github Page on PC. </span>
  <span class="hljs-comment">#Mobile takes either a random amount of time, or NOT at all!</span>
<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">hlHtml&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTop&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;
      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTopMobile&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
        // Get the button
        let myButton = document.getElementById(&quot;toTop&quot;);
        let myButtonMobile = document.getElementById(&quot;toTopMobile&quot;);
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName(&quot;body&quot;); //gives a query object

        //myButton.style.color = &quot;red&quot;; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if (&quot;maxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints &gt; 0;
          } 
        else if (&quot;msMaxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints &gt; 0;
          } 
        else 
          {
            var mQ = window.matchMedia &amp;&amp; matchMedia(&quot;(pointer:coarse)&quot;);

            if (mQ &amp;&amp; mQ.media === &quot;(pointer:coarse)&quot;) 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
              currentButton.style.display = &quot;block&quot;;
            } else {currentButton.style.display = &quot;none&quot;;}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Use Live Preview Extension and set the Auto Refresh Preview set to &quot;On changes to Saved Files&quot;</span>
  <span class="hljs-comment">#And Server Keep Alive After Embedded Preview Close set to 0, </span>
  <span class="hljs-comment">#so that we no longer need the preview embedded window, we now have it in the browser!</span>
    <span class="hljs-comment">#Live SERVER Extension no longer works, even with the .html file kept open</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd enables nimiboost's markdown highlight mode. hlMdf adds the fmt&quot;{var}&quot; functionality</span>
nbText: <span class="hljs-string">hlmdf&quot;&quot;&quot;
## INTRO - GREETING
- **Title**: Nim's Debugging Methods
- **Alt Title**: Part 1 of 2(Part 1 is Nim's Debugging Methods); Part 2 is using external debuggers and profilers
- **Prerequired knowledge:** Up to and including: Nim for Beginners List Comprehensions with sugar.collect vs Python's List Comprehensions 

## INTRO - FOREWORDS
**(What is the purpose of this video ?)**
- Nim's Debugging Methods:
  - In this video we will go over all the debugging methods Nim has specifically.
  Actual debuggers and profilers are the subject of a part 2 video.
   
The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Debugging your programs&quot;</span>
nbSubSection <span class="hljs-string">&quot;Simple debugging methods(`echo`, `assert`, `doAssert`)&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  We have been using `echo` for debugging our programs for a long while now.
  But there is also `assert` and `doAssert`

  **Here is an example of `assert`:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  How this works is that, if the condition is true, nothing will happen, the program will simply continue.
  But if the condition is false, then you will get an error like this:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span>

nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\assertError.png&quot;&gt;&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  `assert` only works in the default debug mode `-d:debug`(terminal, config.nims gets extra `-` --d:debug).
  It gets ignored by the compiler.

  Now there is also `doAssert`, which stays in the release version `-d:release` of your program.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`debugEcho` and No Side Effects programming&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  There is another type of `echo` called `debugEcho` which pretends to be of no side effects,
  in order for it to work with `procs` marked with {.noSideEffect.} pragma.

  `func` keyword that can be used in place of `proc`, simply means `proc myProc(arg: type) {.noSideEffect.} =`.
  And {.noSideEffect.} pragma means that this proc will use the `functional` programming paradigm's,
  no side effects term. Which means, that if a proc with no side effects pragma or a func,
  is given parameters, and if those parameters are the same, it should always return the same output.
  And it should NOT modify any outside state, e.g. writting to the `stdout`.

  This is MOSTLY true in Nim, but Nim is NOT a functional programming language.
  It only has some features of one as an addon to make it better.

  **Here is an example:**
  Let's demonstrate this no side effects term, by making a proc that writes to the `stdout`,
  by either using `echo` or `stdout.write`/`.writeln`, running it, and then changing the proc to a `func`,
  and or adding the {.noSideEffect.} pragma:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> writeToStdout() =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout()

nbCodeSkip:
  <span class="hljs-keyword">func</span> writeToStdout2() =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout2()
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffects.png&quot;&gt;&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffectsError.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Error, will not compile.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> writeToStdout3() {.noSideEffect.} =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout3()
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffects2.png&quot;&gt;&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffectsError2.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Error, will not compile.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> writeToStdout4() {.noSideEffect.} =
    debugEcho <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout4()
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now the warning is silenced, and we can compile, **BUT it will have side effects!**
  &lt;h6&gt;(you may double check that yourself)&lt;/h6&gt;
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Sugar module's `dump` macro&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `dump` macro takes identifiers/variables and uses `echo` to, 
  print out the name and the value of the variables given in the following pattern `(a, b) = (aVal, bVal)`.
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/sugar

  <span class="hljs-keyword">var</span> aVar = <span class="hljs-number">101</span>
  <span class="hljs-keyword">let</span> aLet = <span class="hljs-number">202</span>
  <span class="hljs-keyword">const</span> aConst = <span class="hljs-number">303</span>
  dump (aVar, aLet, aConst) <span class="hljs-comment">#Requires parentheses</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  I don't recommend using it with multiple variables with complex values at the same time.
  It will get confusing, because you will read the variable on the left, 
  then search trough a lot of data on the right, instead of simply having each variable on it's own line.

  I recommend using it for a single variable at a time, and with that, the pattern is simply `varName = value`.
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  aVar.dump

nbSubSection <span class="hljs-string">&quot;Sugar module's `dumpToString` macro&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `dumpToString` macro functions differently to the `dump` macro.
  It does not call `echo` to display variable names and their values.
  Instead it returns a string, whilst also expanding templates and macros(similar to calling repr on them).
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">MyObject</span> = <span class="hljs-keyword">object</span>
      name: <span class="hljs-built_in">string</span>
      value: <span class="hljs-built_in">int</span>

  <span class="hljs-keyword">var</span> myObject = <span class="hljs-type">MyObject</span>(name: <span class="hljs-string">&quot;Hello&quot;</span>, value: <span class="hljs-number">101</span>)
  <span class="hljs-keyword">echo</span> myObject.dumpToString

  <span class="hljs-keyword">var</span> someVar = <span class="hljs-number">101</span>
  <span class="hljs-keyword">echo</span> someVar.dumpToString
  <span class="hljs-keyword">echo</span> myObject.dumpToString, someVar.dumpToString

nbText: <span class="hljs-string">&quot;&quot;&quot;
  A little bit of an odd output, the name of the variable is outputted twice...
  I personally prefer the `dump` macro for singular variables, 
  but since this one doesn't call `echo` and expands templates and macros,
  you can use it in more freeing and useful ways.

  **Here is an example with calling `dumpToString` on a template calling a proc:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> sum(a, b: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
    a + b
    
  <span class="hljs-keyword">template</span> varPassTrough(variable: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    sum(variable, variable)

  <span class="hljs-keyword">echo</span> varPassTrough(someVar)
  <span class="hljs-keyword">echo</span> varPassTrough(someVar).dumpToString

nbText: <span class="hljs-string">&quot;&quot;&quot;
  With `dumpToString` you will know what is going on within your templates etc,
  by seeing the name of procs being used and with what arguments.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`astToStr proc`&quot;</span> 
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `astToStr` proc takes the name of an identifier like `var` and `let`,
  and returns the name of the identifier. This is very useful for debugging,
  because, let's say that you had lots of variables you wanted to know their values of at all times.
  Now you would first form 1x echo call, then copy paste it and then change the variables.
  And if you also wanted to know what variable's value you are displaying,
  you would have to manually write it as a string. But with `astToStr` you wouldn't have to.

  **For that reason, here in an example of `astToStr` with a template for displaying the name of the variable,
  the type, and it's value:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">template</span> dbgMsg(varName: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">echo</span> varName.astToStr, <span class="hljs-string">&quot; of type &quot;</span>, varName.typeof, <span class="hljs-string">&quot; of value &quot;</span>, varName
  
  <span class="hljs-keyword">var</span> myVar: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  <span class="hljs-keyword">let</span> myLet: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  <span class="hljs-keyword">const</span> myConst: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  myVar.dbgMsg
  myLet.dbgMsg
  myConst.dbgMsg <span class="hljs-comment">#Doesn't work with constants, returns the value instead of the name</span>

nbSection <span class="hljs-string">&quot;Unit testing&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  A more advanced way of debugging your programs is called `unit testing` by the usage of the `unittest` module.
  Unit testing works somewhat like using `assert`, but it has more options like not quiting on a failed test.
  Unit testing is not meant to stay in your programs in release versions, but to iron out the bugs before it gets to that.
  To start a unit test, you need to call the `suite` template to start a block of unit testing code like this:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/unittest

  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    <span class="hljs-keyword">discard</span>
nbColorizeOutputUT <span class="hljs-comment">#TODO - our template makes an extra line... if we delete the first 2 indexes, we delete &lt;s ...</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Then we use the `test` template for our tests, which starts a block of code,
  and then using the `require` template of type bool, we specify what value we want it to be, true or false,
  and this condition needs to be true otherwise the test fails. This is meant for code that is crucial for your program,
  that if it fails, there is no point in running anymore tests.
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    test <span class="hljs-string">&quot;Must be true&quot;</span>:
      require(<span class="hljs-literal">true</span>)
nbColorizeOutputUT

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Showing an image from VS Code to show that the tests are colorized(green for success, red for failure)

  Now to test values there is the `check` template.
  You can also use the `setup` section for a `suite`, to for example declare variables you want to use in testing,
  these variables will be available to ALL the tests. You can also create variables inside tests,
  but those will be local/available only to that test.

  **Here is an example of `check` and `setup` templates:**
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    setup:
      <span class="hljs-keyword">let</span> fruit = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>]
      <span class="hljs-keyword">var</span> kFruit: <span class="hljs-built_in">string</span>
    test <span class="hljs-string">&quot;Must be true&quot;</span>:
      require(<span class="hljs-literal">true</span>)
    test <span class="hljs-string">&quot;&quot;&quot;Fruit starting with the letter &quot;k&quot; &quot;&quot;&quot;</span>:
      <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fruit:
        <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;k&quot;</span>:
          kFruit = f
      check kFruit == <span class="hljs-string">&quot;kiwi&quot;</span>
nbColorizeOutputUT

nbText: <span class="hljs-string">&quot;&quot;&quot;
  There is also the `expect` template which tries to catch an exception(a type of error),
  and if a specified exception is raised/caught, the test of `expect` will pass, 
  otherwise if the exception/error is NOT of the type specified, or if there isn't one at all, it will fail.
  
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    test <span class="hljs-string">&quot;Index out of bounds&quot;</span>:
      <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">#Does NOT work with [0, 1, 2] array - no exceptions for IOOB arrays</span>
      expect(<span class="hljs-type">IndexDefect</span>):        <span class="hljs-comment"># IOOB - index out of bounds, because IOOB on arrays,</span>
        <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">3</span>]        <span class="hljs-comment"># can always be found at compilation</span>
nbColorizeOutputUT

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here is an example of a failed `check` and a failed `expect`:
&quot;&quot;&quot;</span>
nbCode: 
  suite <span class="hljs-string">&quot;Failed expect and check&quot;</span>:
    test <span class="hljs-string">&quot;Failed check&quot;</span>:
        check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)
    test <span class="hljs-string">&quot;Failed expect&quot;</span>: <span class="hljs-comment">#Because it expects IndexDefect(IOOB)</span>
      <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
      expect(<span class="hljs-type">IndexDefect</span>):
        <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">0</span>]
        
nbColorizeOutputUT <span class="hljs-comment">#TODO weirdly almost all of it is green colorized without using the nbColorizeOutputUT</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  There is also the `checkpoint` proc which will print out all of the checkpoints set,
  if a `test` or `check` fails:
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
    checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
    check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>))
    checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>)
nbColorizeOutputUT

<span class="hljs-comment">#TODO some more unittest examples, more unique ones please</span>

nbSubSection <span class="hljs-string">&quot;Stack tracing&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Stack tracing is getting a report of the current active frame being executed by the compiler.
  The stack meaning, all the code we write that isn't a `string, sequence`,
  and other data types that live on the heap, or ones we explicitly mark to be on the heap.
  #TODO is this correct ???

  The frame simply means a collection of code on the stack.
  That stack inside the frame(with a frameMsg),
  contains the name of the `proc` being executed, the line it's from,
  and the filename(for when your program is split into multiple and using modules).

  With all that said, getting a `stack traceback` can be very useful for debugging,
  because you can get the information on where the code crashed,
  when the compiler can't, and ESPECIALLY in release mode, which has a lot of the safety measures for debugging,
  turned off for reasons of speed. But this has to be done manually by basically setting checkpoints.
&quot;&quot;&quot;</span>
<span class="hljs-comment">#TODO no messages in nimib...</span>
nbCode:
  <span class="hljs-comment">#Stack tracing</span>
  <span class="hljs-keyword">proc</span> a1() =
    writeStackTrace()

  <span class="hljs-keyword">proc</span> a() =
    a1()

  a()

nbSection <span class="hljs-string">&quot;Code Usage Profiling&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  This method will measure in % the amount of processing was spent of the total on a given call.
  To do this, we will have to `import std/nimprof` Nim's profiler,
  and enable it and stack tracing with **the following flags inside a `config.nims` file:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  --profiler:on 
  --stackTrace:on

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The following is a sample program that we are going to be using for code usage profiling:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/nimprof 
  <span class="hljs-keyword">import</span> std/strutils 

  <span class="hljs-keyword">proc</span> letters() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found letter&quot;</span>)

  <span class="hljs-keyword">proc</span> numbers() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found number&quot;</span>)

  <span class="hljs-keyword">proc</span> different() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found something else&quot;</span>)

  <span class="hljs-keyword">proc</span> analyse(data: <span class="hljs-built_in">string</span>) =
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> index &lt; data.len:
      <span class="hljs-keyword">case</span> data[index]
      <span class="hljs-keyword">of</span> <span class="hljs-type">Letters</span>: letters()
      <span class="hljs-keyword">of</span> {<span class="hljs-string">'0'</span> .. <span class="hljs-string">'9'</span>}: numbers()
      <span class="hljs-keyword">else</span>: different()
      index.inc

  <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. <span class="hljs-number">1000</span>: 
    analyse(<span class="hljs-string">&quot;uyguhijkmnbreadv44354gasuygi456donkey456uiolkno,.,Ochyqudsayd12635uha&quot;</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The above code's results will be inside `profile_results.txt` file.
  **Here are the results after completion:**
&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\codeUsageProfilingResults.png&quot;&gt;&quot;&quot;&quot;</span>
<span class="hljs-comment">#TODO explain this</span>

nbSection <span class="hljs-string">&quot;Time Elapsed Profiling/Benchmarking&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  I have already shown this in the `List Comprehensions with sugar.collect vs Python's List Comprehensions` tutorial.
  But for completioning reasons, let's cover this here as well.
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

  <span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = cpuTime()

      <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
        code

      <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
      <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
      <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

  benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
    <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      list.add j

  benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
    <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

    <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
      list[index] = index

  benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-keyword">var</span> list = collect:
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
        i
<span class="hljs-comment">#This takes a bit, so for reasons of speed when working on this tutorial, this is the first run captured</span>
nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;
&lt;pre&gt;
CPU Time [add    ] x 10000 = 0.000142300000s
CPU Time [index  ] x 10000 = 0.000157300000s
CPU Time [collect] x 10000 = 0.000142400000s
&lt;/pre&gt;
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Debugging modules by Nim's community members&quot;</span>

nbUoSection <span class="hljs-string">&quot;Outro - Afterwords&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of written tutorial.
&quot;&quot;&quot;</span>
nbUoSection <span class="hljs-string">&quot;Thanks to my past and current Patrons&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Past Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Current Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- jaap groot (from October 2023)
- Dimitri Lesnoff (from October 2023)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Compiler Information&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option(mm:orc)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;My and General Links&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Links to this video's subject:&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [E.G.1. SDL2_nim documentation](https://vladar4.github.io/sdl2_nim/ &quot;Example link to an example video's subject&quot;)
- [E.G.2. SDL2 documentation(in case SDL2_nim documentation missed something)](https://wiki.libsdl.org/APIByCategory &quot;Example link to an example video's subject&quot;)
&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>