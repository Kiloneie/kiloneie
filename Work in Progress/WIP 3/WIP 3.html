<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>NimsDebuggingMethods.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>NimsDebuggingMethods.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ul>
<li>1. <a href="#debugging-your-programs">Debugging your programs</a>
<ul>
<li>1.1. <a href="#simple-debugging-methods(`echo`,-`assert`,-`doassert`)">Simple debugging methods(<code>echo</code>, <code>assert</code>, <code>doAssert</code>)</a></li>
<li>1.2. <a href="#`debugecho`-and-no-side-effects-programming"><code>debugEcho</code> and No Side Effects programming</a></li>
<li>1.3. <a href="#sugar-module's-`dump`-macro">Sugar module's <code>dump</code> macro</a></li>
<li>1.4. <a href="#sugar-module's-`dumptostring`-macro">Sugar module's <code>dumpToString</code> macro</a></li>
<li>1.5. <a href="#`asttostr-proc`"><code>astToStr proc</code></a></li>
</ul>
</li>
<li>2. <a href="#unit-testing">Unit testing</a>
<ul>
<li>2.1. <a href="#`suite`-template"><code>suite</code> template</a></li>
<li>2.2. <a href="#`test`-template"><code>test</code> template</a></li>
<li>2.3. <a href="#`require`-template"><code>require</code> template</a></li>
<li>2.4. <a href="#`check`-and-`setup`-templates"><code>check</code> and <code>setup</code> templates</a></li>
<li>2.5. <a href="#`expect`-template"><code>expect</code> template</a></li>
<li>2.6. <a href="#`checkpoint`-proc"><code>checkpoint</code> proc</a></li>
<li>2.7. <a href="#`teardown`-proc"><code>teardown</code> proc</a></li>
</ul>
</li>
<li>3. <a href="#testament-automatic-unit-tester">Testament automatic unit tester</a></li>
<li>4. <a href="#stack-tracing">Stack tracing</a></li>
<li>5. <a href="#code-usage-profiling">Code Usage Profiling</a></li>
<li>6. <a href="#using-nimprof-as-a-memory-profiler">Using nimprof as a memory profiler</a></li>
<li>7. <a href="#time-elapsed-profiling/benchmarking">Time Elapsed Profiling/Benchmarking</a></li>
</ul>
      <meta name = "viewport" content = "width = device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      </style>
      <body>

      <button onclick = "topFunction()" id = "toTop" title = "Go to top">Top</button>
      <button onclick = "topFunction()" id = "toTopMobile" title = "Go to top">Top</button>

      <script>
        // Get the button
        let myButton = document.getElementById("toTop");
        let myButtonMobile = document.getElementById("toTopMobile");
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName("body"); //gives a query object

        //myButton.style.color = "red"; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop > 20 || document.documentElement.scrollTop > 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if ("maxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints > 0;
          } 
        else if ("msMaxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints > 0;
          } 
        else 
          {
            var mQ = window.matchMedia && matchMedia("(pointer:coarse)");

            if (mQ && mQ.media === "(pointer:coarse)") 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              currentButton.style.display = "block";
            } else {currentButton.style.display = "none";}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      </script>
    
<h2>INTRO - GREETING</h2>
<ul>
<li><strong>Title</strong>: Nim's Debugging Methods</li>
<li><strong>Alt Title</strong>: Part 1 of 2(Part 1 is Nim's Debugging Methods); Part 2 is using external debuggers and profilers</li>
<li><strong>Prerequired knowledge:</strong> Up to and including: Nim for Beginners List Comprehensions with sugar.collect vs Python's List Comprehensions</li>
</ul>
<h2>INTRO - FOREWORDS</h2>
<p><strong>(What is the purpose of this video ?)</strong></p>
<ul>
<li>Nim's Debugging Methods:
<ul>
<li>In this video we will go over all the debugging methods Nim has specifically.
Actual debuggers and profilers are the subject of a part 2 video.</li>
</ul>
</li>
</ul>
<p>The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.</p>
<p><a name = "debugging-your-programs"></a></p>
<h1>1. Debugging your programs</h1>
<hr />
<p><a name = "simple-debugging-methods(`echo`,-`assert`,-`doassert`)"></a></p>
<h2>¬†¬†1.1. Simple debugging methods(<code>echo</code>, <code>assert</code>, <code>doAssert</code>)</h2>
<hr />
<p>We have been using <code>echo</code> for debugging our programs for a long while now.
But there is also <code>assert</code> and <code>doAssert</code></p>
<p><strong>Here is an example of <code>assert</code>:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>How this works is that, if the condition is true, nothing will happen, the program will simply continue.
But if the condition is false, then you will get an error like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span></code></pre>
<img src = "images\assertError.png">
<p><code>assert</code> only works in the default debug mode <code>-d:debug</code>(terminal, config.nims gets extra <code>-</code> --d:debug).
It gets ignored by the compiler.</p>
<p>Now there is also <code>doAssert</code>, which stays in the release version <code>-d:release</code> of your program.</p>
<p><a name = "`debugecho`-and-no-side-effects-programming"></a></p>
<h2>¬†¬†1.2. <code>debugEcho</code> and No Side Effects programming</h2>
<hr />
<p>There is another type of <code>echo</code> called <code>debugEcho</code> which pretends to be of no side effects,
in order for it to work with <code>procs</code> marked with {.noSideEffect.} pragma.</p>
<p><code>func</code> keyword that can be used in place of <code>proc</code>, simply means <code>proc myProc(arg: type) {.noSideEffect.} =</code>.
And {.noSideEffect.} pragma means that this proc will use the <code>functional</code> programming paradigm's,
no side effects term. Which means, that if a proc with no side effects pragma or a func,
is given parameters, and if those parameters are the same, it should always return the same output.
And it should NOT modify any outside state, e.g. writting to the <code>stdout</code>.</p>
<p>This is MOSTLY true in Nim, but Nim is NOT a functional programming language.
It only has some features of one as an addon to make it better.</p>
<p><strong>Here is an example:</strong>
Let's demonstrate this no side effects term, by making a proc that writes to the <code>stdout</code>,
by either using <code>echo</code> or <code>stdout.write</code>/<code>.writeln</code>, running it, and then changing the proc to a <code>func</code>,
and or adding the {.noSideEffect.} pragma:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout() =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">Hello</pre></code></pre>

<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">func</span> writeToStdout2() =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout2()</code></pre>
<img src = "images\sideEffects.png">
<img src = "images\sideEffectsError.png">
<p>Error, will not compile.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout3() {.noSideEffect.} =
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout3()</code></pre>
<img src = "images\sideEffects2.png">
<img src = "images\sideEffectsError2.png">
<p>Error, will not compile.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> writeToStdout4() {.noSideEffect.} =
  debugEcho <span class="hljs-string">&quot;Hello&quot;</span>

writeToStdout4()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">Hello</pre></code></pre>

<p>Now the warning is silenced, and we can compile, <strong>BUT it will have side effects!</strong></p>
  <h6>(you may double check that yourself)</h6>
<p><a name = "sugar-module's-`dump`-macro"></a></p>
<h2>¬†¬†1.3. Sugar module's <code>dump</code> macro</h2>
<hr />
<p><code>dump</code> macro takes identifiers/variables and uses <code>echo</code> to,
print out the name and the value of the variables given in the following pattern <code>(a, b) = (aVal, bVal)</code>.
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/sugar

<span class="hljs-keyword">var</span> aVar = <span class="hljs-number">101</span>
<span class="hljs-keyword">let</span> aLet = <span class="hljs-number">202</span>
<span class="hljs-keyword">const</span> aConst = <span class="hljs-number">303</span>
dump (aVar, aLet, aConst) <span class="hljs-comment">#Requires parentheses</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">(aVar, aLet, aConst) = (101, 202, 303)</pre></code></pre>

<p>I don't recommend using it with multiple variables with complex values at the same time.
It will get confusing, because you will read the variable on the left,
then search trough a lot of data on the right, instead of simply having each variable on it's own line.</p>
<p>I recommend using it for a single variable at a time, and with that, the pattern is simply <code>varName = value</code>.
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim">aVar.dump</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">aVar = 101</pre></code></pre>

<p><a name = "sugar-module's-`dumptostring`-macro"></a></p>
<h2>¬†¬†1.4. Sugar module's <code>dumpToString</code> macro</h2>
<hr />
<p><code>dumpToString</code> macro functions differently to the <code>dump</code> macro.
It does not call <code>echo</code> to display variable names and their values.
Instead it returns a string, whilst also expanding templates and macros(similar to calling repr on them).
<strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">MyObject</span> = <span class="hljs-keyword">object</span>
    name: <span class="hljs-built_in">string</span>
    value: <span class="hljs-built_in">int</span>

<span class="hljs-keyword">var</span> myObject = <span class="hljs-type">MyObject</span>(name: <span class="hljs-string">&quot;Hello&quot;</span>, value: <span class="hljs-number">101</span>)
<span class="hljs-keyword">echo</span> myObject.dumpToString

<span class="hljs-keyword">var</span> someVar = <span class="hljs-number">101</span>
<span class="hljs-keyword">echo</span> someVar.dumpToString
<span class="hljs-keyword">echo</span> myObject.dumpToString, someVar.dumpToString</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">myObject: myObject = (name: &quot;Hello&quot;, value: 101)
someVar: someVar = 101
myObject: myObject = (name: &quot;Hello&quot;, value: 101)someVar: someVar = 101</pre></code></pre>

<p>A little bit of an odd output, the name of the variable is outputted twice...
I personally prefer the <code>dump</code> macro for singular variables,
but since this one doesn't call <code>echo</code> and expands templates and macros,
you can use it in more freeing and useful ways.</p>
<p><strong>Here is an example with calling <code>dumpToString</code> on a template calling a proc:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> sum(a, b: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
  a + b
  
<span class="hljs-keyword">template</span> varPassTrough(variable: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  sum(variable, variable)

<span class="hljs-keyword">echo</span> varPassTrough(someVar)
<span class="hljs-keyword">echo</span> varPassTrough(someVar).dumpToString</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">202
sum(someVar, someVar): sum(someVar, someVar) = 202</pre></code></pre>

<p>With <code>dumpToString</code> you will know what is going on within your templates etc,
by seeing the name of procs being used and with what arguments.</p>
<p><a name = "`asttostr-proc`"></a></p>
<h2>¬†¬†1.5. <code>astToStr proc</code></h2>
<hr />
<p><code>astToStr</code> proc takes the name of an identifier like <code>var</code> and <code>let</code>,
and returns the name of the identifier. This is very useful for debugging,
because, let's say that you had lots of variables you wanted to know their values of at all times.
Now you would first form 1x echo call, then copy paste it and then change the variables.
And if you also wanted to know what variable's value you are displaying,
you would have to manually write it as a string. But with <code>astToStr</code> you wouldn't have to.</p>
<p><strong>For that reason, here in an example of <code>astToStr</code> with a template for displaying the name of the variable,
the type, and it's value:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> dbgMsg(varName: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">echo</span> varName.astToStr, <span class="hljs-string">&quot; of type &quot;</span>, varName.typeof, <span class="hljs-string">&quot; of value &quot;</span>, varName

<span class="hljs-keyword">var</span> myVar: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
<span class="hljs-keyword">let</span> myLet: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
<span class="hljs-keyword">const</span> myConst: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
myVar.dbgMsg
myLet.dbgMsg
myConst.dbgMsg <span class="hljs-comment">#Doesn't work with constants, returns the value instead of the name</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">myVar of type float of value 0.99
myLet of type float of value 0.99
0.99 of type float of value 0.99</pre></code></pre>

<p><a name = "unit-testing"></a></p>
<h1>2. Unit testing</h1>
<hr />
<p>A more advanced way of debugging your programs is called <code>unit testing</code> by the usage of the <code>unittest</code> module.
Unit testing is the method that the vast majority of other programming languages use,
and so Nim also has it.</p>
<p>Unit testing works somewhat like using <code>assert</code>, but it has more options like not quiting on a failed test,
and displaying what exactly failed.
Unit testing is not meant to stay in your programs in release versions, but to iron out the bugs before it gets to that.</p>
<p><a name = "`suite`-template"></a></p>
<h2>¬†¬†2.1. <code>suite</code> template</h2>
<hr />
<p>To start a unit test, you need to call the <code>suite</code> template to start a block of unit testing code like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/unittest

suite <span class="hljs-string">&quot;My tests&quot;</span>:
  <span class="hljs-keyword">discard</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
</span></pre>
<p>As you can see, you have to name your <code>suite</code>, which serves as basically a collection of tests you will perform.</p>
<p><a name = "`test`-template"></a></p>
<h2>¬†¬†2.2. <code>test</code> template</h2>
<hr />
<p>To begin unittesting our code, we need to use the <code>test</code> template for our tests which we also have to name.
The <code>test</code> template then starts a test of the following block of code. And will return [OK], or [FAILED],
depending on the checked code inside of it.</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  test <span class="hljs-string">&quot;Must be true&quot;</span>:
    <span class="hljs-keyword">discard</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Must be true</pre>
<p><a name = "`require`-template"></a></p>
<h2>¬†¬†2.3. <code>require</code> template</h2>
<hr />
<p>One can use the <code>require</code> template of type bool, to which we have to specify what value we want it to be, true or false.
Then this condition needs to be of that bool value otherwise the test fails.
This is meant for code that is crucial for your program, that if it fails, there is no point in running anymore tests.</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  test <span class="hljs-string">&quot;Must be true&quot;</span>:
    require(<span class="hljs-literal">true</span>)</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Must be true</pre>
<p><a name = "`check`-and-`setup`-templates"></a></p>
<h2>¬†¬†2.4. <code>check</code> and <code>setup</code> templates</h2>
<hr />
<p>Now to check values to be of the desired value you want for the functionality of your program,
there is the <code>check</code> template.</p>
<p>You can also use the <code>setup</code> section for a <code>suite</code>, to for example declare variables you want to use in testing,
those variables will be available to ALL of your tests. You can also create variables inside tests,
but those will be local/available only to that test.
It is also ran before EVERY test, on top of the fact that is will run once after the start of the <code>suite</code>.</p>
<p><strong>Here is an example of <code>check</code> and <code>setup</code> templates:</strong></p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  setup:
    <span class="hljs-keyword">let</span> fruit = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>]
    <span class="hljs-keyword">var</span> kFruit: <span class="hljs-built_in">string</span>
  test <span class="hljs-string">&quot;Must be true&quot;</span>:
    require(<span class="hljs-literal">true</span>)
  test <span class="hljs-string">&quot;&quot;&quot;Fruit starting with the letter &quot;k&quot; &quot;&quot;&quot;</span>:
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fruit:
      <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;k&quot;</span>:
        kFruit = f
    check kFruit == <span class="hljs-string">&quot;kiwi&quot;</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Must be true
  <span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Fruit starting with the letter \"k\" </pre>
<p><a name = "`expect`-template"></a></p>
<h2>¬†¬†2.5. <code>expect</code> template</h2>
<hr />
<p>The <code>expect</code> template which tries to catch an exception(a type of error),
and if a specified exception is raised/caught, the test of <code>expect</code> will pass,
otherwise if the exception/error is NOT of the type specified, or if there isn't one at all, it will fail.</p>
<p><strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;My tests&quot;</span>:
  test <span class="hljs-string">&quot;Index out of bounds&quot;</span>:
    <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">#Does NOT work with [0, 1, 2] array - no exceptions for IOOB arrays</span>
    expect(<span class="hljs-type">IndexDefect</span>):        <span class="hljs-comment"># IOOB - index out of bounds, because IOOB on arrays,</span>
      <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">3</span>]        <span class="hljs-comment"># can always be found at compilation</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> My tests
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Index out of bounds</pre>
<p>Here is an example of a failed <code>check</code> and a failed <code>expect</code>:</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Failed expect and check&quot;</span>:
  test <span class="hljs-string">&quot;Failed check&quot;</span>:
      check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)
  test <span class="hljs-string">&quot;Failed expect&quot;</span>: <span class="hljs-comment">#Because it expects IndexDefect(IOOB)</span>
    <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
    expect(<span class="hljs-type">IndexDefect</span>):
      <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">0</span>]</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Failed expect and check
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(583, 16): Check failed: 1 == 2
  </span><span style = "color: rgba(255, 0, 0, 1)">[FAILED]</span> Failed check
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(586, 13): Expect Failed, no exception was thrown.
  <span style = "color: rgba(255, 0, 0, 1)">[FAILED]</span> Failed expect</pre>
<p><a name = "`checkpoint`-proc"></a></p>
<h2>¬†¬†2.6. <code>checkpoint</code> proc</h2>
<hr />
<p>The <code>checkpoint</code> proc will print out all of the checkpoints set before a [FAILURE] occurs inside either a <code>test</code>,
or a <code>check</code> template. It will NOT display [FAILURE], but instead, just the unittest error message:</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
  checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
  checkpoint(<span class="hljs-string">&quot;Checkpoint 2&quot;</span>)
  check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>))
  checkpoint(<span class="hljs-string">&quot;Checkpoint 3&quot;</span>)   <span class="hljs-comment">#Gets ignored</span>
  checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>) <span class="hljs-comment">#Gets ignored</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Checkpoints
    Checkpoint Start
    Checkpoint 2
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(599, 32): Check failed: (101, \"Hello World!\") == (1, \"Hello\")
</span></pre>
<p>If we then make the <code>check</code> succeed, none of the checkpoints will be shown.</p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
  checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
  checkpoint(<span class="hljs-string">&quot;Checkpoint 2&quot;</span>)
  check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>))
  checkpoint(<span class="hljs-string">&quot;Checkpoint 3&quot;</span>)   <span class="hljs-comment">#Gets ignored</span>
  checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>) <span class="hljs-comment">#Gets ignored</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Checkpoints
</span></pre>
<p><a name = "`teardown`-proc"></a></p>
<h2>¬†¬†2.7. <code>teardown</code> proc</h2>
<hr />
<p>Just like how the <code>setup</code> proc is ran BEFORE every test, the <code>teardown</code> proc is ran AFTER every test,
but not after the end of the <code>suite</code>. In other words <code>setup</code> is ran before <code>1 + numberOfTests</code>,
while <code>teardown</code> is ran after <code>numberOfTests</code>.</p>
<p><strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim">suite <span class="hljs-string">&quot;Setup and teardown example&quot;</span>:
  setup:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Ran BEFORE every test AND at the beginning of the `suite`&quot;</span>
  teardown:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Ran AFTER every test&quot;</span>
  test <span class="hljs-string">&quot;Simple arithmetic check&quot;</span>:
    check(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)
  test <span class="hljs-string">&quot;Just another test&quot;</span>:
    check(<span class="hljs-string">&quot;a&quot;</span> == <span class="hljs-string">&quot;a&quot;</span>)
  test <span class="hljs-string">&quot;Yet another test&quot;</span>:
    check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>) <span class="hljs-comment">#_FAILED</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Code put inside a suite, but OUTSIDE all of the tests, is also ran only once&quot;</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<pre class = "" style = "overflow-x: auto;">
<span style = "color: rgba(0, 132, 255, 1)">[Suite]</span><span style = "color:white";> Setup and teardown example
Ran BEFORE every test AND at the beginning of the `suite`
Ran AFTER every test
  </span><span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Simple arithmetic check
Ran BEFORE every test AND at the beginning of the `suite`
Ran AFTER every test
  <span style = "color: rgba(0, 255, 0, 1)">[OK]</span> Just another test
Ran BEFORE every test AND at the beginning of the `suite`
    f:\\Nim\\Nim YouTube Projects\\Current Projects\\Nim's Debugging Methods\\NimsDebuggingMethods.nim(635, 14): Check failed: 1 == 2
Ran AFTER every test
  <span style = "color: rgba(255, 0, 0, 1)">[FAILED]</span> Yet another test
Code put inside a suite, but OUTSIDE all of the tests, is also ran only once</pre>
<p>The output is a bit confusing, because all of the echoes are happening before the <code>[OK]</code> outputs.
But that is just because the <code>[OK]</code> flag is outputted AFTER the entire test is finished, including the <code>setup</code> and <code>teardown</code>.</p>
<p>This is demonstrated very well with the one <code>[FAILED]</code> at the bottom.
First the <code>setup</code>'s echo triggers, then the error, then the <code>teardown</code> and finally the <code>[FAILED]</code> flag.</p>
<p><a name = "testament-automatic-unit-tester"></a></p>
<h1>3. Testament automatic unit tester</h1>
<hr />
<p>Testament is the Nim's way of advanced automatic unittesting.
It offers one befit over the unittest module, which is process isolation for your tests.
Instead of one instance running all of your tests, this will instead be split.
This can offer great benefits such as, if multiple parts of your program you want tested,
write to the <code>stdout</code>, and make a big mess, testament will avoid this.
Obviously this is just the simplest example, it is very beneficial.</p>
<p>Testament is shipped along with Nim, and doesn't require any imports.
But to use it, you will have to use the terminal, like with <code>nimble</code>.
<code>testament run test1.nim</code> is the simplest example of using testament.</p>
<p>But before that, you should make a <code>tests</code> folder next to your main program.
And inside it you will put your tests, which will be nim files <code>.nim</code>.
(You can change where this module looks for tests)
Make sure that ALL of your tests start with the letter <code>t</code>, so <code>test.nim</code>, <code>tmyTest.nim</code>, etc.</p>
<p>#TODO check the forum post, we might be having a directory structure problem,
#even though we followed ringabout's tutorial... his structure might be wrong
#or something...
#the post does NOT address the freaking assert 42 == 42 FAILING !!!
#TODO once we actually get this working, the wording will most probably change
#TODO Very brief showcase of running a simple single example only, this is long enough as is</p>
<p><a name = "stack-tracing"></a></p>
<h1>4. Stack tracing</h1>
<hr />
<p>Stack tracing is getting a report of the current active frame being executed by the compiler.
The stack meaning, all the code we write that isn't a <code>string, sequence</code>,
and other data types that live on the heap, or ones we explicitly mark to be on the heap.
#TODO is this correct ???</p>
<p>The frame simply means a collection of code on the stack.
That stack inside the frame(with a frameMsg),
contains the name of the <code>proc</code> being executed, the line it's from,
and the filename(for when your program is split into multiple and using modules).</p>
<p>With all that said, getting a <code>stack traceback</code> can be very useful for debugging,
because you can get the information on where the code crashed,
when the compiler can't, and ESPECIALLY in release mode, which has a lot of the safety measures for debugging,
turned off for reasons of speed. But this has to be done manually by basically setting checkpoints.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">#Stack tracing</span>
<span class="hljs-keyword">proc</span> checkpoint2() =
  writeStackTrace()

<span class="hljs-keyword">proc</span> checkpoint() =
  checkpoint2()

checkpoint()</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<img src = "images\stackTracing.png">
<p>So the the stack trace starts at the top, <code>stackTracing</code> is the name of the file it's being called from,
and the start of the stack trace.
Then we have <code>checkpoint</code> which calls <code>checkpoint2</code> in that stack frame.</p>
<p><strong>Here is another example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/strutils

<span class="hljs-keyword">var</span> lowercaseWords = @[<span class="hljs-string">&quot;program&quot;</span>, <span class="hljs-string">&quot;nim&quot;</span>, <span class="hljs-string">&quot;gimp&quot;</span>, <span class="hljs-string">&quot;computer&quot;</span>]

<span class="hljs-keyword">proc</span> capitalizeAscii(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> =
  <span class="hljs-literal">result</span> = strutils.capitalizeAscii(s)
  writeStackTrace()

<span class="hljs-keyword">for</span> lWord <span class="hljs-keyword">in</span> lowercaseWords.mitems: <span class="hljs-comment">#Modifiable</span>
  <span class="hljs-keyword">if</span> lWord[<span class="hljs-number">0</span>].isLowerAscii:
    lWord = lWord.capitalizeAscii <span class="hljs-comment">#Our capitalizeAscii</span>

<span class="hljs-keyword">echo</span> lowercaseWords</code></pre>
<img src = "images\stackTracing2.png">
<p>As you can see, we get 4x tracebacks for the 4x lowercaseWords.
This is very useful to determine how many times a loop happened, but more importantly if something weird happened there,
and most importantly, when the crash/error happened. For example, the program could run several times just fine,
but then some data wasn't correct for a proc and a crash happened.
If this happened inside a loop going trough a VERY large collection of data, it would be like finding a needle in a haystack.</p>
<p><strong>Here is an example of just that, an error inside a loop:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/strutils

                      <span class="hljs-comment"># 0    1     2      3     4       5     6     7      8       9     10     11   12</span>
<span class="hljs-keyword">var</span> integersToParse = @[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;25&quot;</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;68&quot;</span>, <span class="hljs-string">&quot;-100&quot;</span>, <span class="hljs-string">&quot;75&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>, <span class="hljs-string">&quot;-17&quot;</span>, <span class="hljs-string">&quot;10.1&quot;</span>, <span class="hljs-string">&quot;99&quot;</span>, <span class="hljs-string">&quot;-44&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]
<span class="hljs-keyword">var</span> parsedIntegers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]

<span class="hljs-keyword">proc</span> parseInt(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-literal">result</span> = strutils.parseInt(s) <span class="hljs-comment">#This one is a proc {.noSideEffect.}</span>
  writeStackTrace()

<span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> integersToParse:
  parsedIntegers.add number.parseInt <span class="hljs-comment">#Our parseInt</span>

<span class="hljs-keyword">echo</span> parsedIntegers</code></pre>
<img src = "images\stackTracing3.png">
<p>Now, this example doesn't have a big enough of a collection of data that you couldn't find the problem quickly.
But it should demonstrate that, if that collection of data was in the hundreds, thousands and more,
it would take just way too much time.</p>
<p>And with that, stack tracing found the problem easily. Index 8 of <code>&quot;10.1&quot;</code> is a float when parsed, not an int.</p>
<p><a name = "code-usage-profiling"></a></p>
<h1>5. Code Usage Profiling</h1>
<hr />
<p>This method will measure in % the amount of processing was spent of the total on a given call(stack trace).
To do this, we will have to <code>import std/nimprof</code> Nim's embedded profiler,
and enable it and stack tracing with <strong>the following flags inside a <code>config.nims</code> file:</strong></p>
<pre><code class="nohighlight hljs nim">--profiler:on 
--stackTrace:on</code></pre>
<p>The following is a sample program that we are going to be using for code usage profiling:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/nimprof 
<span class="hljs-keyword">import</span> std/strutils 

<span class="hljs-keyword">proc</span> letters() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found letter&quot;</span>)

<span class="hljs-keyword">proc</span> numbers() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found number&quot;</span>)

<span class="hljs-keyword">proc</span> different() =
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found something else&quot;</span>)

<span class="hljs-keyword">proc</span> analyse(data: <span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> index &lt; data.len:
    <span class="hljs-keyword">case</span> data[index]
    <span class="hljs-keyword">of</span> <span class="hljs-type">Letters</span>: letters()
    <span class="hljs-keyword">of</span> {<span class="hljs-string">'0'</span> .. <span class="hljs-string">'9'</span>}: numbers()
    <span class="hljs-keyword">else</span>: different()
    index.inc

<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. <span class="hljs-number">1000</span>: 
  analyse(<span class="hljs-string">&quot;uyguhijkmnbreadv44354gasuygi456donkey456uiolkno,.,Ochyqudsayd12635uha&quot;</span>)</code></pre>
<p>The above code's results will be inside <code>profile_results.txt</code> file.
<strong>Here are the results after completion:</strong></p>
<img src = "images\codeUsageProfilingResults.png">
<img src = "images\codeUsageProfilingResultsLeftSide.png">
<p>The profiling results are split into 2x parts. The left side contains all the stack traces,
with the percental values on the far left representing the percentage of the TOTAL usage of that stack frame,
relative to the program. So the first stack frame took 41% of the program's total usage</p>
<img src = "images\codeUsageProfilingResultsRightSide.png">
<p>Now the right side shows the percental usage/time spent on each of the <code>proc calls</code> relative to that stack frame.
So the first stack frame spent 86% on the <code>analyse proc</code>.
<code>Profiling</code> with it's near 100% value, is just the profiler, you may completely ignore it.</p>
<p>Then the second stack frame also took the same amount of processing on the <code>analyse proc</code>,
but it also called the <code>numbers proc</code> 28% of the time.</p>
<p>There are just 3 procs inside the <code>nimprof</code> module.
These are the following <code>disableProfiling</code>, <code>enableProfiling</code> and <code>setSamplingFrequency</code>.
You can use the enable and disableProfiling procs to mark only the desired parts of your code to profile.</p>
<p>With all that said, this should of demonstrated how you can use Nim's embedded profiler to find bottle necks in your programs.</p>
<p><a name = "using-nimprof-as-a-memory-profiler"></a></p>
<h1>6. Using nimprof as a memory profiler</h1>
<hr />
<p>Nim's embedded profiler can also be used to profile your program's memory.
It will tell you which stack traces use/allocate the most memory, and thus find memory bottle necks, or potentially memory leaks.</p>
<p>To do this, all you have to do is <code>import nimprof</code>, set the following flags in your <code>config.nims</code> configuration file:</p>
<pre><code class="nohighlight hljs nim">--profiler:off 
--stackTrace:on 
--d:memProfiler</code></pre>
<p>And then run your program.
(Yes, <code>--profiler:off</code>, Seems bizzare but that's how this works...)</p>
<p>Sadly Nim's embedded profiler is kind of picky and will not give you ANY results if the sample size is too small.
Which is why the <code>Code Usage Profiling</code> example had to be run multiple times at least(1000 just to be safe).
And so for memory profiling, that example is terrible, as it does barely any allocations at all.</p>
<p><strong>So, here is an allocation heavy example for the memory profiler:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/nimprof 
<span class="hljs-keyword">import</span> std/strutils</code></pre>
<p>You can also set the following following flag <code>--d:ignoreAllocationSize</code>(define the symbol),
so that the only the number of memory allocations get profiled, not the size.</p>
<p><a name = "time-elapsed-profiling/benchmarking"></a></p>
<h1>7. Time Elapsed Profiling/Benchmarking</h1>
<hr />
<p>I have already shown this in the <code>List Comprehensions with sugar.collect vs Python's List Comprehensions</code> tutorial.
But i have a bit more to say, and it has to included in this tutorial.</p>
<p>Since Nim doesn't have a module specifically for this, this is custom made.
Time elapsed/based benchmarking is used in basically every programming language out there.
But they are often misused, used for comparisons between programming languages.
Because the implementations may vary significantly. E.g. Python is a dynamic programming language,
and with that it is slow. But since it's so popular, it's implementations are VERY optimized using <code>Cython</code>,
that's what the source code of Python is called, since it's written in <code>C</code>.
And with that, the benchmark then becomes a benchmark of implementations instead of languages.</p>
<p>The use case for this compared to an actual external dedicated profiler is,
that this is much easier and simpler to both setup and use. An actual external profiler will have many more features for finding bottle necks.
Features that will find neglected code that a time based/elapsed profiler cannot.
But again a time based/elapsed profiler is very simple, while a dedicated/general profiler can be quite tricky to learn,
and may often be total overkill.</p>
<p>With that said, unless you know there are lots of bottle necks you have to optimize once the bulk of your program is done,
use the simplest tool for the job.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

<span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = cpuTime()

    <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
      code

    <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
    <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
    <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
  <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
    list.add j

benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
  <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

  <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
    list[index] = index

benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-keyword">var</span> list = collect:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      i</code></pre>
<pre>
CPU Time [add    ] x 10000 = 0.000142300000s
CPU Time [index  ] x 10000 = 0.000157300000s
CPU Time [collect] x 10000 = 0.000142400000s
</pre>
<h1>Outro - Afterwords</h1>
<hr />
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of written tutorial.</p>
<h1>Thanks to my past and current Patrons</h1>
<hr />
<h2>Past Patrons</h2>
<hr />
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<h2>Current Patrons</h2>
<hr />
<ul>
<li>jaap groot (from October 2023)</li>
<li>Dimitri Lesnoff (from October 2023)</li>
</ul>
<h2>Compiler Information</h2>
<hr />
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option(mm:orc)</li>
</ul>
<h2>My and General Links</h2>
<hr />
<ul>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<h2>Links to this video's subject:</h2>
<hr />
<ul>
<li><a href="https://nim-lang.org/docs/sugar.html#dump.m%2Cuntyped">dump macro</a></li>
<li><a href="https://nim-lang.org/docs/sugar.html#dumpToString.m%2Cuntyped">dumpToString macro</a></li>
<li><a href="https://nim-lang.org/docs/unittest.html">unittest module for advanced testing of your code</a></li>
<li><a href="https://github.com/status-im/nim-unittest2">unittest 2 potential candidate to replace unittest</a></li>
<li><a href="https://nim-lang.org/docs/nimprof.html">Nim's embedded profiler</a></li>
<li><a href="https://nim-lang.org/docs/estp.html">Embedded Stack Trace Profiler (ESTP) User Guide</a></li>
</ul>
<h2>Stack Tracing procs, etc -&gt; (system module)</h2>
<hr />
<ul>
<li><a href="https://nim-lang.org/docs/nimprof.html">StackTraceEntry object</a></li>
<li><a href="https://nim-lang.org/docs/system.html#getStackTrace">getStackTrace proc</a></li>
<li><a href="https://nim-lang.org/docs/system.html#getStackTraceEntries">getStackTraceEntries</a></li>
<li><a href="https://nim-lang.org/docs/system.html#nimGC_setStackBottom%2Cpointer">nimGC_setStackBottom</a></li>
<li><a href="https://nim-lang.org/docs/system.html#nimGC_setStackBottom%2Cpointer">stackTraceAvailable</a></li>
<li><a href="https://nim-lang.org/docs/system.html#writeStackTrace">writeStackTrace</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>
<span class="hljs-comment">#nbShow is super useful!</span>
<span class="hljs-comment">#&lt;code&gt;&lt;/code&gt; makes text with a background</span>

<span class="hljs-comment">#https://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals raw strings r&quot;&quot;</span>

<span class="hljs-keyword">import</span> nimib, std/strutils, std/strformat <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment">#Overriding nimib's nbCode -&gt; with a version that has horizontal scroll for overflowing output</span>
<span class="hljs-keyword">import</span> nimib / [capture]

<span class="hljs-keyword">template</span> nbCode(body: <span class="hljs-built_in">untyped</span>) {.used.} =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCode&quot;</span>, body): <span class="hljs-comment">#Writes to stdout `lineNumb typeOfNBblock: a bit of first line</span>
    captureStdout(nb.blk.output):
      body

nb.partials[<span class="hljs-string">&quot;nbCode&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
{{&gt;nbCodeSource}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot; style = &quot;color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;&quot;&gt;{{&gt;nbCodeOutput}}&lt;/code&gt;&lt;/pre&gt;
&quot;&quot;&quot;</span> 
nb.renderPlans[<span class="hljs-string">&quot;nbCode&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>] <span class="hljs-comment"># default partial automatically escapes output (code is escaped when highlighting)</span>
                                              <span class="hljs-comment"># Required to show the code that then gets it's output shown aswell, if empty, empty &lt;code&gt;&lt;/code&gt; line</span>

<span class="hljs-keyword">template</span> colorizeLines(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">var</span> bodyColorized = body.repr

  <span class="hljs-keyword">var</span> timesToColorize: <span class="hljs-built_in">int</span>
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[Suite]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[Suite]&quot;</span>)
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>)
  <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>) &gt; <span class="hljs-number">0</span>:
    timesToColorize += bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>)

  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">var</span> suiteFinalStage = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">var</span> currentIndex: <span class="hljs-built_in">int</span>

  <span class="hljs-keyword">while</span> index &lt; <span class="hljs-number">1</span>:
    <span class="hljs-comment"># [Suite]   </span>
    <span class="hljs-keyword">if</span> suiteFinalStage == <span class="hljs-literal">false</span>:
      bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(0, 132, 255, 1)&quot;&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[Suite]&quot;</span>))
      bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&lt;span style = &quot;color:white&quot;;&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[Suite]&quot;</span>) + <span class="hljs-string">&quot;[Suite]&quot;</span>.len)
      suiteFinalStage = <span class="hljs-literal">true</span>

      <span class="hljs-keyword">if</span> bodyColorized.count(<span class="hljs-string">&quot;[OK]&quot;</span>) &gt; <span class="hljs-number">0</span>:
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[OK]&quot;</span>))
        currentIndex = bodyColorized.find(<span class="hljs-string">&quot;[OK]&quot;</span>) + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>.len-<span class="hljs-number">1</span> <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
      <span class="hljs-keyword">elif</span> bodyColorized.count(<span class="hljs-string">&quot;[FAILED]&quot;</span>) &gt; <span class="hljs-number">0</span>:
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.find(<span class="hljs-string">&quot;[FAILED]&quot;</span>))
        currentIndex = bodyColorized.find(<span class="hljs-string">&quot;[FAILED]&quot;</span>) + <span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>.len-<span class="hljs-number">1</span> <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
      <span class="hljs-keyword">else</span>: <span class="hljs-comment">#If it only has [Suite] end it, no need to increase the index</span>
        bodyColorized.insert(<span class="hljs-string">&quot;&quot;&quot;&lt;/span&gt;&quot;&quot;&quot;</span>, bodyColorized.len-<span class="hljs-number">1</span>) <span class="hljs-comment">#Must be -1</span>
        index += <span class="hljs-number">1</span>
    <span class="hljs-comment">#-[OK] and [FAILED]</span>
    bodyColorized = bodyColorized.replaceWord(<span class="hljs-string">&quot;[OK]&quot;</span>, <span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(0, 255, 0, 1)&quot;&gt;[OK]&lt;/span&gt;&quot;&quot;&quot;</span>)
    bodyColorized = bodyColorized.replaceWord(<span class="hljs-string">&quot;[FAILED]&quot;</span>, <span class="hljs-string">&quot;&quot;&quot;&lt;span style = &quot;color: rgba(255, 0, 0, 1)&quot;&gt;[FAILED]&lt;/span&gt;&quot;&quot;&quot;</span>)
    
    <span class="hljs-comment">#Temporary improvement</span>
    <span class="hljs-keyword">if</span> bodyColorized.startsWith(<span class="hljs-string">&quot;&quot;&quot;&quot;\n&quot;&quot;&quot;</span>):
      bodyColorized.delete(<span class="hljs-number">0.</span>.<span class="hljs-number">2</span>)
    <span class="hljs-keyword">if</span> bodyColorized.endsWith(<span class="hljs-string">&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span>):
      bodyColorized.delete(bodyColorized.len-<span class="hljs-number">1.</span>.bodyColorized.len-<span class="hljs-number">1</span>)

    <span class="hljs-comment">#Removing raw \n, which are the ones shown</span>
    bodyColorized = bodyColorized.replace(<span class="hljs-string">r&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)

    <span class="hljs-comment">#Not sure why, but it errors without it</span>
    bodyColorized.stripLineEnd 
    
  bodyColorized

<span class="hljs-keyword">var</span> output: <span class="hljs-built_in">string</span>
<span class="hljs-keyword">template</span> nbColorizeOutputUT() =
  output = nb.blk.output
  output = output.colorizeLines

  <span class="hljs-comment">#Clearing old output</span>
  nb.blk.output = <span class="hljs-string">&quot;&quot;</span>
  nb.blk.context[<span class="hljs-string">&quot;output&quot;</span>] = <span class="hljs-string">&quot;&quot;</span>

  nbRawHtml: &amp;<span class="hljs-string">&quot;&quot;&quot;&lt;pre class = &quot;&quot; style = &quot;overflow-x: auto;&quot;&gt;{output}&lt;/pre&gt;&quot;&quot;&quot;</span> <span class="hljs-comment">#class = &quot;&quot; so we don't get green font</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">var</span> index = (section: <span class="hljs-number">0</span>, subsection: <span class="hljs-number">0</span>)

<span class="hljs-keyword">template</span> nbSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  index.section.inc
  index.subsection = <span class="hljs-number">0</span> <span class="hljs-comment">#Reset on a new nbSection</span>

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;. &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;- &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> <span class="hljs-comment">#&amp;#92; is HTML code for &quot;\&quot;, you can also &quot;\\&quot; or r&quot;\&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbSubSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbUoSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbUoSubSection(name: <span class="hljs-built_in">string</span>) {.used.} =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbCodeSnippet(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>, body):
    nb.blk.output = body

nb.partials[<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;&lt;pre&gt;&lt;code class=&quot;hlNim&quot;&gt;{{&amp;output}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>
nb.renderPlans[<span class="hljs-string">&quot;nbCodeSnippet&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>]

<span class="hljs-comment">#Updating the same file is shown instantly once deployed via Github Page on PC. </span>
  <span class="hljs-comment">#Mobile takes either a random amount of time, or NOT at all!</span>
<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">hlHtml&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTop&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;
      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTopMobile&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
        // Get the button
        let myButton = document.getElementById(&quot;toTop&quot;);
        let myButtonMobile = document.getElementById(&quot;toTopMobile&quot;);
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName(&quot;body&quot;); //gives a query object

        //myButton.style.color = &quot;red&quot;; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if (&quot;maxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints &gt; 0;
          } 
        else if (&quot;msMaxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints &gt; 0;
          } 
        else 
          {
            var mQ = window.matchMedia &amp;&amp; matchMedia(&quot;(pointer:coarse)&quot;);

            if (mQ &amp;&amp; mQ.media === &quot;(pointer:coarse)&quot;) 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
              currentButton.style.display = &quot;block&quot;;
            } else {currentButton.style.display = &quot;none&quot;;}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Use Live Preview Extension and set the Auto Refresh Preview set to &quot;On changes to Saved Files&quot;</span>
  <span class="hljs-comment">#And Server Keep Alive After Embedded Preview Close set to 0, </span>
  <span class="hljs-comment">#so that we no longer need the preview embedded window, we now have it in the browser!</span>
    <span class="hljs-comment">#Live SERVER Extension no longer works, even with the .html file kept open</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd enables nimiboost's markdown highlight mode. hlMdf adds the fmt&quot;{var}&quot; functionality</span>
nbText: <span class="hljs-string">hlmdf&quot;&quot;&quot;
## INTRO - GREETING
- **Title**: Nim's Debugging Methods
- **Alt Title**: Part 1 of 2(Part 1 is Nim's Debugging Methods); Part 2 is using external debuggers and profilers
- **Prerequired knowledge:** Up to and including: Nim for Beginners List Comprehensions with sugar.collect vs Python's List Comprehensions 

## INTRO - FOREWORDS
**(What is the purpose of this video ?)**
- Nim's Debugging Methods:
  - In this video we will go over all the debugging methods Nim has specifically.
  Actual debuggers and profilers are the subject of a part 2 video.
   
The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Debugging your programs&quot;</span>
nbSubSection <span class="hljs-string">&quot;Simple debugging methods(`echo`, `assert`, `doAssert`)&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  We have been using `echo` for debugging our programs for a long while now.
  But there is also `assert` and `doAssert`

  **Here is an example of `assert`:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  How this works is that, if the condition is true, nothing will happen, the program will simply continue.
  But if the condition is false, then you will get an error like this:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span>

nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\assertError.png&quot;&gt;&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  `assert` only works in the default debug mode `-d:debug`(terminal, config.nims gets extra `-` --d:debug).
  It gets ignored by the compiler.

  Now there is also `doAssert`, which stays in the release version `-d:release` of your program.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`debugEcho` and No Side Effects programming&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  There is another type of `echo` called `debugEcho` which pretends to be of no side effects,
  in order for it to work with `procs` marked with {.noSideEffect.} pragma.

  `func` keyword that can be used in place of `proc`, simply means `proc myProc(arg: type) {.noSideEffect.} =`.
  And {.noSideEffect.} pragma means that this proc will use the `functional` programming paradigm's,
  no side effects term. Which means, that if a proc with no side effects pragma or a func,
  is given parameters, and if those parameters are the same, it should always return the same output.
  And it should NOT modify any outside state, e.g. writting to the `stdout`.

  This is MOSTLY true in Nim, but Nim is NOT a functional programming language.
  It only has some features of one as an addon to make it better.

  **Here is an example:**
  Let's demonstrate this no side effects term, by making a proc that writes to the `stdout`,
  by either using `echo` or `stdout.write`/`.writeln`, running it, and then changing the proc to a `func`,
  and or adding the {.noSideEffect.} pragma:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> writeToStdout() =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout()

nbCodeSkip:
  <span class="hljs-keyword">func</span> writeToStdout2() =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout2()
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffects.png&quot;&gt;&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffectsError.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Error, will not compile.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> writeToStdout3() {.noSideEffect.} =
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout3()
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffects2.png&quot;&gt;&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\sideEffectsError2.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Error, will not compile.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> writeToStdout4() {.noSideEffect.} =
    debugEcho <span class="hljs-string">&quot;Hello&quot;</span>

  writeToStdout4()
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now the warning is silenced, and we can compile, **BUT it will have side effects!**
  &lt;h6&gt;(you may double check that yourself)&lt;/h6&gt;
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Sugar module's `dump` macro&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `dump` macro takes identifiers/variables and uses `echo` to, 
  print out the name and the value of the variables given in the following pattern `(a, b) = (aVal, bVal)`.
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/sugar

  <span class="hljs-keyword">var</span> aVar = <span class="hljs-number">101</span>
  <span class="hljs-keyword">let</span> aLet = <span class="hljs-number">202</span>
  <span class="hljs-keyword">const</span> aConst = <span class="hljs-number">303</span>
  dump (aVar, aLet, aConst) <span class="hljs-comment">#Requires parentheses</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  I don't recommend using it with multiple variables with complex values at the same time.
  It will get confusing, because you will read the variable on the left, 
  then search trough a lot of data on the right, instead of simply having each variable on it's own line.

  I recommend using it for a single variable at a time, and with that, the pattern is simply `varName = value`.
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  aVar.dump

nbSubSection <span class="hljs-string">&quot;Sugar module's `dumpToString` macro&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `dumpToString` macro functions differently to the `dump` macro.
  It does not call `echo` to display variable names and their values.
  Instead it returns a string, whilst also expanding templates and macros(similar to calling repr on them).
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">MyObject</span> = <span class="hljs-keyword">object</span>
      name: <span class="hljs-built_in">string</span>
      value: <span class="hljs-built_in">int</span>

  <span class="hljs-keyword">var</span> myObject = <span class="hljs-type">MyObject</span>(name: <span class="hljs-string">&quot;Hello&quot;</span>, value: <span class="hljs-number">101</span>)
  <span class="hljs-keyword">echo</span> myObject.dumpToString

  <span class="hljs-keyword">var</span> someVar = <span class="hljs-number">101</span>
  <span class="hljs-keyword">echo</span> someVar.dumpToString
  <span class="hljs-keyword">echo</span> myObject.dumpToString, someVar.dumpToString

nbText: <span class="hljs-string">&quot;&quot;&quot;
  A little bit of an odd output, the name of the variable is outputted twice...
  I personally prefer the `dump` macro for singular variables, 
  but since this one doesn't call `echo` and expands templates and macros,
  you can use it in more freeing and useful ways.

  **Here is an example with calling `dumpToString` on a template calling a proc:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> sum(a, b: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
    a + b
    
  <span class="hljs-keyword">template</span> varPassTrough(variable: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    sum(variable, variable)

  <span class="hljs-keyword">echo</span> varPassTrough(someVar)
  <span class="hljs-keyword">echo</span> varPassTrough(someVar).dumpToString

nbText: <span class="hljs-string">&quot;&quot;&quot;
  With `dumpToString` you will know what is going on within your templates etc,
  by seeing the name of procs being used and with what arguments.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`astToStr proc`&quot;</span> 
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `astToStr` proc takes the name of an identifier like `var` and `let`,
  and returns the name of the identifier. This is very useful for debugging,
  because, let's say that you had lots of variables you wanted to know their values of at all times.
  Now you would first form 1x echo call, then copy paste it and then change the variables.
  And if you also wanted to know what variable's value you are displaying,
  you would have to manually write it as a string. But with `astToStr` you wouldn't have to.

  **For that reason, here in an example of `astToStr` with a template for displaying the name of the variable,
  the type, and it's value:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">template</span> dbgMsg(varName: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">echo</span> varName.astToStr, <span class="hljs-string">&quot; of type &quot;</span>, varName.typeof, <span class="hljs-string">&quot; of value &quot;</span>, varName
  
  <span class="hljs-keyword">var</span> myVar: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  <span class="hljs-keyword">let</span> myLet: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  <span class="hljs-keyword">const</span> myConst: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.99</span>
  myVar.dbgMsg
  myLet.dbgMsg
  myConst.dbgMsg <span class="hljs-comment">#Doesn't work with constants, returns the value instead of the name</span>

nbSection <span class="hljs-string">&quot;Unit testing&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  A more advanced way of debugging your programs is called `unit testing` by the usage of the `unittest` module.
  Unit testing is the method that the vast majority of other programming languages use,
  and so Nim also has it.

  Unit testing works somewhat like using `assert`, but it has more options like not quiting on a failed test,
  and displaying what exactly failed.
  Unit testing is not meant to stay in your programs in release versions, but to iron out the bugs before it gets to that.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`suite` template&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  To start a unit test, you need to call the `suite` template to start a block of unit testing code like this:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/unittest

  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    <span class="hljs-keyword">discard</span>
nbColorizeOutputUT <span class="hljs-comment">#TODO - our template makes an extra line... if we delete the first 2 indexes, we delete &lt;s ...</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, you have to name your `suite`, which serves as basically a collection of tests you will perform.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`test` template&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  To begin unittesting our code, we need to use the `test` template for our tests which we also have to name.
  The `test` template then starts a test of the following block of code. And will return [OK], or [FAILED],
  depending on the checked code inside of it.
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    test <span class="hljs-string">&quot;Must be true&quot;</span>:
      <span class="hljs-keyword">discard</span>
nbColorizeOutputUT

nbSubSection <span class="hljs-string">&quot;`require` template&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  One can use the `require` template of type bool, to which we have to specify what value we want it to be, true or false.
  Then this condition needs to be of that bool value otherwise the test fails. 
  This is meant for code that is crucial for your program, that if it fails, there is no point in running anymore tests.
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    test <span class="hljs-string">&quot;Must be true&quot;</span>:
      require(<span class="hljs-literal">true</span>)
nbColorizeOutputUT

nbSubSection <span class="hljs-string">&quot;`check` and `setup` templates&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now to check values to be of the desired value you want for the functionality of your program, 
  there is the `check` template.
  
  You can also use the `setup` section for a `suite`, to for example declare variables you want to use in testing,
  those variables will be available to ALL of your tests. You can also create variables inside tests,
  but those will be local/available only to that test. 
  It is also ran before EVERY test, on top of the fact that is will run once after the start of the `suite`.

  **Here is an example of `check` and `setup` templates:**
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    setup:
      <span class="hljs-keyword">let</span> fruit = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;kiwi&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>]
      <span class="hljs-keyword">var</span> kFruit: <span class="hljs-built_in">string</span>
    test <span class="hljs-string">&quot;Must be true&quot;</span>:
      require(<span class="hljs-literal">true</span>)
    test <span class="hljs-string">&quot;&quot;&quot;Fruit starting with the letter &quot;k&quot; &quot;&quot;&quot;</span>:
      <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fruit:
        <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;k&quot;</span>:
          kFruit = f
      check kFruit == <span class="hljs-string">&quot;kiwi&quot;</span>
nbColorizeOutputUT

nbSubSection <span class="hljs-string">&quot;`expect` template&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The `expect` template which tries to catch an exception(a type of error),
  and if a specified exception is raised/caught, the test of `expect` will pass, 
  otherwise if the exception/error is NOT of the type specified, or if there isn't one at all, it will fail.
  
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;My tests&quot;</span>:
    test <span class="hljs-string">&quot;Index out of bounds&quot;</span>:
      <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment">#Does NOT work with [0, 1, 2] array - no exceptions for IOOB arrays</span>
      expect(<span class="hljs-type">IndexDefect</span>):        <span class="hljs-comment"># IOOB - index out of bounds, because IOOB on arrays,</span>
        <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">3</span>]        <span class="hljs-comment"># can always be found at compilation</span>
nbColorizeOutputUT

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here is an example of a failed `check` and a failed `expect`:
&quot;&quot;&quot;</span>
nbCode: 
  suite <span class="hljs-string">&quot;Failed expect and check&quot;</span>:
    test <span class="hljs-string">&quot;Failed check&quot;</span>:
        check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)
    test <span class="hljs-string">&quot;Failed expect&quot;</span>: <span class="hljs-comment">#Because it expects IndexDefect(IOOB)</span>
      <span class="hljs-keyword">let</span> numbers = @[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
      expect(<span class="hljs-type">IndexDefect</span>):
        <span class="hljs-keyword">discard</span> numbers[<span class="hljs-number">0</span>] 
nbColorizeOutputUT <span class="hljs-comment">#TODO weirdly almost all of it is green colorized without using the nbColorizeOutputUT</span>

nbSubSection <span class="hljs-string">&quot;`checkpoint` proc&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The `checkpoint` proc will print out all of the checkpoints set before a [FAILURE] occurs inside either a `test`,
  or a `check` template. It will NOT display [FAILURE], but instead, just the unittest error message:
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
    checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
    checkpoint(<span class="hljs-string">&quot;Checkpoint 2&quot;</span>)
    check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>))
    checkpoint(<span class="hljs-string">&quot;Checkpoint 3&quot;</span>)   <span class="hljs-comment">#Gets ignored</span>
    checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>) <span class="hljs-comment">#Gets ignored</span>
nbColorizeOutputUT

nbText: <span class="hljs-string">&quot;&quot;&quot;
  If we then make the `check` succeed, none of the checkpoints will be shown.
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;Checkpoints&quot;</span>:
    checkpoint(<span class="hljs-string">&quot;Checkpoint Start&quot;</span>)
    checkpoint(<span class="hljs-string">&quot;Checkpoint 2&quot;</span>)
    check((<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>) == (<span class="hljs-number">101</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>))
    checkpoint(<span class="hljs-string">&quot;Checkpoint 3&quot;</span>)   <span class="hljs-comment">#Gets ignored</span>
    checkpoint(<span class="hljs-string">&quot;Checkpoint End&quot;</span>) <span class="hljs-comment">#Gets ignored</span>
nbColorizeOutputUT

nbSubSection <span class="hljs-string">&quot;`teardown` proc&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Just like how the `setup` proc is ran BEFORE every test, the `teardown` proc is ran AFTER every test,
  but not after the end of the `suite`. In other words `setup` is ran before `1 + numberOfTests`, 
  while `teardown` is ran after `numberOfTests`.

  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  suite <span class="hljs-string">&quot;Setup and teardown example&quot;</span>:
    setup:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Ran BEFORE every test AND at the beginning of the `suite`&quot;</span>
    teardown:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Ran AFTER every test&quot;</span>
    test <span class="hljs-string">&quot;Simple arithmetic check&quot;</span>:
      check(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)
    test <span class="hljs-string">&quot;Just another test&quot;</span>:
      check(<span class="hljs-string">&quot;a&quot;</span> == <span class="hljs-string">&quot;a&quot;</span>)
    test <span class="hljs-string">&quot;Yet another test&quot;</span>:
      check(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>) <span class="hljs-comment">#_FAILED</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Code put inside a suite, but OUTSIDE all of the tests, is also ran only once&quot;</span>
nbColorizeOutputUT
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The output is a bit confusing, because all of the echoes are happening before the `[OK]` outputs.
  But that is just because the `[OK]` flag is outputted AFTER the entire test is finished, including the `setup` and `teardown`.

  This is demonstrated very well with the one `[FAILED]` at the bottom.
  First the `setup`'s echo triggers, then the error, then the `teardown` and finally the `[FAILED]` flag.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Testament automatic unit tester&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Testament is the Nim's way of advanced automatic unittesting.
  It offers one befit over the unittest module, which is process isolation for your tests.
  Instead of one instance running all of your tests, this will instead be split.
  This can offer great benefits such as, if multiple parts of your program you want tested,
  write to the `stdout`, and make a big mess, testament will avoid this.
  Obviously this is just the simplest example, it is very beneficial.

  Testament is shipped along with Nim, and doesn't require any imports.
  But to use it, you will have to use the terminal, like with `nimble`.
  `testament run test1.nim` is the simplest example of using testament.

  But before that, you should make a `tests` folder next to your main program.
  And inside it you will put your tests, which will be nim files `.nim`.
  (You can change where this module looks for tests)
  Make sure that ALL of your tests start with the letter `t`, so `test.nim`, `tmyTest.nim`, etc.

  #TODO check the forum post, we might be having a directory structure problem,
    #even though we followed ringabout's tutorial... his structure might be wrong
    #or something...
    #the post does NOT address the freaking assert 42 == 42 FAILING !!!
  #TODO once we actually get this working, the wording will most probably change
  #TODO Very brief showcase of running a simple single example only, this is long enough as is
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Stack tracing&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Stack tracing is getting a report of the current active frame being executed by the compiler.
  The stack meaning, all the code we write that isn't a `string, sequence`,
  and other data types that live on the heap, or ones we explicitly mark to be on the heap.
  #TODO is this correct ???

  The frame simply means a collection of code on the stack.
  That stack inside the frame(with a frameMsg),
  contains the name of the `proc` being executed, the line it's from,
  and the filename(for when your program is split into multiple and using modules).

  With all that said, getting a `stack traceback` can be very useful for debugging,
  because you can get the information on where the code crashed,
  when the compiler can't, and ESPECIALLY in release mode, which has a lot of the safety measures for debugging,
  turned off for reasons of speed. But this has to be done manually by basically setting checkpoints.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">#Stack tracing</span>
  <span class="hljs-keyword">proc</span> checkpoint2() =
    writeStackTrace()

  <span class="hljs-keyword">proc</span> checkpoint() =
    checkpoint2()

  checkpoint()
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\stackTracing.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  So the the stack trace starts at the top, `stackTracing` is the name of the file it's being called from, 
  and the start of the stack trace.
  Then we have `checkpoint` which calls `checkpoint2` in that stack frame.

  **Here is another example:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/strutils

  <span class="hljs-keyword">var</span> lowercaseWords = @[<span class="hljs-string">&quot;program&quot;</span>, <span class="hljs-string">&quot;nim&quot;</span>, <span class="hljs-string">&quot;gimp&quot;</span>, <span class="hljs-string">&quot;computer&quot;</span>]

  <span class="hljs-keyword">proc</span> capitalizeAscii(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> =
    <span class="hljs-literal">result</span> = strutils.capitalizeAscii(s)
    writeStackTrace()

  <span class="hljs-keyword">for</span> lWord <span class="hljs-keyword">in</span> lowercaseWords.mitems: <span class="hljs-comment">#Modifiable</span>
    <span class="hljs-keyword">if</span> lWord[<span class="hljs-number">0</span>].isLowerAscii:
      lWord = lWord.capitalizeAscii <span class="hljs-comment">#Our capitalizeAscii</span>

  <span class="hljs-keyword">echo</span> lowercaseWords
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\stackTracing2.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, we get 4x tracebacks for the 4x lowercaseWords.
  This is very useful to determine how many times a loop happened, but more importantly if something weird happened there,
  and most importantly, when the crash/error happened. For example, the program could run several times just fine,
  but then some data wasn't correct for a proc and a crash happened. 
  If this happened inside a loop going trough a VERY large collection of data, it would be like finding a needle in a haystack.

  **Here is an example of just that, an error inside a loop:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/strutils

                        <span class="hljs-comment"># 0    1     2      3     4       5     6     7      8       9     10     11   12</span>
  <span class="hljs-keyword">var</span> integersToParse = @[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;25&quot;</span>, <span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;68&quot;</span>, <span class="hljs-string">&quot;-100&quot;</span>, <span class="hljs-string">&quot;75&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>, <span class="hljs-string">&quot;-17&quot;</span>, <span class="hljs-string">&quot;10.1&quot;</span>, <span class="hljs-string">&quot;99&quot;</span>, <span class="hljs-string">&quot;-44&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]
  <span class="hljs-keyword">var</span> parsedIntegers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]

  <span class="hljs-keyword">proc</span> parseInt(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-literal">result</span> = strutils.parseInt(s) <span class="hljs-comment">#This one is a proc {.noSideEffect.}</span>
    writeStackTrace()

  <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> integersToParse:
    parsedIntegers.add number.parseInt <span class="hljs-comment">#Our parseInt</span>

  <span class="hljs-keyword">echo</span> parsedIntegers

nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\stackTracing3.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now, this example doesn't have a big enough of a collection of data that you couldn't find the problem quickly.
  But it should demonstrate that, if that collection of data was in the hundreds, thousands and more,
  it would take just way too much time.

  And with that, stack tracing found the problem easily. Index 8 of `&quot;10.1&quot;` is a float when parsed, not an int.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Code Usage Profiling&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  This method will measure in % the amount of processing was spent of the total on a given call(stack trace).
  To do this, we will have to `import std/nimprof` Nim's embedded profiler,
  and enable it and stack tracing with **the following flags inside a `config.nims` file:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  --profiler:on 
  --stackTrace:on

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The following is a sample program that we are going to be using for code usage profiling:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/nimprof 
  <span class="hljs-keyword">import</span> std/strutils 

  <span class="hljs-keyword">proc</span> letters() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found letter&quot;</span>)

  <span class="hljs-keyword">proc</span> numbers() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found number&quot;</span>)

  <span class="hljs-keyword">proc</span> different() =
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Found something else&quot;</span>)

  <span class="hljs-keyword">proc</span> analyse(data: <span class="hljs-built_in">string</span>) =
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> index &lt; data.len:
      <span class="hljs-keyword">case</span> data[index]
      <span class="hljs-keyword">of</span> <span class="hljs-type">Letters</span>: letters()
      <span class="hljs-keyword">of</span> {<span class="hljs-string">'0'</span> .. <span class="hljs-string">'9'</span>}: numbers()
      <span class="hljs-keyword">else</span>: different()
      index.inc

  <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> .. <span class="hljs-number">1000</span>: 
    analyse(<span class="hljs-string">&quot;uyguhijkmnbreadv44354gasuygi456donkey456uiolkno,.,Ochyqudsayd12635uha&quot;</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The above code's results will be inside `profile_results.txt` file.
  **Here are the results after completion:**
&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\codeUsageProfilingResults.png&quot;&gt;&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\codeUsageProfilingResultsLeftSide.png&quot;&gt;&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The profiling results are split into 2x parts. The left side contains all the stack traces,
  with the percental values on the far left representing the percentage of the TOTAL usage of that stack frame,
  relative to the program. So the first stack frame took 41% of the program's total usage
&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">hlhtml&quot;&quot;&quot;&lt;img src = &quot;images\codeUsageProfilingResultsRightSide.png&quot;&gt;&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now the right side shows the percental usage/time spent on each of the `proc calls` relative to that stack frame.
  So the first stack frame spent 86% on the `analyse proc`. 
  `Profiling` with it's near 100% value, is just the profiler, you may completely ignore it.

  Then the second stack frame also took the same amount of processing on the `analyse proc`,
  but it also called the `numbers proc` 28% of the time.

  There are just 3 procs inside the `nimprof` module.
  These are the following `disableProfiling`, `enableProfiling` and `setSamplingFrequency`.
  You can use the enable and disableProfiling procs to mark only the desired parts of your code to profile.

  With all that said, this should of demonstrated how you can use Nim's embedded profiler to find bottle necks in your programs.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Using nimprof as a memory profiler&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Nim's embedded profiler can also be used to profile your program's memory.
  It will tell you which stack traces use/allocate the most memory, and thus find memory bottle necks, or potentially memory leaks.
  
  To do this, all you have to do is `import nimprof`, set the following flags in your `config.nims` configuration file:
&quot;&quot;&quot;</span>
nbCodeSkip:
  --profiler:off 
  --stackTrace:on 
  --d:memProfiler

nbText: <span class="hljs-string">&quot;&quot;&quot;
  And then run your program.
  (Yes, `--profiler:off`, Seems bizzare but that's how this works...)

  Sadly Nim's embedded profiler is kind of picky and will not give you ANY results if the sample size is too small.
  Which is why the `Code Usage Profiling` example had to be run multiple times at least(1000 just to be safe).
  And so for memory profiling, that example is terrible, as it does barely any allocations at all.

  **So, here is an allocation heavy example for the memory profiler:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/nimprof 
  <span class="hljs-keyword">import</span> std/strutils

<span class="hljs-comment">#TODO getting EMPTY `profile_results.txt` file............ how many memory allocations are we actually doing ? MUST ALLOCATE MEMORY in order to get any results !!!</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  You can also set the following following flag `--d:ignoreAllocationSize`(define the symbol), 
  so that the only the number of memory allocations get profiled, not the size.
&quot;&quot;&quot;</span>
<span class="hljs-comment">#TODO show the same example's results with the above flag</span>

nbSection <span class="hljs-string">&quot;Time Elapsed Profiling/Benchmarking&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  I have already shown this in the `List Comprehensions with sugar.collect vs Python's List Comprehensions` tutorial.
  But i have a bit more to say, and it has to included in this tutorial.

  Since Nim doesn't have a module specifically for this, this is custom made.
  Time elapsed/based benchmarking is used in basically every programming language out there.
  But they are often misused, used for comparisons between programming languages.
  Because the implementations may vary significantly. E.g. Python is a dynamic programming language,
  and with that it is slow. But since it's so popular, it's implementations are VERY optimized using `Cython`,
  that's what the source code of Python is called, since it's written in `C`.
  And with that, the benchmark then becomes a benchmark of implementations instead of languages.

  The use case for this compared to an actual external dedicated profiler is,
  that this is much easier and simpler to both setup and use. An actual external profiler will have many more features for finding bottle necks.
  Features that will find neglected code that a time based/elapsed profiler cannot.
  But again a time based/elapsed profiler is very simple, while a dedicated/general profiler can be quite tricky to learn,
  and may often be total overkill.

  With that said, unless you know there are lots of bottle necks you have to optimize once the bulk of your program is done,
  use the simplest tool for the job.
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

  <span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = cpuTime()

      <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
        code

      <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
      <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
      <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

  benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
    <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      list.add j

  benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
    <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

    <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
      list[index] = index

  benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-keyword">var</span> list = collect:
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
        i
<span class="hljs-comment">#This takes a bit, so for reasons of speed when working on this tutorial, this is the first run captured</span>
nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;
&lt;pre&gt;
CPU Time [add    ] x 10000 = 0.000142300000s
CPU Time [index  ] x 10000 = 0.000157300000s
CPU Time [collect] x 10000 = 0.000142400000s
&lt;/pre&gt;
&quot;&quot;&quot;</span>

nbUoSection <span class="hljs-string">&quot;Outro - Afterwords&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of written tutorial.
&quot;&quot;&quot;</span>
nbUoSection <span class="hljs-string">&quot;Thanks to my past and current Patrons&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Past Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Current Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- jaap groot (from October 2023)
- Dimitri Lesnoff (from October 2023)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Compiler Information&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option(mm:orc)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;My and General Links&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Links to this video's subject:&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [dump macro](https://nim-lang.org/docs/sugar.html#dump.m%2Cuntyped)
- [dumpToString macro](https://nim-lang.org/docs/sugar.html#dumpToString.m%2Cuntyped)
- [unittest module for advanced testing of your code](https://nim-lang.org/docs/unittest.html)
- [unittest 2 potential candidate to replace unittest](https://github.com/status-im/nim-unittest2)
- [Nim's embedded profiler](https://nim-lang.org/docs/nimprof.html)
- [Embedded Stack Trace Profiler (ESTP) User Guide](https://nim-lang.org/docs/estp.html)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Stack Tracing procs, etc -&gt; (system module)&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  - [StackTraceEntry object](https://nim-lang.org/docs/nimprof.html)
  - [getStackTrace proc](https://nim-lang.org/docs/system.html#getStackTrace)
  - [getStackTraceEntries](https://nim-lang.org/docs/system.html#getStackTraceEntries)
  - [nimGC_setStackBottom](https://nim-lang.org/docs/system.html#nimGC_setStackBottom%2Cpointer)
  - [stackTraceAvailable](https://nim-lang.org/docs/system.html#nimGC_setStackBottom%2Cpointer)
  - [writeStackTrace](https://nim-lang.org/docs/system.html#writeStackTrace)
&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>