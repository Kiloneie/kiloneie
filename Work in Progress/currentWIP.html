<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>FAQ Restructuring\FAQrestructure.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>FAQ Restructuring\FAQrestructure.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ul>
<li>1. <a href="#multiple-type-arguments-and-returns">Multiple Type Arguments and Returns</a>
<ul>
<li>1.1. <a href="#`type-or-|-type`-approach-problem"><code>type or | type</code> approach problem</a></li>
<li>1.2. <a href="#using-`static`-for-compile-time-multi-return">Using <code>static</code> for compile-time multi return</a></li>
</ul>
</li>
<li>2. <a href="#finding-and-sorting-data">Finding and Sorting data</a>
<ul>
<li>2.1. <a href="#finding-the-lowest-number-in-a-sequence">Finding the lowest number in a sequence</a></li>
<li>2.2. <a href="#finding-the-lowest-number-in-a-sequence-using-`min/maxindex`">Finding the lowest number in a sequence using <code>min/maxIndex</code></a></li>
<li>2.3. <a href="#sorting-a-sequence-of-integers">Sorting a sequence of integers</a></li>
<li>2.4. <a href="#sorting-a-sequence-of-integers-using-`sort`">Sorting a sequence of integers using <code>sort</code></a></li>
</ul>
</li>
<li>3. <a href="#generics">Generics</a>
<ul>
<li>3.1. <a href="#generic-definitions">Generic Definitions</a></li>
<li>3.2. <a href="#generic-object-initialization">Generic Object Initialization</a></li>
<li>3.3. <a href="#generic-tuple-initialization">Generic Tuple Initialization</a></li>
</ul>
</li>
<li>4. <a href="#more-overloading">More Overloading</a>
<ul>
<li>4.1. <a href="#using-`find`-with-a-sequence-of-numbers">Using <code>find</code> with a sequence of numbers</a></li>
<li>4.2. <a href="#using-`find`-with-a-sequence-of-objects">Using <code>find</code> with a sequence of objects</a></li>
<li>4.3. <a href="#overloading-`find`-proc">Overloading <code>find</code> proc</a></li>
<li>4.4. <a href="#`[]`-overload-for-ease-of-life"><code>[]</code> overload for ease of life</a></li>
</ul>
</li>
<li>5. <a href="#tuple-unpacking">Tuple Unpacking</a>
<ul>
<li>5.1. <a href="#tuple-unpacking-use-case">Tuple Unpacking Use Case</a></li>
</ul>
</li>
</ul>
      <meta name = "viewport" content = "width = device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -226px;
        left: 200px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      </style>
      <body>

      <button onclick = "topFunction()" id = "toTop" title = "Go to top">Top</button>
      <button onclick = "topFunction()" id = "toTopMobile" title = "Go to top">Top</button>

      <script>
        // Get the button
        let myButton = document.getElementById("toTop");
        let myButtonMobile = document.getElementById("toTopMobile");
        var currentButton = myButton

        var hasTouchScreen = false;

        // Detecting if the device is a mobile device
        if ("maxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints > 0;
          } 
        else if ("msMaxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints > 0;
          } 
        else 
          {
            var mQ = window.matchMedia && matchMedia("(pointer:coarse)");

            if (mQ && mQ.media === "(pointer:coarse)") 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        //Well it now works!!!, but, we need to move it more to the right
          //and it only follows correctly when we scroll down,
          //if we go back up, it stays down there

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() {scrollFunction()};

        function scrollFunction() {
          if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            currentButton.style.display = "block";
          } else {currentButton.style.display = "none";}
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      </script>
    
<h2>INTRO - GREETING</h2>
<ul>
<li>TITLE: Finding, Sorting data, Multiple Type Returns, Overloading, Generics and Tuple Unpacking</li>
<li>EXTRA CONTENT: Making a fake Table(hashSets, overloading and generics)</li>
</ul>
<h2>INTRO - FOREWORDS</h2>
<p><b>(What is the purpose of this video ?)</b></p>
<ul>
<li>In this video i will show you how to find and sort data using loops,
as well as with <code>find</code> and <code>sort</code> procs.
Also Generics, more Overloading with and without Generics and Tuple Unpacking.</li>
</ul>
<p>There is also a lot of cut content as an Extra,
which shows a lot more Generics and Overloading.</p>
<p>The code for this video and it's script/documentation styled with nimib,
as well as the cut content as an Extra, is in the links in the description as a form of written tutorial.</p>
<ul>
<li><a href="https://kiloneie.github.io/Extra%20Content/extraMakingFakeTable.html" title="Extra Content">Extra Content</a></li>
</ul>
<p><a name = "multiple-type-arguments-and-returns"></a></p>
<h1>1. Multiple Type Arguments and Returns</h1>
<hr />
<p>One can use the vertical bar/line <code>|</code> or better, the <code>or</code> operator,
to specify that a proc can take OR return, multiple types of data.</p>
<p><strong>Example of multiple types for an argument:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> stringOrInt(data: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">int</span>) =
  <span class="hljs-keyword">echo</span> data

<span class="hljs-keyword">proc</span> stringOrIntOr(data: <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>) =
  <span class="hljs-keyword">echo</span> data

<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello&quot;</span>
<span class="hljs-keyword">var</span> num = <span class="hljs-number">101</span>

str.stringOrInt
num.stringOrInt

str.stringOrIntOr
num.stringOrIntOr</code></pre><pre class="nb-output">Hello
101
Hello
101</pre>
<p><strong>Example of multiple types for return:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> multipleReturn(data: <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>): <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> = <span class="hljs-comment">#This is now a `generic`! Multi return = generic</span>
  <span class="hljs-literal">result</span> = data

<span class="hljs-keyword">echo</span> multipleReturn(<span class="hljs-number">101</span>)
<span class="hljs-keyword">echo</span> multipleReturn(<span class="hljs-string">&quot;Hello&quot;</span>)</code></pre><pre class="nb-output">101
Hello</pre>
<p><a name = "`type-or-|-type`-approach-problem"></a></p>
<h2>¬†¬†1.1. <code>type or | type</code> approach problem</h2>
<hr />
<p>If we were to change the body of the above proc,
to say <code>data + data</code>, we would get an error when the argument would be a <code>string</code>,
as you cannot join strings with the <code>+</code> operator(not unless you overload it,
but that is pointless, because <code>&amp;</code> exists for this exact purpose).</p>
<p>Variable types must be known at compile-time, therefore you cannot use the vertical bar/line <code>|</code>,
or the <code>or</code> operator, to have a variable of multiple types.</p>
<p><strong>The following does NOT compile:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> stringOrInt: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">int</span></code></pre>
<p>I have seen this approach be used here and there, and i do not agree with it,
because of the above problem. You can solve by using some logic to check for the type beforehand.
But then, the code would be doing extra work, wasting performance.</p>
<p><strong>SOLUTION 1:</strong> It would be much better to simply <code>overload</code> the same <code>proc</code>,
so that you have 2x procs or more, one for each of the types, to achieve the same functionality,
with none of the problems.</p>
<p><strong>SOLUTION 2:</strong> Generics</p>
<p><a name = "using-`static`-for-compile-time-multi-return"></a></p>
<h2>¬†¬†1.2. Using <code>static</code> for compile-time multi return</h2>
<hr />
<p>One can also solve the above problem of the code appearing to be fine,
but then failing at compilation, or worse, sometime at runtime,
by using <code>static</code> dataType for the argument.</p>
<p><code>static</code> enforces that the value will be known at compile-time,
therefore we do NOT need to check the types beforehand.</p>
<p><strong><code>static</code> type example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> test(x: <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span>): <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">string</span> = <span class="hljs-comment">#Multi return = generic</span>
  <span class="hljs-keyword">when</span> x:
    <span class="hljs-string">&quot;Hello&quot;</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-number">101</span>

<span class="hljs-keyword">echo</span> test <span class="hljs-literal">true</span>
<span class="hljs-keyword">echo</span> test <span class="hljs-literal">false</span></code></pre><pre class="nb-output">Hello
101</pre>
<p>The following <code>runtime</code> version does NOT compile:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> testR(x: <span class="hljs-built_in">bool</span>): <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">string</span> = <span class="hljs-comment">#Multi return = generic</span>
  <span class="hljs-keyword">when</span> x:
    <span class="hljs-string">&quot;Hello&quot;</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-number">101</span>

<span class="hljs-keyword">echo</span> testR <span class="hljs-literal">true</span>
<span class="hljs-keyword">echo</span> testR <span class="hljs-literal">false</span></code></pre>
  <h6>If you need this to work at `runtime`, you should use the `union` module by `alaviss`:
  - https://github.com/alaviss/union/
<p>But i can't tell if it still works as nimble cannot find it. I don't want to waste time.</h6></p>
<p><a name = "finding-and-sorting-data"></a></p>
<h1>2. Finding and Sorting data</h1>
<hr />
<p><a name = "finding-the-lowest-number-in-a-sequence"></a></p>
<h2>¬†¬†2.1. Finding the lowest number in a sequence</h2>
<hr />
<p>My version of how to find the lowest integer value in a sequence:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> listOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
listOfNumbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

<span class="hljs-keyword">var</span> smallestNumber: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span> <span class="hljs-comment">#So that it starts as the biggest</span>

<span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> listOfNumbers:
  <span class="hljs-keyword">if</span> number &lt; smallestNumber:
    smallestNumber = number

<span class="hljs-keyword">echo</span> smallestNumber</code></pre><pre class="nb-output">-100</pre>
<p><a name = "finding-the-lowest-number-in-a-sequence-using-`min/maxindex`"></a></p>
<h2>¬†¬†2.2. Finding the lowest number in a sequence using <code>min/maxIndex</code></h2>
<hr />
<p><code>sequtils</code>(sequence utilities) module's <code>min/maxIndex</code> proc:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/sequtils

<span class="hljs-keyword">var</span> numbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
numbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

<span class="hljs-keyword">echo</span> numbers[numbers.minIndex]
<span class="hljs-keyword">echo</span> numbers[numbers.maxIndex]</code></pre><pre class="nb-output">-100
100</pre>
<p>As you can see it's much simpler, but it is always valuable to learn how to do it yourself,
especially if you plan to make a similar proc.</p>
<p><a name = "sorting-a-sequence-of-integers"></a></p>
<h2>¬†¬†2.3. Sorting a sequence of integers</h2>
<hr />
<p>My example of sorting a sequence of integers by their value descending(10, 9, 8...):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/sets, std/sequtils

<span class="hljs-keyword">var</span> listOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
listOfNumbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Original listOfNumbers:&quot;</span>
<span class="hljs-keyword">echo</span> listOfNumbers; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

<span class="hljs-keyword">var</span> checkedNumbers: <span class="hljs-type">HashSet</span>[<span class="hljs-built_in">int</span>] <span class="hljs-comment">#Max normal Set int size is int16</span>
<span class="hljs-keyword">var</span> countedNumbers: <span class="hljs-built_in">seq</span>[(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>])] <span class="hljs-comment">#a Seq of (locations of number) - number of elements of locations = numb of of occurances</span>

<span class="hljs-comment">#Finding all occurances of a number and their locations</span>
<span class="hljs-keyword">for</span> index, number <span class="hljs-keyword">in</span> listOfNumbers.pairs:
  <span class="hljs-keyword">var</span> tempSeq: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  <span class="hljs-keyword">var</span> tempNum: <span class="hljs-built_in">int</span>
  <span class="hljs-keyword">if</span> number <span class="hljs-keyword">notin</span> checkedNumbers:
    <span class="hljs-keyword">for</span> index2, number2 <span class="hljs-keyword">in</span> listOfNumbers.pairs: <span class="hljs-comment">#Double same loop, so that each number can check all the other numbers    </span>
      <span class="hljs-keyword">if</span> index != index2: <span class="hljs-comment">#Don't check the same position against the same position</span>
        <span class="hljs-comment">#Don't check an already checked number</span>
          <span class="hljs-keyword">if</span> number == number2:
            tempNum = number  
            checkedNumbers.incl number     
            tempSeq.add index <span class="hljs-comment">#First location</span>
            tempSeq.add index2 <span class="hljs-comment">#Second location</span>
    <span class="hljs-comment">#For single occurance numbers</span>
    tempNum = number
    tempSeq.add index

    <span class="hljs-comment">#Multi occurance numbers</span>
    tempSeq = tempSeq.deduplicate
    countedNumbers.add (tempNum, tempSeq)
  
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;countedNumbers:&quot;</span>
<span class="hljs-keyword">echo</span> countedNumbers; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

<span class="hljs-keyword">var</span> sortedListOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
<span class="hljs-keyword">var</span> smallestNumber: (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]) = (<span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>, @[])
<span class="hljs-keyword">var</span> sNlocation: <span class="hljs-built_in">int</span>
<span class="hljs-keyword">while</span> countedNumbers.len &gt; <span class="hljs-number">0</span>:
  smallestNumber = (<span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>, @[]) <span class="hljs-comment">#Reset - so that smallestNumber is always larger then the one in the list</span>
  <span class="hljs-comment">#Here we will remove once we break out with the smallestNumber</span>
  <span class="hljs-keyword">for</span> index, tup <span class="hljs-keyword">in</span> countedNumbers.pairs:
    <span class="hljs-keyword">if</span> tup[<span class="hljs-number">0</span>] &lt; smallestNumber[<span class="hljs-number">0</span>]: <span class="hljs-comment">#tup[0] -&gt; number</span>
      smallestNumber = tup
      sNlocation = index
  countedNumbers.delete sNlocation
  <span class="hljs-comment">#Now we add number * locations to tempListOfNumbers</span>
  <span class="hljs-keyword">for</span> location <span class="hljs-keyword">in</span> smallestNumber[<span class="hljs-number">1</span>]:
    sortedListOfNumbers.add smallestNumber[<span class="hljs-number">0</span>]

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers&quot;</span>
<span class="hljs-keyword">echo</span> sortedListOfNumbers</code></pre><pre class="nb-output">Original listOfNumbers:
@[1, 2, 50, 20, 100, 0, -5, 68, -100, 0, 100, 0]

countedNumbers:
@[(1, @[0]), (2, @[1]), (50, @[2]), (20, @[3]), (100, @[4, 10]), (0, @[5, 9, 11]), (-5, @[6]), (68, @[7]), (-100, @[8])]

sortedListOfNumbers
@[-100, -5, 0, 0, 0, 1, 2, 20, 50, 68, 100, 100]</pre>
<p>As you can see, for just sorting numbers in a sequence, it takes a lot of code to do so.</p>
<p><a name = "sorting-a-sequence-of-integers-using-`sort`"></a></p>
<h2>¬†¬†2.4. Sorting a sequence of integers using <code>sort</code></h2>
<hr />
<p><strong><code>sort</code> is Nim's default sorting algorithm - func(there is also a <code>proc</code> verison)</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/algorithm

<span class="hljs-keyword">var</span> listOfNumbers2: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
listOfNumbers2 = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Original listOfNumbers2:&quot;</span>
<span class="hljs-keyword">echo</span> listOfNumbers2; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

<span class="hljs-keyword">var</span> sortedListOfNumbers2 = listOfNumbers2
sortedListOfNumbers2.sort() <span class="hljs-comment">#Default is lowest to highest - Ascending</span>

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers2&quot;</span>
<span class="hljs-keyword">echo</span> sortedListOfNumbers2</code></pre><pre class="nb-output">Original listOfNumbers2:
@[1, 2, 50, 20, 100, 0, -5, 68, -100, 0, 100, 0]

sortedListOfNumbers2
@[-100, -5, 0, 0, 0, 1, 2, 20, 50, 68, 100, 100]</pre>
<p>As you can see, it saves you a LOT of time(it took me quite a bit to write my own above).</p>
<p><strong>Descending <code>sort</code> example:</strong></p>
<pre><code class="nohighlight hljs nim">sortedListOfNumbers2.sort(order = <span class="hljs-type">SortOrder</span>.<span class="hljs-type">Descending</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers2 in Descending order:&quot;</span>
<span class="hljs-keyword">echo</span> sortedListOfNumbers2</code></pre><pre class="nb-output">sortedListOfNumbers2 in Descending order:
@[100, 100, 68, 50, 20, 2, 1, 0, 0, 0, -5, -100]</pre>
<p><code>sort</code> proc modifies the existing variable, and uses the <code>system.cmp</code> for comparisons by default.
There is also the <code>sorted</code> proc, which returns a new copy instead of modifying the existing container.</p>
<p><strong><code>sorted</code> proc example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> listOfNumbers2.sorted() <span class="hljs-comment">#You can't use `sort` with an echo like this</span></code></pre><pre class="nb-output">@[-100, -5, 0, 0, 0, 1, 2, 20, 50, 68, 100, 100]</pre>
<p>You can also specify which comparison/<code>cmp</code> proc to use, like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> listOfNumbers2.sorted(system.cmp[<span class="hljs-built_in">int</span>])</code></pre>
<p>You can replace that <code>cmp</code>(compare) proc, with one of the following from the Nim's Standard Library's docs search results:</p>
<img src = "images/cmpSearchResults.png" alt = "`cmp` search results">
<p><a name = "generics"></a></p>
<h1>3. Generics</h1>
<hr />
<p>Generics in Nim, are used to parametrize procs, iterators or types with type parameters.
`[]`<code>are used along with capital letters inside of them, separated by commas, after a type's name, proc or iterator to tell the compiler that this will be a</code>generic`:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
    ndata: <span class="hljs-built_in">string</span>

<span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>]() =
  <span class="hljs-keyword">discard</span>

<span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>]() =
  <span class="hljs-keyword">discard</span></code></pre>
<p>The above examples are incomplete, they will not work just yet.
Again, using `[]` with a capital letter inside will just &quot;mark&quot; the <code>type, proc, iterator</code> as a generic.
Now we require to use that <code>T</code>(can be any capital letter) in the arguments of the <code>proc</code>, <code>iterator</code>,
and on the fields of a <code>type</code> like so:</p>
<p><a name = "generic-definitions"></a></p>
<h2>¬†¬†3.1. Generic Definitions</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
    data: <span class="hljs-type">T</span>

<span class="hljs-keyword">type</span>
  <span class="hljs-type">GenericTuple</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">tuple</span>
    name: <span class="hljs-type">A</span>
    age: <span class="hljs-type">B</span>

<span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>) =
  <span class="hljs-keyword">discard</span>

<span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">discard</span></code></pre>
<p><strong>And also for generic containers proc definition example</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> genericContainerProc[<span class="hljs-type">T</span>](anyTypeContainer: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]) =
  <span class="hljs-keyword">discard</span></code></pre>
<p>Now let's see how to use this <code>generic object</code></p>
<p><a name = "generic-object-initialization"></a></p>
<h2>¬†¬†3.2. Generic Object Initialization</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> genericObject = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">string</span>](data: <span class="hljs-string">&quot;A String&quot;</span>)
<span class="hljs-keyword">var</span> genericObject2 = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">int</span>](data: <span class="hljs-number">101</span>)

<span class="hljs-keyword">echo</span> genericObject, <span class="hljs-string">&quot; of type &quot;</span>, genericObject.typeof
<span class="hljs-keyword">echo</span> genericObject2, <span class="hljs-string">&quot; of type &quot;</span>, genericObject2.typeof</code></pre><pre class="nb-output">(data: &quot;A String&quot;) of type GenericObject[system.string]
(data: 101) of type GenericObject[system.int]</pre>
<p><a name = "generic-tuple-initialization"></a></p>
<h2>¬†¬†3.3. Generic Tuple Initialization</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> genericTuple: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>)
<span class="hljs-keyword">var</span> genericTuple2: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">seq</span>[<span class="hljs-built_in">float</span>], <span class="hljs-built_in">bool</span>] = (@[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">3.25</span>], <span class="hljs-literal">true</span>)

<span class="hljs-keyword">echo</span> genericTuple, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple.typeof
<span class="hljs-keyword">echo</span> genericTuple2, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple2.typeof</code></pre><pre class="nb-output">(name: &quot;Bob&quot;, age: 20) of type GenericTuple[system.string, system.int]
(name: @[0.5, 1.1, 3.25], age: true) of type GenericTuple[seq[float], system.bool]</pre>
<p>Calling generic procs and iterators is exactly the same as non generic versions,
unlike structures like <code>objects</code> and <code>tuples</code>(shown above).</p>
<p><a name = "more-overloading"></a></p>
<h1>4. More Overloading</h1>
<hr />
<p><strong>NOTE:</strong> <code>hashSets, more on hash Tables and Hashing</code> had the start of <code>more</code> overloading,
since the Nim for Beginners #22 Procedure Overloading(4 min long).</p>
<p>To demonstrate and teach you more about overloading, we are going to overload the <code>find</code> proc.</p>
<p>The <code>find</code> proc from the <code>strutils</code> module(string utilities)(also in some other modules),
is very useful for finding substrings(a part of a string) in a string.</p>
<p>In fact, we have already used it in both the Sets and the hashSets videos,
in order to <code>find</code> and remove specified separators from a string.</p>
<p>This time though, we are going to use the <code>system.find</code> version,
which does not deal with <code>strings</code> but with an element of some type.</p>
<p><a name = "using-`find`-with-a-sequence-of-numbers"></a></p>
<h2>¬†¬†4.1. Using <code>find</code> with a sequence of numbers</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> mySequence = @[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">50</span>]

<span class="hljs-keyword">echo</span> mySequence.find(-<span class="hljs-number">10</span>)</code></pre><pre class="nb-output">3</pre>
<p>Like with all <code>find</code> proc versions, you give it what you want it to find, and it returns the <code>index</code> of where it is.</p>
<p><strong>If you were to reinsert the index back, you would get -10 in this case:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> location = mySequence.find(-<span class="hljs-number">10</span>)
<span class="hljs-keyword">echo</span> mySequence[location]</code></pre><pre class="nb-output">-10</pre>
<p><a name = "using-`find`-with-a-sequence-of-objects"></a></p>
<h2>¬†¬†4.2. Using <code>find</code> with a sequence of objects</h2>
<hr />
<p><strong>Now let's find an object based on one of it's fields in a sequence:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">SomeObject</span> = <span class="hljs-keyword">object</span>
    name: <span class="hljs-built_in">string</span>
    age: <span class="hljs-built_in">int</span>

<span class="hljs-keyword">var</span> seqOfSomeObject: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>]
seqOfSomeObject.add <span class="hljs-type">SomeObject</span>(name: <span class="hljs-string">&quot;Wombat&quot;</span>, age: <span class="hljs-number">3</span>)
seqOfSomeObject.add <span class="hljs-type">SomeObject</span>(name: <span class="hljs-string">&quot;Womp rat&quot;</span>, age: <span class="hljs-number">5</span>)</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> wompRat = seqOfSomeObject.find(<span class="hljs-string">&quot;Womp rat&quot;</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;index of Womp rat: &quot;</span>, wompRat, <span class="hljs-string">&quot; reinsertion: &quot;</span>, seqOfSomeObject[wompRat]</code></pre>
<img src = "images/findProcError.png" alt = "`find` proc error">
<p><a name = "overloading-`find`-proc"></a></p>
<h2>¬†¬†4.3. Overloading <code>find</code> proc</h2>
<hr />
<p>As you can see, <code>find</code> proc does not have a version/overload for our <code>SomeObject</code>,
and therefore does not compile.</p>
<p><strong>So in order to make it work, we need to overload the <code>find</code> proc for our custom object:</strong>
First off, here is how the <code>system.find</code> proc is defined(a generic):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> find*[<span class="hljs-type">T</span>, <span class="hljs-type">S</span>](a: <span class="hljs-type">T</span>, item: <span class="hljs-type">S</span>): <span class="hljs-built_in">int</span> {.inline.}=
  <span class="hljs-comment">## Returns the first index of `item` in `a` or -1 if not found. This requires</span>
  <span class="hljs-comment">## appropriate `items` and `==` operations to work.</span>
  <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items(a):
    <span class="hljs-keyword">if</span> i == item: <span class="hljs-keyword">return</span>
    inc(<span class="hljs-literal">result</span>)
  <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span></code></pre>
<p>Our overload, in order to <code>find</code> by the fields of our <code>SomeObject</code>:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">#Can also be: proc find[T, S](a: T, item: S): int {.inline.} = #Specify for a single type, better</span>
<span class="hljs-keyword">proc</span> find[<span class="hljs-type">S</span>](a: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>], item: <span class="hljs-type">S</span>): <span class="hljs-built_in">int</span> {.inline.} =
  <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> a.pairs:
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> element.fields: <span class="hljs-comment">#Second unwrap to get the fields of `name: string` and `age: int`</span>
      <span class="hljs-keyword">if</span> f.typeof <span class="hljs-keyword">is</span> item.typeof:
        <span class="hljs-keyword">if</span> $f == $item: <span class="hljs-keyword">return</span> index <span class="hljs-comment">#To string($) -&gt; f(int) == item(string) -&gt; ERROR</span>
      <span class="hljs-comment">#inc(result) #No longer needed as we are using the `pairs` iterator</span>
  <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span></code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> wompRat = seqOfSomeObject.find(<span class="hljs-string">&quot;Womp rat&quot;</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Found name Womp rat at index: &quot;</span>, wompRat
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[wompRat]</code></pre><pre class="nb-output">Found name Womp rat at index: 1
Reinsertion result: (name: &quot;Womp rat&quot;, age: 5)</pre>
<p>And now for the <code>age</code> field:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> ageOfWompRat = seqOfSomeObject.find(<span class="hljs-number">5</span>)

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Found age 5 at index: &quot;</span>, ageOfWompRat
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[ageOfWompRat]</code></pre><pre class="nb-output">Found age 5 at index: 1
Reinsertion result: (name: &quot;Womp rat&quot;, age: 5)</pre>
<p><a name = "`[]`-overload-for-ease-of-life"></a></p>
<h2>¬†¬†4.4. <code>[]</code> overload for ease of life</h2>
<hr />
<p>`[]` overload will allow us to replace:
<code>seqOfSomeObject.find(&quot;Womp rat&quot;)</code> to <code>seqOfSomeObject[&quot;Womp rat&quot;]</code> to get the index.</p>
<p>The overload is mostly the same as the <code>find</code> overload.
<strong>Except that the <code>item</code> argument is now a <code>string</code> instead of a generic.</strong></p>
<p>This is because, if the overloaded `[]` was given an <code>integer</code>,
it would still try to return us the element at the index of that <code>integer</code>.
And in this instance <code>5</code> is not in the index of the 2 fields(0, 1),
resulting in an error.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/strutils</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `[]`(a: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>], item: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">int</span> {.inline.} =
  <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> a.pairs:
    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> element.fields: <span class="hljs-comment">#Second unwrap to get the fields of `name: string` and `age: int`</span>
      <span class="hljs-keyword">if</span> parseInt($f) <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>:  <span class="hljs-comment">#`Line 1` Try to parse - to see if we get an `int`</span>
        <span class="hljs-keyword">if</span> $f == $item: <span class="hljs-keyword">return</span> index <span class="hljs-comment">#To string($) -&gt; f(int) == item(string) -&gt; ERROR</span>
      <span class="hljs-keyword">elif</span> $f == $item: <span class="hljs-keyword">return</span> index 
      <span class="hljs-comment">#inc(result) #No longer needed as we are using the `pairs` iterator</span>
  <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span></code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> name = seqOfSomeObject[<span class="hljs-string">&quot;Womp rat&quot;</span>]
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;name's index: &quot;</span>, name
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[name]</code></pre><pre class="nb-output">name's index: 1
Reinsertion result: (name: &quot;Womp rat&quot;, age: 5)</pre>
<p>The following will NOT compile, and crash if the <code>item</code> argument is a generic.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> age = seqOfSomeObject[<span class="hljs-number">5</span>] <span class="hljs-comment">#Index out of bounds - no crash yet</span>
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;age's index: &quot;</span>, age
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[age] <span class="hljs-comment">#Crash here</span></code></pre>
<p>What we can do is make that number <code>5</code> into a string <code>$5</code>.
And with that change the <code>[]</code>'s overload's marked <code>Line #1</code> checking of <code>if f.typeof is item.typeof:</code>,
to <code>if parseInt($f) is int:</code>, in order to see if the parsed string is an actual integer,
and then the same process as before continues.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> age = seqOfSomeObject[$<span class="hljs-number">5</span>]
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;age's index: &quot;</span>, age
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[age]</code></pre><pre class="nb-output">age's index: 1
Reinsertion result: (name: &quot;Womp rat&quot;, age: 5)</pre>
<p><a name = "tuple-unpacking"></a></p>
<h1>5. Tuple Unpacking</h1>
<hr />
<p>In the past video of <code>Nim for Beginners #14 Tuples</code>, i have shown you Tuples.
(There is a lot of dealing with <code>tuples</code> in the Extra cut content)</p>
<p>Now it's time to explain and demonstrate <code>tuple unpacking</code>. Tuple unpacking is quite simple.</p>
<p>You can use them to give values(assignment) to multiple variables(<code>var</code>), constants(<code>const</code>) or immutable variable(<code>let</code>),
at once.</p>
<p><strong>Example 1:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> (v1, c1, l1) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

<span class="hljs-keyword">echo</span> v1
<span class="hljs-keyword">echo</span> c1
<span class="hljs-keyword">echo</span> l1</code></pre><pre class="nb-output">var
const
let</pre>
<p><strong>You may also ommit assignment of any of them:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> (v2, _, l2) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

<span class="hljs-keyword">let</span> (_, _, _) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)</code></pre>
<p><strong>All of this is treated as syntatic sugar for basically the following code(Example 1):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span>
  temporaryTuple = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
  v3 = temporaryTuple[<span class="hljs-number">0</span>]
  c3 = temporaryTuple[<span class="hljs-number">1</span>]
  l3 = temporaryTuple[<span class="hljs-number">2</span>]</code></pre>
<p>I don't think i have ever shown this before, but yes, you can access any field of a <code>tuple</code>,
without knowing the name of the field, especially useful for <code>anonymous</code> tuples like here(fields without names).
I do recommend though, that you do use the <code>names</code> of the fields over the <code>index</code> when the <code>names</code> are present.</p>
<p>When tuple unpacking with tuples with numbers(literals) into <code>var</code> and <code>let</code> variables,
they get assigned their values without a <code>temporaryTuple</code>.</p>
<p>Since you can nest any container withing another container(array, seq, set, table, etc),
as well as data structure in a data structure(object, tuple),
you can also use nested tuples for tuple unpacking.</p>
<p><a name = "tuple-unpacking-use-case"></a></p>
<h2>¬†¬†5.1. Tuple Unpacking Use Case</h2>
<hr />
<p>In Nim you can have multiple return types for a <code>proc</code>,
by using <code>object variants</code> and <code>union types</code>(int|string).</p>
<p>This can also be achieved by using <code>tuples</code>. But <code>tuples</code>,
don't just allow for multiple types to be returned,
they allow for multiple returns, which can then be easily <code>unpacked</code>,
into variables and containers.</p>
<p><strong>Here is an example of a multiple return:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> returnsNestedTuple(): (<span class="hljs-built_in">int</span>, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>), <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) = (<span class="hljs-number">4</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-keyword">let</span> (x, (_, y), _, z) = returnsNestedTuple()

<span class="hljs-keyword">echo</span> x, <span class="hljs-string">&quot; &quot;</span>, y, <span class="hljs-string">&quot; &quot;</span>, z</code></pre><pre class="nb-output">4 7 3</pre>
<p>Another very useful part of <code>tuple unpacking</code> is that, you don't need to return anything.
1, 2, all or none.</p>
<h2>OUTRO - AFTERWORDS</h2>
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also follow me on twitter of the same name, and support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of offline tutorial.</p>
<p>Also, don't forget checking out the Extra cut content!</p>
<h3>Thanks to my past and current Patrons</h3>
<p><b>Past Patrons:</b></p>
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<p><b>Current Patrons</b></p>
<ul>
<li>jaap groot (from October 2023)</li>
<li>Dimitri Lesnoff (from October 2023)</li>
</ul>
<p><b>Compiler information</b></p>
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option</li>
<li>Timestamps:
<ul>
<li>00:15 Start of video example</li>
</ul>
</li>
</ul>
<p><b>LINKS:</b></p>
<ul>
<li><a href="https://kiloneie.github.io/Extra%20Content/extraMakingFakeTable.html" title="Extra Content">Extra Content</a></li>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<p><b>LINKS to this video's subject:</b></p>
<ul>
<li><a href="https://nim-lang.org/docs/sequtils.html#minIndex%2CopenArray%5BT%5D" title="min/maxIndex procs">min/maxIndex procs</a></li>
<li><a href="https://nim-lang.org/docs/algorithm.html#sort%2CopenArray%5BT%5D%2Cproc%28T%2CT%29" title="for `sort` func and `sorted` proc">for <code>sort</code> func and <code>sorted</code> proc</a></li>
<li><a href="https://nim-lang.org/docs/strutils.html#parseInt%2Cstring" title="parseInt">parseInt</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>

<span class="hljs-comment">#https://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals raw strings r&quot;&quot;</span>

<span class="hljs-keyword">import</span> nimib, std/strutils <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">var</span> index = (section: <span class="hljs-number">0</span>, subsection: <span class="hljs-number">0</span>)

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  index.section.inc
  index.subsection = <span class="hljs-number">0</span> <span class="hljs-comment">#Reset on a new nbSection</span>

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;. &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;- &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> <span class="hljs-comment">#&amp;#92; is HTML code for &quot;\&quot;, you can also &quot;\\&quot; or r&quot;\&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbSubSection(name:<span class="hljs-built_in">string</span>) =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -226px;
        left: 200px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTop&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;
      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTopMobile&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
        // Get the button
        let myButton = document.getElementById(&quot;toTop&quot;);
        let myButtonMobile = document.getElementById(&quot;toTopMobile&quot;);
        var currentButton = myButton

        var hasTouchScreen = false;

        // Detecting if the device is a mobile device
        if (&quot;maxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints &gt; 0;
          } 
        else if (&quot;msMaxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints &gt; 0;
          } 
        else 
          {
            var mQ = window.matchMedia &amp;&amp; matchMedia(&quot;(pointer:coarse)&quot;);

            if (mQ &amp;&amp; mQ.media === &quot;(pointer:coarse)&quot;) 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        //Well it now works!!!, but, we need to move it more to the right
          //and it only follows correctly when we scroll down,
          //if we go back up, it stays down there

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() {scrollFunction()};

        function scrollFunction() {
          if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
            currentButton.style.display = &quot;block&quot;;
          } else {currentButton.style.display = &quot;none&quot;;}
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#Checking if mobile user</span>
<span class="hljs-comment">#[ nbRawHtml: &quot;&quot;&quot;
&lt;script&gt;
  if (typeof screen.orientation !== 'undefined') {
      let d = new Date();
      document.body.innerHTML = &quot;&lt;h1&gt;Today's date is &quot; + d + &quot;&lt;/h1&gt;&quot;
  }
&lt;/script&gt;
&quot;&quot;&quot; ]#</span>

<span class="hljs-comment">#If yes, we will put the button and the bottom right most point of the content area and transparent,</span>
  <span class="hljs-comment">#until hovered and clicked</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Do NOT forget to have the .html file OPEN at all times, otherwise </span>
  <span class="hljs-comment">#live preview will NOT work! ANY live preview!</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd or hlMdf enables nimiboost's markdown highlight mode</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;
## INTRO - GREETING
- TITLE: Finding, Sorting data, Multiple Type Returns, Overloading, Generics and Tuple Unpacking
- EXTRA CONTENT: Making a fake Table(hashSets, overloading and generics)

## INTRO - FOREWORDS
&lt;b&gt;(What is the purpose of this video ?)&lt;/b&gt;
- In this video i will show you how to find and sort data using loops, 
  as well as with `find` and `sort` procs.
  Also Generics, more Overloading with and without Generics and Tuple Unpacking.

There is also a lot of cut content as an Extra,
which shows a lot more Generics and Overloading.
   
The code for this video and it's script/documentation styled with nimib,
as well as the cut content as an Extra, is in the links in the description as a form of written tutorial.

- [Extra Content](https://kiloneie.github.io/Extra%20Content/extraMakingFakeTable.html &quot;Extra Content&quot;)
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Multiple Type Arguments and Returns&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  One can use the vertical bar/line `|` or better, the `or` operator, 
  to specify that a proc can take OR return, multiple types of data.

  **Example of multiple types for an argument:**
&quot;&quot;&quot;</span>
nbCodeInBlock:
  <span class="hljs-keyword">proc</span> stringOrInt(data: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">int</span>) =
    <span class="hljs-keyword">echo</span> data

  <span class="hljs-keyword">proc</span> stringOrIntOr(data: <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>) =
    <span class="hljs-keyword">echo</span> data

  <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello&quot;</span>
  <span class="hljs-keyword">var</span> num = <span class="hljs-number">101</span>

  str.stringOrInt
  num.stringOrInt

  str.stringOrIntOr
  num.stringOrIntOr
  
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Example of multiple types for return:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> multipleReturn(data: <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span>): <span class="hljs-built_in">string</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span> = <span class="hljs-comment">#This is now a `generic`! Multi return = generic</span>
    <span class="hljs-literal">result</span> = data

  <span class="hljs-keyword">echo</span> multipleReturn(<span class="hljs-number">101</span>)
  <span class="hljs-keyword">echo</span> multipleReturn(<span class="hljs-string">&quot;Hello&quot;</span>)

nbSubSection <span class="hljs-string">&quot;`type or | type` approach problem&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  If we were to change the body of the above proc,
  to say `data + data`, we would get an error when the argument would be a `string`,
  as you cannot join strings with the `+` operator(not unless you overload it, 
  but that is pointless, because `&amp;` exists for this exact purpose).

  Variable types must be known at compile-time, therefore you cannot use the vertical bar/line `|`,
  or the `or` operator, to have a variable of multiple types.

  **The following does NOT compile:**
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">var</span> stringOrInt: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">int</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  I have seen this approach be used here and there, and i do not agree with it,
  because of the above problem. You can solve by using some logic to check for the type beforehand.
  But then, the code would be doing extra work, wasting performance.

  **SOLUTION 1:** It would be much better to simply `overload` the same `proc`,
  so that you have 2x procs or more, one for each of the types, to achieve the same functionality,
  with none of the problems.

  **SOLUTION 2:** Generics
&quot;&quot;&quot;</span>

nbSubSection: <span class="hljs-string">&quot;Using `static` for compile-time multi return&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  One can also solve the above problem of the code appearing to be fine,
  but then failing at compilation, or worse, sometime at runtime,
  by using `static` dataType for the argument.

  `static` enforces that the value will be known at compile-time,
  therefore we do NOT need to check the types beforehand.

  **`static` type example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> test(x: <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span>): <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">string</span> = <span class="hljs-comment">#Multi return = generic</span>
    <span class="hljs-keyword">when</span> x:
      <span class="hljs-string">&quot;Hello&quot;</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-number">101</span>

  <span class="hljs-keyword">echo</span> test <span class="hljs-literal">true</span>
  <span class="hljs-keyword">echo</span> test <span class="hljs-literal">false</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The following `runtime` version does NOT compile:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">proc</span> testR(x: <span class="hljs-built_in">bool</span>): <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">string</span> = <span class="hljs-comment">#Multi return = generic</span>
    <span class="hljs-keyword">when</span> x:
      <span class="hljs-string">&quot;Hello&quot;</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-number">101</span>

  <span class="hljs-keyword">echo</span> testR <span class="hljs-literal">true</span>
  <span class="hljs-keyword">echo</span> testR <span class="hljs-literal">false</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  &lt;h6&gt;If you need this to work at `runtime`, you should use the `union` module by `alaviss`:
  - https://github.com/alaviss/union/

  But i can't tell if it still works as nimble cannot find it. I don't want to waste time.&lt;/h6&gt;
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Finding and Sorting data&quot;</span>
nbSubSection <span class="hljs-string">&quot;Finding the lowest number in a sequence&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  My version of how to find the lowest integer value in a sequence:
&quot;&quot;&quot;</span>
nbCodeInBlock:
  <span class="hljs-keyword">var</span> listOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  listOfNumbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

  <span class="hljs-keyword">var</span> smallestNumber: <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span> <span class="hljs-comment">#So that it starts as the biggest</span>

  <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> listOfNumbers:
    <span class="hljs-keyword">if</span> number &lt; smallestNumber:
      smallestNumber = number

  <span class="hljs-keyword">echo</span> smallestNumber

nbSubSection <span class="hljs-string">&quot;Finding the lowest number in a sequence using `min/maxIndex`&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `sequtils`(sequence utilities) module's `min/maxIndex` proc:
&quot;&quot;&quot;</span>  
nbCode:
  <span class="hljs-keyword">import</span> std/sequtils

  <span class="hljs-keyword">var</span> numbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  numbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

  <span class="hljs-keyword">echo</span> numbers[numbers.minIndex]
  <span class="hljs-keyword">echo</span> numbers[numbers.maxIndex]
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see it's much simpler, but it is always valuable to learn how to do it yourself,
  especially if you plan to make a similar proc.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Sorting a sequence of integers&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  My example of sorting a sequence of integers by their value descending(10, 9, 8...): 
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/sets, std/sequtils

  <span class="hljs-keyword">var</span> listOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  listOfNumbers = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Original listOfNumbers:&quot;</span>
  <span class="hljs-keyword">echo</span> listOfNumbers; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

  <span class="hljs-keyword">var</span> checkedNumbers: <span class="hljs-type">HashSet</span>[<span class="hljs-built_in">int</span>] <span class="hljs-comment">#Max normal Set int size is int16</span>
  <span class="hljs-keyword">var</span> countedNumbers: <span class="hljs-built_in">seq</span>[(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>])] <span class="hljs-comment">#a Seq of (locations of number) - number of elements of locations = numb of of occurances</span>

  <span class="hljs-comment">#Finding all occurances of a number and their locations</span>
  <span class="hljs-keyword">for</span> index, number <span class="hljs-keyword">in</span> listOfNumbers.pairs:
    <span class="hljs-keyword">var</span> tempSeq: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
    <span class="hljs-keyword">var</span> tempNum: <span class="hljs-built_in">int</span>
    <span class="hljs-keyword">if</span> number <span class="hljs-keyword">notin</span> checkedNumbers:
      <span class="hljs-keyword">for</span> index2, number2 <span class="hljs-keyword">in</span> listOfNumbers.pairs: <span class="hljs-comment">#Double same loop, so that each number can check all the other numbers    </span>
        <span class="hljs-keyword">if</span> index != index2: <span class="hljs-comment">#Don't check the same position against the same position</span>
          <span class="hljs-comment">#Don't check an already checked number</span>
            <span class="hljs-keyword">if</span> number == number2:
              tempNum = number  
              checkedNumbers.incl number     
              tempSeq.add index <span class="hljs-comment">#First location</span>
              tempSeq.add index2 <span class="hljs-comment">#Second location</span>
      <span class="hljs-comment">#For single occurance numbers</span>
      tempNum = number
      tempSeq.add index

      <span class="hljs-comment">#Multi occurance numbers</span>
      tempSeq = tempSeq.deduplicate
      countedNumbers.add (tempNum, tempSeq)
    
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;countedNumbers:&quot;</span>
  <span class="hljs-keyword">echo</span> countedNumbers; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

  <span class="hljs-keyword">var</span> sortedListOfNumbers: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  <span class="hljs-keyword">var</span> smallestNumber: (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]) = (<span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>, @[])
  <span class="hljs-keyword">var</span> sNlocation: <span class="hljs-built_in">int</span>
  <span class="hljs-keyword">while</span> countedNumbers.len &gt; <span class="hljs-number">0</span>:
    smallestNumber = (<span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>, @[]) <span class="hljs-comment">#Reset - so that smallestNumber is always larger then the one in the list</span>
    <span class="hljs-comment">#Here we will remove once we break out with the smallestNumber</span>
    <span class="hljs-keyword">for</span> index, tup <span class="hljs-keyword">in</span> countedNumbers.pairs:
      <span class="hljs-keyword">if</span> tup[<span class="hljs-number">0</span>] &lt; smallestNumber[<span class="hljs-number">0</span>]: <span class="hljs-comment">#tup[0] -&gt; number</span>
        smallestNumber = tup
        sNlocation = index
    countedNumbers.delete sNlocation
    <span class="hljs-comment">#Now we add number * locations to tempListOfNumbers</span>
    <span class="hljs-keyword">for</span> location <span class="hljs-keyword">in</span> smallestNumber[<span class="hljs-number">1</span>]:
      sortedListOfNumbers.add smallestNumber[<span class="hljs-number">0</span>]

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers&quot;</span>
  <span class="hljs-keyword">echo</span> sortedListOfNumbers

nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, for just sorting numbers in a sequence, it takes a lot of code to do so.
&quot;&quot;&quot;</span>
nbSubSection <span class="hljs-string">&quot;Sorting a sequence of integers using `sort`&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **`sort` is Nim's default sorting algorithm - func(there is also a `proc` verison)**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/algorithm

  <span class="hljs-keyword">var</span> listOfNumbers2: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">int</span>]
  listOfNumbers2 = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">68</span>, -<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>]

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Original listOfNumbers2:&quot;</span>
  <span class="hljs-keyword">echo</span> listOfNumbers2; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&quot;</span>

  <span class="hljs-keyword">var</span> sortedListOfNumbers2 = listOfNumbers2
  sortedListOfNumbers2.sort() <span class="hljs-comment">#Default is lowest to highest - Ascending</span>

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers2&quot;</span>
  <span class="hljs-keyword">echo</span> sortedListOfNumbers2
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, it saves you a LOT of time(it took me quite a bit to write my own above).

  **Descending `sort` example:**
&quot;&quot;&quot;</span>
nbCode:
  sortedListOfNumbers2.sort(order = <span class="hljs-type">SortOrder</span>.<span class="hljs-type">Descending</span>)
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;sortedListOfNumbers2 in Descending order:&quot;</span>
  <span class="hljs-keyword">echo</span> sortedListOfNumbers2

nbText: <span class="hljs-string">&quot;&quot;&quot;
  `sort` proc modifies the existing variable, and uses the `system.cmp` for comparisons by default.
  There is also the `sorted` proc, which returns a new copy instead of modifying the existing container.

  **`sorted` proc example:**
&quot;&quot;&quot;</span>
nbCode: 
  <span class="hljs-keyword">echo</span> listOfNumbers2.sorted() <span class="hljs-comment">#You can't use `sort` with an echo like this</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  You can also specify which comparison/`cmp` proc to use, like this:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">echo</span> listOfNumbers2.sorted(system.cmp[<span class="hljs-built_in">int</span>])

nbText: <span class="hljs-string">&quot;&quot;&quot;
  You can replace that `cmp`(compare) proc, with one of the following from the Nim's Standard Library's docs search results:
&quot;&quot;&quot;</span>
nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;&lt;img src = &quot;images/cmpSearchResults.png&quot; alt = &quot;`cmp` search results&quot;&gt;&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Generics&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Generics in Nim, are used to parametrize procs, iterators or types with type parameters.
  \`[]\`` are used along with capital letters inside of them, separated by commas,
  after a type's name, proc or iterator to tell the compiler that this will be a `generic`:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
      ndata: <span class="hljs-built_in">string</span>

  <span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>]() =
    <span class="hljs-keyword">discard</span>
  
  <span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>]() =
    <span class="hljs-keyword">discard</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  The above examples are incomplete, they will not work just yet.
  Again, using \`[]\` with a capital letter inside will just &quot;mark&quot; the `type, proc, iterator` as a generic.
  Now we require to use that `T`(can be any capital letter) in the arguments of the `proc`, `iterator`,
  and on the fields of a `type` like so:
&quot;&quot;&quot;</span>
nbSubSection <span class="hljs-string">&quot;Generic Definitions&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericObject</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
      data: <span class="hljs-type">T</span>

  <span class="hljs-keyword">type</span>
    <span class="hljs-type">GenericTuple</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] = <span class="hljs-keyword">tuple</span>
      name: <span class="hljs-type">A</span>
      age: <span class="hljs-type">B</span>

  <span class="hljs-keyword">proc</span> genericProc[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>) =
    <span class="hljs-keyword">discard</span>
  
  <span class="hljs-keyword">iterator</span> genericIterator[<span class="hljs-type">T</span>](anyType: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **And also for generic containers proc definition example**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> genericContainerProc[<span class="hljs-type">T</span>](anyTypeContainer: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]) =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's see how to use this `generic object`
&quot;&quot;&quot;</span>
nbSubSection <span class="hljs-string">&quot;Generic Object Initialization&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> genericObject = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">string</span>](data: <span class="hljs-string">&quot;A String&quot;</span>)
  <span class="hljs-keyword">var</span> genericObject2 = <span class="hljs-type">GenericObject</span>[<span class="hljs-built_in">int</span>](data: <span class="hljs-number">101</span>)

  <span class="hljs-keyword">echo</span> genericObject, <span class="hljs-string">&quot; of type &quot;</span>, genericObject.typeof
  <span class="hljs-keyword">echo</span> genericObject2, <span class="hljs-string">&quot; of type &quot;</span>, genericObject2.typeof

nbSubSection <span class="hljs-string">&quot;Generic Tuple Initialization&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> genericTuple: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>)
  <span class="hljs-keyword">var</span> genericTuple2: <span class="hljs-type">GenericTuple</span>[<span class="hljs-built_in">seq</span>[<span class="hljs-built_in">float</span>], <span class="hljs-built_in">bool</span>] = (@[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">3.25</span>], <span class="hljs-literal">true</span>)

  <span class="hljs-keyword">echo</span> genericTuple, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple.typeof
  <span class="hljs-keyword">echo</span> genericTuple2, <span class="hljs-string">&quot; of type &quot;</span>, genericTuple2.typeof
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Calling generic procs and iterators is exactly the same as non generic versions,
  unlike structures like `objects` and `tuples`(shown above).
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;More Overloading&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **NOTE:** `hashSets, more on hash Tables and Hashing` had the start of `more` overloading,
  since the Nim for Beginners #22 Procedure Overloading(4 min long).

  To demonstrate and teach you more about overloading, we are going to overload the `find` proc.

  The `find` proc from the `strutils` module(string utilities)(also in some other modules),
  is very useful for finding substrings(a part of a string) in a string.

  In fact, we have already used it in both the Sets and the hashSets videos,
  in order to `find` and remove specified separators from a string.

  This time though, we are going to use the `system.find` version,
  which does not deal with `strings` but with an element of some type. 
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Using `find` with a sequence of numbers&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> mySequence = @[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">50</span>]

  <span class="hljs-keyword">echo</span> mySequence.find(-<span class="hljs-number">10</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Like with all `find` proc versions, you give it what you want it to find, and it returns the `index` of where it is.

  **If you were to reinsert the index back, you would get -10 in this case:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> location = mySequence.find(-<span class="hljs-number">10</span>)
  <span class="hljs-keyword">echo</span> mySequence[location]

nbSubSection <span class="hljs-string">&quot;Using `find` with a sequence of objects&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Now let's find an object based on one of it's fields in a sequence:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">SomeObject</span> = <span class="hljs-keyword">object</span>
      name: <span class="hljs-built_in">string</span>
      age: <span class="hljs-built_in">int</span>
  
  <span class="hljs-keyword">var</span> seqOfSomeObject: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>]
  seqOfSomeObject.add <span class="hljs-type">SomeObject</span>(name: <span class="hljs-string">&quot;Wombat&quot;</span>, age: <span class="hljs-number">3</span>)
  seqOfSomeObject.add <span class="hljs-type">SomeObject</span>(name: <span class="hljs-string">&quot;Womp rat&quot;</span>, age: <span class="hljs-number">5</span>)
  
nbCodeSkip:
  <span class="hljs-keyword">let</span> wompRat = seqOfSomeObject.find(<span class="hljs-string">&quot;Womp rat&quot;</span>)
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;index of Womp rat: &quot;</span>, wompRat, <span class="hljs-string">&quot; reinsertion: &quot;</span>, seqOfSomeObject[wompRat]

nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;&lt;img src = &quot;images/findProcError.png&quot; alt = &quot;`find` proc error&quot;&gt;&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Overloading `find` proc&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, `find` proc does not have a version/overload for our `SomeObject`,
  and therefore does not compile.

  **So in order to make it work, we need to overload the `find` proc for our custom object:**
  First off, here is how the `system.find` proc is defined(a generic):
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">proc</span> find*[<span class="hljs-type">T</span>, <span class="hljs-type">S</span>](a: <span class="hljs-type">T</span>, item: <span class="hljs-type">S</span>): <span class="hljs-built_in">int</span> {.inline.}=
    <span class="hljs-comment">## Returns the first index of `item` in `a` or -1 if not found. This requires</span>
    <span class="hljs-comment">## appropriate `items` and `==` operations to work.</span>
    <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items(a):
      <span class="hljs-keyword">if</span> i == item: <span class="hljs-keyword">return</span>
      inc(<span class="hljs-literal">result</span>)
    <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span>

nbText <span class="hljs-string">&quot;&quot;&quot;
  Our overload, in order to `find` by the fields of our `SomeObject`:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">#Can also be: proc find[T, S](a: T, item: S): int {.inline.} = #Specify for a single type, better</span>
  <span class="hljs-keyword">proc</span> find[<span class="hljs-type">S</span>](a: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>], item: <span class="hljs-type">S</span>): <span class="hljs-built_in">int</span> {.inline.} =
    <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> a.pairs:
      <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> element.fields: <span class="hljs-comment">#Second unwrap to get the fields of `name: string` and `age: int`</span>
        <span class="hljs-keyword">if</span> f.typeof <span class="hljs-keyword">is</span> item.typeof:
          <span class="hljs-keyword">if</span> $f == $item: <span class="hljs-keyword">return</span> index <span class="hljs-comment">#To string($) -&gt; f(int) == item(string) -&gt; ERROR</span>
        <span class="hljs-comment">#inc(result) #No longer needed as we are using the `pairs` iterator</span>
    <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span>

nbCode:
  <span class="hljs-keyword">let</span> wompRat = seqOfSomeObject.find(<span class="hljs-string">&quot;Womp rat&quot;</span>)
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Found name Womp rat at index: &quot;</span>, wompRat
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[wompRat]

nbText: <span class="hljs-string">&quot;&quot;&quot;
  And now for the `age` field:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> ageOfWompRat = seqOfSomeObject.find(<span class="hljs-number">5</span>)

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Found age 5 at index: &quot;</span>, ageOfWompRat
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[ageOfWompRat]

nbSubSection <span class="hljs-string">&quot;`[]` overload for ease of life&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  \`[]\` overload will allow us to replace: 
  `seqOfSomeObject.find(&quot;Womp rat&quot;)` to `seqOfSomeObject[&quot;Womp rat&quot;]` to get the index.

  The overload is mostly the same as the `find` overload.
  **Except that the `item` argument is now a `string` instead of a generic.**

  This is because, if the overloaded \`[]\` was given an `integer`,
  it would still try to return us the element at the index of that `integer`.
  And in this instance `5` is not in the index of the 2 fields(0, 1),
  resulting in an error.
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">import</span> std/strutils

nbCode:
  <span class="hljs-keyword">proc</span> `[]`(a: <span class="hljs-built_in">seq</span>[<span class="hljs-type">SomeObject</span>], item: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">int</span> {.inline.} =
    <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> index, element <span class="hljs-keyword">in</span> a.pairs:
      <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> element.fields: <span class="hljs-comment">#Second unwrap to get the fields of `name: string` and `age: int`</span>
        <span class="hljs-keyword">if</span> parseInt($f) <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>:  <span class="hljs-comment">#`Line 1` Try to parse - to see if we get an `int`</span>
          <span class="hljs-keyword">if</span> $f == $item: <span class="hljs-keyword">return</span> index <span class="hljs-comment">#To string($) -&gt; f(int) == item(string) -&gt; ERROR</span>
        <span class="hljs-keyword">elif</span> $f == $item: <span class="hljs-keyword">return</span> index 
        <span class="hljs-comment">#inc(result) #No longer needed as we are using the `pairs` iterator</span>
    <span class="hljs-literal">result</span> = -<span class="hljs-number">1</span>

nbCode:
  <span class="hljs-keyword">let</span> name = seqOfSomeObject[<span class="hljs-string">&quot;Womp rat&quot;</span>]
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;name's index: &quot;</span>, name
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[name]

nbText: <span class="hljs-string">&quot;&quot;&quot;
  The following will NOT compile, and crash if the `item` argument is a generic.
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">let</span> age = seqOfSomeObject[<span class="hljs-number">5</span>] <span class="hljs-comment">#Index out of bounds - no crash yet</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;age's index: &quot;</span>, age
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[age] <span class="hljs-comment">#Crash here</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  What we can do is make that number `5` into a string `$5`.
  And with that change the `[]`'s overload's marked `Line #1` checking of `if f.typeof is item.typeof:`,
  to `if parseInt($f) is int:`, in order to see if the parsed string is an actual integer,
  and then the same process as before continues.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> age = seqOfSomeObject[$<span class="hljs-number">5</span>]
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;age's index: &quot;</span>, age
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Reinsertion result: &quot;</span>, seqOfSomeObject[age]


nbSection <span class="hljs-string">&quot;Tuple Unpacking&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  In the past video of `Nim for Beginners #14 Tuples`, i have shown you Tuples.
  (There is a lot of dealing with `tuples` in the Extra cut content)

  Now it's time to explain and demonstrate `tuple unpacking`. Tuple unpacking is quite simple.

  You can use them to give values(assignment) to multiple variables(`var`), constants(`const`) or immutable variable(`let`),
  at once.

  **Example 1:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> (v1, c1, l1) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

  <span class="hljs-keyword">echo</span> v1
  <span class="hljs-keyword">echo</span> c1
  <span class="hljs-keyword">echo</span> l1
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **You may also ommit assignment of any of them:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> (v2, _, l2) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)

  <span class="hljs-keyword">let</span> (_, _, _) = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **All of this is treated as syntatic sugar for basically the following code(Example 1):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span>
    temporaryTuple = (<span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;const&quot;</span>, <span class="hljs-string">&quot;let&quot;</span>)
    v3 = temporaryTuple[<span class="hljs-number">0</span>]
    c3 = temporaryTuple[<span class="hljs-number">1</span>]
    l3 = temporaryTuple[<span class="hljs-number">2</span>]
nbText: <span class="hljs-string">&quot;&quot;&quot;
  I don't think i have ever shown this before, but yes, you can access any field of a `tuple`,
  without knowing the name of the field, especially useful for `anonymous` tuples like here(fields without names).
  I do recommend though, that you do use the `names` of the fields over the `index` when the `names` are present.

  When tuple unpacking with tuples with numbers(literals) into `var` and `let` variables,
  they get assigned their values without a `temporaryTuple`.

  Since you can nest any container withing another container(array, seq, set, table, etc), 
  as well as data structure in a data structure(object, tuple),
  you can also use nested tuples for tuple unpacking.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Tuple Unpacking Use Case&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In Nim you can have multiple return types for a `proc`,
  by using `object variants` and `union types`(int|string).

  This can also be achieved by using `tuples`. But `tuples`,
  don't just allow for multiple types to be returned,
  they allow for multiple returns, which can then be easily `unpacked`, 
  into variables and containers.
  
  **Here is an example of a multiple return:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> returnsNestedTuple(): (<span class="hljs-built_in">int</span>, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>), <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) = (<span class="hljs-number">4</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

  <span class="hljs-keyword">let</span> (x, (_, y), _, z) = returnsNestedTuple()

  <span class="hljs-keyword">echo</span> x, <span class="hljs-string">&quot; &quot;</span>, y, <span class="hljs-string">&quot; &quot;</span>, z

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Another very useful part of `tuple unpacking` is that, you don't need to return anything.
  1, 2, all or none.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
## OUTRO - AFTERWORDS

  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also follow me on twitter of the same name, and support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of offline tutorial.

  Also, don't forget checking out the Extra cut content!

### Thanks to my past and current Patrons
&lt;b&gt;Past Patrons:&lt;/b&gt;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)

&lt;b&gt;Current Patrons&lt;/b&gt;
- jaap groot (from October 2023)
- Dimitri Lesnoff (from October 2023)

&lt;b&gt;Compiler information&lt;/b&gt;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option
- Timestamps:
  - 00:15 Start of video example
&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;

&lt;b&gt;LINKS:&lt;/b&gt;
- [Extra Content](https://kiloneie.github.io/Extra%20Content/extraMakingFakeTable.html &quot;Extra Content&quot;)
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)

&lt;b&gt;LINKS to this video's subject:&lt;/b&gt;
- [min/maxIndex procs](https://nim-lang.org/docs/sequtils.html#minIndex%2CopenArray%5BT%5D &quot;min/maxIndex procs&quot;)
- [for `sort` func and `sorted` proc](https://nim-lang.org/docs/algorithm.html#sort%2CopenArray%5BT%5D%2Cproc%28T%2CT%29 &quot;for `sort` func and `sorted` proc&quot;)
- [parseInt](https://nim-lang.org/docs/strutils.html#parseInt%2Cstring &quot;parseInt&quot;)
&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>