<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>..\#4 Sugar collect List Comprehensions\Video Data\sugarCollectListComprehensions.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..\..\#3 Overloading in Depth">üè°</a></span>
  <span><code>..\#4 Sugar collect List Comprehensions\Video Data\sugarCollectListComprehensions.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ul>
<li>1. <a href="#list-comprehensions">List Comprehensions</a>
<ul>
<li>1.1. <a href="#nim---comprehending-a-list-with-a-for-loop">Nim - Comprehending a list with a for loop</a></li>
<li>1.2. <a href="#python's-list-comprehension-structure">Python's List Comprehension structure</a></li>
<li>1.3. <a href="#python---comprehending-a-list-with-a-for-loop">Python - Comprehending a list with a for loop</a></li>
<li>1.4. <a href="#nim---using-sugar.collect">Nim - Using sugar.collect</a></li>
<li>1.5. <a href="#python---list-comprehension">Python - List Comprehension</a></li>
</ul>
</li>
<li>2. <a href="#python's-list-comprehensions-vs-nim's-`collect`">Python's list comprehensions vs Nim's <code>collect</code></a>
<ul>
<li>2.1. <a href="#python's-list-comprehension-cons">Python's List Comprehension Cons</a></li>
</ul>
</li>
<li>3. <a href="#nim's-sugar-`collect`-pros">Nim's sugar <code>collect</code> Pros</a>
<ul>
<li>3.1. <a href="#long-one-liners-are-bad">Long one liners are bad</a></li>
<li>3.2. <a href="#sugar-`collect`-also-works-on-sets-and-tables">Sugar <code>collect</code> also works on Sets and Tables</a></li>
<li>3.3. <a href="#`collect`-with-sets"><code>collect</code> with Sets</a></li>
<li>3.4. <a href="#`collect`-with-hashsets"><code>collect</code> with hashSets</a></li>
<li>3.5. <a href="#`collect`-with-tables"><code>collect</code> with Tables</a></li>
</ul>
</li>
<li>4. <a href="#performance-benchmarks">Performance Benchmarks</a>
<ul>
<li>4.1. <a href="#nim's-3-variants">Nim's 3 variants</a></li>
<li>4.2. <a href="#python's-3-variants">Python's 3 variants</a></li>
</ul>
</li>
</ul>
      <meta name = "viewport" content = "width = device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      </style>
      <body>

      <button onclick = "topFunction()" id = "toTop" title = "Go to top">Top</button>
      <button onclick = "topFunction()" id = "toTopMobile" title = "Go to top">Top</button>

      <script>
        // Get the button
        let myButton = document.getElementById("toTop");
        let myButtonMobile = document.getElementById("toTopMobile");
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName("body"); //gives a query object

        //myButton.style.color = "red"; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop > 20 || document.documentElement.scrollTop > 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if ("maxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints > 0;
          } 
        else if ("msMaxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints > 0;
          } 
        else 
          {
            var mQ = window.matchMedia && matchMedia("(pointer:coarse)");

            if (mQ && mQ.media === "(pointer:coarse)") 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              currentButton.style.display = "block";
            } else {currentButton.style.display = "none";}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      </script>
    
<h2>INTRO - GREETING</h2>
<ul>
<li><strong>Title</strong>: List Comprehensions with sugar.collect and comparison against Python's List Comprehensions</li>
<li><strong>Alt Title</strong>: List Comprehensions with sugar.collect vs Python's List Comprehensions</li>
</ul>
<h2>INTRO - FOREWORDS</h2>
<p><strong>(What is the purpose of this video ?)</strong></p>
<ul>
<li>List comprehensions with sugar.collect and comparison against Python's List Comprehensions:
<ul>
<li>In this video we will go over sugar.collect, it's pros and cons,
and compare it against Python's list comprehensions with some benchmarks.</li>
</ul>
</li>
</ul>
<p>The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.</p>
<p><a name = "list-comprehensions"></a></p>
<h1>1. List Comprehensions</h1>
<hr />
<p>sugar.<code>collect</code> is a macro, a macro used for list comprehensions.
A list comprehension is basically making a list from an existing list based on some variable parameters.
This can be done with either a for loop or sugar.collect, list comprehensions in Python.</p>
<p><a name = "nim---comprehending-a-list-with-a-for-loop"></a></p>
<h2>¬†¬†1.1. Nim - Comprehending a list with a for loop</h2>
<hr />
<p>In the following example, we make a new list/sequence based on the <code>fruit</code> sequence,
by iterating over it with a <code>for</code> loop using the <code>pairs</code> iterator,
and returning only the elements of the list starting with the letter &quot;P&quot;.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> fruit = @[<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Pineapple&quot;</span>]

<span class="hljs-keyword">var</span> pFruit: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">string</span>]

<span class="hljs-keyword">for</span> i, f <span class="hljs-keyword">in</span> fruit.pairs:
  <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;P&quot;</span>:
    pFruit.add f

<span class="hljs-keyword">echo</span> pFruit</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">@[&quot;Peach&quot;, &quot;Pear&quot;, &quot;Pineapple&quot;]</pre></code></pre>

<p><a name = "python's-list-comprehension-structure"></a></p>
<h2>¬†¬†1.2. Python's List Comprehension structure</h2>
<hr />
<p>Before we go on for the Python's version of the above example,
here is the structure of a Python's <strong>list comprehension</strong>,
with explanation.</p>
<pre><code class="python hljs">  list = [returned for element in container if condition]</code></pre>
<ul>
<li><strong>returned</strong> - the element/value that will be returned/put in a new list.</li>
<li><strong>element</strong> - element of &quot;a&quot; container.</li>
<li><strong>container</strong> - dict, list, set, tuple(in Nim, it's a data structure).</li>
<li><strong>condition</strong> - optional -&gt; to perform operations for the &quot;returned&quot;.</li>
</ul>
<p><a name = "python---comprehending-a-list-with-a-for-loop"></a></p>
<h2>¬†¬†1.3. Python - Comprehending a list with a for loop</h2>
<hr />
<pre><code class="python hljs">  fruit = ["Apple", "Orange", "Banana", "Peach", "Pear", "Pineapple"]
  pfruit = []

  for f in fruit:
    if "P" in f:
      pfruit.append(f)

  print(pfruit)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  ['Peach', 'Pear', 'Pineapple']</code></pre>
<p><a name = "nim---using-sugar.collect"></a></p>
<h2>¬†¬†1.4. Nim - Using sugar.collect</h2>
<hr />
<p>The exact same code as the one with the <code>for</code> loop,
except now it uses the <code>sugar</code> module's <code>collect</code> macro.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> pFruit2 = collect(newSeq):
  <span class="hljs-keyword">for</span> i, f <span class="hljs-keyword">in</span> fruit.pairs:
    <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;P&quot;</span>:
      f

<span class="hljs-keyword">echo</span> pFruit
<span class="hljs-keyword">echo</span> pFruit2</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">@[&quot;Peach&quot;, &quot;Pear&quot;, &quot;Pineapple&quot;]
@[&quot;Peach&quot;, &quot;Pear&quot;, &quot;Pineapple&quot;]</pre></code></pre>

<p><a name = "python---list-comprehension"></a></p>
<h2>¬†¬†1.5. Python - List Comprehension</h2>
<hr />
<pre><code class="python hljs">  fruit2 = ["Apple", "Orange", "Banana", "Peach", "Pear", "Pineapple"]

  pfruit2 = [f for f in fruit2 if "P" in f]

  print(pfruit)
  print(pfruit2)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  ['Peach', 'Pear', 'Pineapple']
  ['Peach', 'Pear', 'Pineapple']</code></pre>
<p><a name = "python's-list-comprehensions-vs-nim's-`collect`"></a></p>
<h1>2. Python's list comprehensions vs Nim's <code>collect</code></h1>
<hr />
<p>Python's List comprehensions are a more compact way to create new lists,
in situations where map() and filter(), and or nested loops would be used.
They are great for simple tasks.</p>
<div style = "font-size: 10px">
map(function, container, container,...) runs a function on given containers,
and returns only the elements that passed<br>
filter(function, container, container,...) runs a function on given containers, 
and transforms them, returninmg the transformed result</div>
<p>Here are a few examples:</p>
<pre><code class="python hljs">  print([i for i in range(10)])</code></pre>
<pre><code class="python hljs">  toTen = []
  for i in range(10):
    toTen.append(i)

  print(toTen)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>
<pre><code class="python hljs">  print([i for i in range(20) if i%2 == 0])</code></pre>
<pre><code class="python hljs">  evenToTwenty = []
  for i in range(20):
    if i%2 == 0:
      evenToTwenty.append(i)

  print(evenToTwenty)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</code></pre>
<pre><code class="python hljs">  nums = [1, 2, 3, 4]
  fruit = ["Apples", "Peaches", "Pears", "Bananas"]
  print([(i, f) for i in nums for f in fruit])</code></pre>
<pre><code class="python hljs">  fourTimesFour = []
  for i in nums:
    for f in fruit:
      fourTimesFour.append((i, f)) #Double (()) - because tuple as argument - python demands () for funcs

  print(fourTimesFour)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [(1, 'Apples'), (1, 'Peaches'), (1, 'Pears'), (1, 'Bananas'),
  (2, 'Apples'), (2, 'Peaches'), (2, 'Pears'), (2, 'Bananas'),
  (3, 'Apples'), (3, 'Peaches'), (3, 'Pears'), (3, 'Bananas'),
  (4, 'Apples'), (4, 'Peaches'), (4, 'Pears'), (4, 'Bananas')]</code></pre>
<pre><code class="python hljs">  print([(i, f) for i in nums for f in fruit if f[0] == "P"])</code></pre>
<pre><code class="python hljs">  fruitP = []
  for i in nums:
    for f in fruit:
      if f[0] == "P":
        fruitP.append((i, f))

  print(fruitP)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [(1, 'Peaches'), (1, 'Pears'),
  (2, 'Peaches'), (2, 'Pears'),
  (3, 'Peaches'), (3, 'Pears'),
  (4, 'Peaches'), (4, 'Pears')]</code></pre>
<pre><code class="python hljs">  print([(i, f) for i in nums for f in fruit if f[0] == "P" if i%2 == 1])</code></pre>
<pre><code class="python hljs">  fruitPodd = []
  for i in nums:
    for f in fruit:
      if f[0] == "P" and i%2 == 1:
        fruitPodd.append((i, f))

  print(fruitPodd)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [(1, 'Peaches'), (1, 'Pears'), (3, 'Peaches'), (3, 'Pears')]</code></pre>
<pre><code class="python hljs">  print([i for i in zip(nums, fruit) if i[0] %2== 0])</code></pre>
<pre><code class="python hljs">  fruitEvenZip = []

  for i in zip(nums, fruit):
    if i[0] %2 == 0:
      fruitEvenZip.append(i)

  print(fruitEvenZip)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [(2, 'Peaches'), (4, 'Bananas')]</code></pre>
<p><a name = "python's-list-comprehension-cons"></a></p>
<h2>¬†¬†2.1. Python's List Comprehension Cons</h2>
<hr />
<p>Python's List Comprehension are useful for small and simple lists, but become extremely hard to understand the more complex they become,
unlike just using a for loop, which is yes more verbose, but also easier to understand and read,
especially if you haven't viewed the code with with a list comprehension for a while.</p>
<p>Here is a <strong>good</strong> example of a <strong>bad</strong> one liner:</p>
<pre><code class="python hljs">  listLLL = [[[1,2,3],[4,5,6],[7,8,9]]]
  flatten_keep_evens = [item for listLL in listLLL for listL in listLL for item in listL if item % 2 == 0]

  print(flatten_keep_evens)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [2, 4, 6, 8]</code></pre>
<p>The above <strong>good</strong> example of a <strong>bad</strong> one liner,
can be greatly improved by indentation(like a for loop) like this:</p>
<pre><code class="python hljs">  doubleNestedLLL = [[[1,2,3], [4,5,6], [7,8,9]]]
  flatenedEvens = [
      element
      for nestedLL in doubleNestedLLL
      for elementsL in nestedLL
      for element in elementsL
      if not element % 2
  ]

  print(flatenedEvens)</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  [2, 4, 6, 8]</code></pre>
<p><a name = "nim's-sugar-`collect`-pros"></a></p>
<h1>3. Nim's sugar <code>collect</code> Pros</h1>
<hr />
<p><a name = "long-one-liners-are-bad"></a></p>
<h2>¬†¬†3.1. Long one liners are bad</h2>
<hr />
<p>Nim does not do list comprehensions as one liners like Python does,
they work very much the same as a for loop, but reduce a bit of typing,
by not having to declare/initialize a sequence before hand, but at the moment of usage.
Then we also don't need to call <code>.add + elementWeWant</code>, but just the <code>elementWeWant</code>.</p>
<p><a name = "sugar-`collect`-also-works-on-sets-and-tables"></a></p>
<h2>¬†¬†3.2. Sugar <code>collect</code> also works on Sets and Tables</h2>
<hr />
<p>Nim's sugar's collect also works on hashSets and Tables, unlike Python.
Nim's collect macro does not have the drawbacks of Python's list comprehensions,
while being much more powerful, because <code>collect</code> also works on other types.
These types being, Sets, HashSets and Tables.</p>
<p><a name = "`collect`-with-sets"></a></p>
<h2>¬†¬†3.3. <code>collect</code> with Sets</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> normalSet = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}

<span class="hljs-keyword">var</span> evenNumbers = collect:
  <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> normalSet:
    <span class="hljs-keyword">if</span> num <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
      num

<span class="hljs-keyword">echo</span> evenNumbers</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">@[2, 4, 6]</pre></code></pre>

<p><a name = "`collect`-with-hashsets"></a></p>
<h2>¬†¬†3.4. <code>collect</code> with hashSets</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/sets

<span class="hljs-keyword">let</span> keyValueSet = [(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&quot;Key 3&quot;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&quot;Key 4&quot;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&quot;Key 5&quot;</span>, <span class="hljs-number">5</span>)].toOrderedSet</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>Normal version:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> oddKeys: <span class="hljs-type">HashSet</span>[(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)]

<span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValueSet:
  <span class="hljs-keyword">if</span> tup[<span class="hljs-number">1</span>] <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
    oddKeys.incl tup

<span class="hljs-keyword">echo</span> oddKeys</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(&quot;Key 1&quot;, 1), (&quot;Key 3&quot;, 3), (&quot;Key 5&quot;, 5)}</pre></code></pre>

<p><strong><code>collect</code> version:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> oddKeysCollect = collect:
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValueSet:
    <span class="hljs-keyword">if</span> tup[<span class="hljs-number">1</span>] <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
      tup

<span class="hljs-keyword">echo</span> oddKeysCollect</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">@[(&quot;Key 1&quot;, 1), (&quot;Key 3&quot;, 3), (&quot;Key 5&quot;, 5)]</pre></code></pre>

<p><a name = "`collect`-with-tables"></a></p>
<h2>¬†¬†3.5. <code>collect</code> with Tables</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/tables

<span class="hljs-keyword">let</span> characterClassEquipment = {<span class="hljs-string">&quot;Paladin&quot;</span>: @[<span class="hljs-string">&quot;Maul&quot;</span>, <span class="hljs-string">&quot;Breastplate&quot;</span>], 
                              <span class="hljs-string">&quot;Wizard&quot;</span>: @[<span class="hljs-string">&quot;Staff&quot;</span>, <span class="hljs-string">&quot;Robe&quot;</span>], <span class="hljs-string">&quot;Druid&quot;</span>: @[<span class="hljs-string">&quot;Staff&quot;</span>],
                              <span class="hljs-string">&quot;Fighter&quot;</span>: @[<span class="hljs-string">&quot;Sword&quot;</span>, <span class="hljs-string">&quot;Shield&quot;</span>, <span class="hljs-string">&quot;Plate Armour&quot;</span>]}.toOrderedTable</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>Normal version:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> staffWielders = initOrderedTable[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">string</span>]]() <span class="hljs-comment">#Do NOT forget `()` at the end</span>

<span class="hljs-keyword">for</span> class, items <span class="hljs-keyword">in</span> characterClassEquipment:
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
    <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;Staff&quot;</span>:
      staffWielders[class] = items <span class="hljs-comment">#`table.add key, value` is now deprecated(marked for future removal)</span>

<span class="hljs-keyword">echo</span> staffWielders</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{&quot;Wizard&quot;: @[&quot;Staff&quot;, &quot;Robe&quot;], &quot;Druid&quot;: @[&quot;Staff&quot;]}</pre></code></pre>

<p><strong><code>collect</code> version:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> staffWieldersCollect = collect:
  <span class="hljs-keyword">for</span> class, items <span class="hljs-keyword">in</span> characterClassEquipment:
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
      <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;Staff&quot;</span>:
        {class: items} <span class="hljs-comment">#Kind of bizzare way of returning</span>

<span class="hljs-keyword">echo</span> staffWieldersCollect</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{&quot;Wizard&quot;: @[&quot;Staff&quot;, &quot;Robe&quot;], &quot;Druid&quot;: @[&quot;Staff&quot;]}</pre></code></pre>

<p><a name = "performance-benchmarks"></a></p>
<h1>4. Performance Benchmarks</h1>
<hr />
<p>Now i will show you performance benchmarks of 3 variants of making a new list,
in both Python and Nim. This is NOT a benchmark of the languages.
This is only meant to see the difference of the 3 variants.</p>
<p>My relevant computer specs used for this benchmark:</p>
<ul>
<li><strong>CPU</strong>: Ryzen 2700x</li>
<li><strong>RAM</strong>: G.Skill Ripjaws V 16GB (2x8GB) DDR4 F4-3200C16D-16GVKB</li>
</ul>
<p>The 3 variants are as follow:</p>
<ul>
<li><strong>add</strong> and <strong>append</strong></li>
<li><strong>index</strong> - <strong>[]</strong></li>
<li><strong>collect</strong> and <strong>list comprehension</strong></li>
</ul>
<p>All 3 variants of the 2 versions of Nim and Python,
create a new list by filling a pre-initialized to size 10000 sequence/array,
with arbitrary data, that is then benchmarked 10000 times,
in order to account for slight variations that occur.
The resulting time elapsed is then divided back by 10000,
to get the mostly correct/aproximate time elapsed for our variations.</p>
<p>This is eased for Nim by the usage of a custom template,
while Python has an official module specifically for this purpose.</p>
<p><a name = "nim's-3-variants"></a></p>
<h2>¬†¬†4.1. Nim's 3 variants</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

<span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = cpuTime()

    <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
      code

    <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
    <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
    <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
  <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
    list.add j

benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
  <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

  <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
    list[index] = index

benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

  <span class="hljs-keyword">var</span> list = collect:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      i</code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">CPU Time [add    ] x 10000 = 0.000166400000s
CPU Time [index  ] x 10000 = 0.000138800000s
CPU Time [collect] x 10000 = 0.000165400000s</code></pre>
<p><a name = "python's-3-variants"></a></p>
<h2>¬†¬†4.2. Python's 3 variants</h2>
<hr />
<pre><code class="python hljs">  from timeit import timeit

  def fAppend():
      num = 10000
      li = []
      for i in range(num):
          li.append(i)

  def fIndex():
      num = 10000
      li = [0] * num
      for i in range(num):
          li[i] = i

  def fLComprehension():
      num = 10000
      li = [i for i in range(num)]

  def main(x):
      print(timeit(stmt = fAppend, number = x) / x)
      print(timeit(stmt = fIndex, number = x) / x)
      print(timeit(stmt = fLComprehension, number = x) / x)

  main(10000) </code></pre>
<pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;">  CPU Time [append       ] x 10000 = 0.00065512317
  CPU Time [index        ] x 10000 = 0.0003905595900000001
  CPU Time [comprehension] x 10000 = 0.0002650251300000001</code></pre>
<h6>(You may run the above benchmarks yourself to double check the data. 
But the results will vary by your CPU and RAM speeds.)</h6>
<h1>Outro - Afterwords</h1>
<hr />
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also follow me on twitter of the same name, and support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of offline tutorial.</p>
<h1>Thanks to my past and current Patrons</h1>
<hr />
<h2>Past Patrons</h2>
<hr />
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<h2>Current Patrons</h2>
<hr />
<ul>
<li>jaap groot (from October 2023)</li>
<li>Dimitri Lesnoff (from October 2023)</li>
</ul>
<h2>Compiler Information</h2>
<hr />
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option</li>
</ul>
<h2>My and General Links</h2>
<hr />
<ul>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<h2>Links to this video's subject:</h2>
<hr />
<ul>
<li><a href="https://nim-lang.org/docs/sugar.html#collect.m%2Cuntyped" title="sugar.collect">Sugar module's collect macro</a></li>
<li><a href="https://www.w3schools.com/python/python_lists_comprehension.asp" title="Python's List Comprehensions">Python's List Comprehensions</a></li>
<li><a href="https://www.w3schools.com/python/ref_func_map.asp" title="Python's map() function">Python's map() function</a></li>
<li><a href="https://www.w3schools.com/python/ref_func_filter.asp" title="Python's filter() function">Python's filter() function</a></li>
<li><a href="https://docs.python.org/3/library/timeit.html" title="Python's benchmarking timeit module's timeit() function">Python's benchmarking timeit module's timeit() function</a></li>
<li><a href="https://nim-lang.org/docs/strutils.html#formatFloat%2Cfloat%2CFloatFormatMode%2Crange%5B%5D%2Cchar" title="Nim's formatFloat func">Nim's formatFloat func</a></li>
<li><a href="https://nim-lang.org/docs/times.html#cpuTime" title="Nim's cpuTime from the Times module">Nim's cpuTime from the Times module</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>
<span class="hljs-comment">#nbShow is super useful!</span>

<span class="hljs-comment">#https://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals raw strings r&quot;&quot;</span>

<span class="hljs-keyword">import</span> nimib, std/strutils <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment">#Overriding nimib's nbCode -&gt; with a version that has horizontal scroll for overflowing output</span>
<span class="hljs-keyword">import</span> nimib / [capture]

<span class="hljs-keyword">template</span> nbCode(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCode&quot;</span>, body): <span class="hljs-comment">#Writes to stdout `lineNumb typeOfNBblock: a bit of first line</span>
    captureStdout(nb.blk.output):
      body

nb.partials[<span class="hljs-string">&quot;nbCode&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
{{&gt;nbCodeSource}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot; style = &quot;color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;&quot;&gt;{{&gt;nbCodeOutput}}&lt;/code&gt;&lt;/pre&gt;
&quot;&quot;&quot;</span> 
nb.renderPlans[<span class="hljs-string">&quot;nbCode&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>] <span class="hljs-comment"># default partial automatically escapes output (code is escaped when highlighting)</span>

<span class="hljs-comment">#Templates for showing Python code snippets and output</span>
<span class="hljs-keyword">template</span> nbPythonShowOnlyCode(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbPythonShowOnlyCode&quot;</span>, body):
    nb.blk.output = body

nb.partials[<span class="hljs-string">&quot;nbPythonShowOnlyCode&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;&lt;pre&gt;&lt;code class=&quot;python hljs&quot;&gt;{{&amp;output}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>
nb.renderPlans[<span class="hljs-string">&quot;nbPythonShowOnlyCode&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>]

<span class="hljs-keyword">template</span> nbPythonShowOnlyOutput(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbPythonShowOnlyOutput&quot;</span>, body):
    nb.blk.output = body

nb.partials[<span class="hljs-string">&quot;nbPythonShowOnlyOutput&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot; style = &quot;color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;&quot;&gt;{{&amp;output}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>
nb.renderPlans[<span class="hljs-string">&quot;nbPythonShowOnlyOutput&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>]

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">var</span> index = (section: <span class="hljs-number">0</span>, subsection: <span class="hljs-number">0</span>)

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  index.section.inc
  index.subsection = <span class="hljs-number">0</span> <span class="hljs-comment">#Reset on a new nbSection</span>

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;. &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;- &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> <span class="hljs-comment">#&amp;#92; is HTML code for &quot;\&quot;, you can also &quot;\\&quot; or r&quot;\&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbSubSection(name:<span class="hljs-built_in">string</span>) =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbUoSection(name: <span class="hljs-built_in">string</span>) =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbUoSubSection(name: <span class="hljs-built_in">string</span>) =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-comment">#Updating the same file is shown instantly once deployed via Github Page on PC. </span>
  <span class="hljs-comment">#Mobile takes either a random amount of time, or NOT at all!</span>
<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">hlHtml&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTop&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;
      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTopMobile&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
        // Get the button
        let myButton = document.getElementById(&quot;toTop&quot;);
        let myButtonMobile = document.getElementById(&quot;toTopMobile&quot;);
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName(&quot;body&quot;); //gives a query object

        //myButton.style.color = &quot;red&quot;; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if (&quot;maxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints &gt; 0;
          } 
        else if (&quot;msMaxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints &gt; 0;
          } 
        else 
          {
            var mQ = window.matchMedia &amp;&amp; matchMedia(&quot;(pointer:coarse)&quot;);

            if (mQ &amp;&amp; mQ.media === &quot;(pointer:coarse)&quot;) 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
              currentButton.style.display = &quot;block&quot;;
            } else {currentButton.style.display = &quot;none&quot;;}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Use Live Preview Extension and set the Auto Refresh Preview set to &quot;On changes to Saved Files&quot;</span>
  <span class="hljs-comment">#And Server Keep Alive After Embedded Preview Close set to 0, </span>
  <span class="hljs-comment">#so that we no longer need the preview embedded window, we now have it in the browser!</span>
    <span class="hljs-comment">#Live SERVER Extension no longer works, even with the .html file kept open</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd or hlMdf enables nimiboost's markdown highlight mode</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;
## INTRO - GREETING
- **Title**: List Comprehensions with sugar.collect and comparison against Python's List Comprehensions
- **Alt Title**: List Comprehensions with sugar.collect vs Python's List Comprehensions

## INTRO - FOREWORDS
**(What is the purpose of this video ?)**
- List comprehensions with sugar.collect and comparison against Python's List Comprehensions:
  - In this video we will go over sugar.collect, it's pros and cons,
    and compare it against Python's list comprehensions with some benchmarks.
   
The code for this video and it's script/documentation styled with nimib,
is in the link in the description as a form of written tutorial.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;List Comprehensions&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  sugar.`collect` is a macro, a macro used for list comprehensions. 
  A list comprehension is basically making a list from an existing list based on some variable parameters.
  This can be done with either a for loop or sugar.collect, list comprehensions in Python.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Nim - Comprehending a list with a for loop&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In the following example, we make a new list/sequence based on the `fruit` sequence,
  by iterating over it with a `for` loop using the `pairs` iterator,
  and returning only the elements of the list starting with the letter &quot;P&quot;.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> fruit = @[<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Pineapple&quot;</span>]

  <span class="hljs-keyword">var</span> pFruit: <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">string</span>]

  <span class="hljs-keyword">for</span> i, f <span class="hljs-keyword">in</span> fruit.pairs:
    <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;P&quot;</span>:
      pFruit.add f

  <span class="hljs-keyword">echo</span> pFruit

<span class="hljs-comment">#The following section is only shown(we are NOT teaching Python)</span>
nbSubSection  <span class="hljs-string">&quot;Python's List Comprehension structure&quot;</span> 
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Before we go on for the Python's version of the above example,
  here is the structure of a Python's **list comprehension**,
  with explanation.
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  list = [returned for element in container if condition]
&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">hlmd&quot;&quot;&quot;
- **returned** - the element/value that will be returned/put in a new list.
- **element** - element of &quot;a&quot; container.
- **container** - dict, list, set, tuple(in Nim, it's a data structure).
- **condition** - optional -&gt; to perform operations for the &quot;returned&quot;.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Python - Comprehending a list with a for loop&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  fruit = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Peach&quot;, &quot;Pear&quot;, &quot;Pineapple&quot;]
  pfruit = []

  for f in fruit:
    if &quot;P&quot; in f:
      pfruit.append(f)

  print(pfruit)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  ['Peach', 'Pear', 'Pineapple']
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Nim - Using sugar.collect&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The exact same code as the one with the `for` loop,
  except now it uses the `sugar` module's `collect` macro.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span> pFruit2 = collect(newSeq):
    <span class="hljs-keyword">for</span> i, f <span class="hljs-keyword">in</span> fruit.pairs:
      <span class="hljs-keyword">if</span> $f[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;P&quot;</span>:
        f

  <span class="hljs-keyword">echo</span> pFruit
  <span class="hljs-keyword">echo</span> pFruit2

nbSubSection <span class="hljs-string">&quot;Python - List Comprehension&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  fruit2 = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Peach&quot;, &quot;Pear&quot;, &quot;Pineapple&quot;]

  pfruit2 = [f for f in fruit2 if &quot;P&quot; in f]

  print(pfruit)
  print(pfruit2)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  ['Peach', 'Pear', 'Pineapple']
  ['Peach', 'Pear', 'Pineapple']
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Python's list comprehensions vs Nim's `collect`&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Python's List comprehensions are a more compact way to create new lists, 
in situations where map() and filter(), and or nested loops would be used. 
They are great for simple tasks.

&lt;div style = &quot;font-size: 10px&quot;&gt;
map(function, container, container,...) runs a function on given containers,
and returns only the elements that passed&lt;br&gt;
filter(function, container, container,...) runs a function on given containers, 
and transforms them, returninmg the transformed result&lt;/div&gt;

Here are a few examples:
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  print([i for i in range(10)])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlpy&quot;&quot;&quot;
  toTen = []
  for i in range(10):
    toTen.append(i)

  print(toTen)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&quot;&quot;&quot;</span>

nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  print([i for i in range(20) if i%2 == 0])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  evenToTwenty = []
  for i in range(20):
    if i%2 == 0:
      evenToTwenty.append(i)

  print(evenToTwenty)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
&quot;&quot;&quot;</span>

nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  nums = [1, 2, 3, 4]
  fruit = [&quot;Apples&quot;, &quot;Peaches&quot;, &quot;Pears&quot;, &quot;Bananas&quot;]
  print([(i, f) for i in nums for f in fruit])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlpy&quot;&quot;&quot;
  fourTimesFour = []
  for i in nums:
    for f in fruit:
      fourTimesFour.append((i, f)) #Double (()) - because tuple as argument - python demands () for funcs

  print(fourTimesFour)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [(1, 'Apples'), (1, 'Peaches'), (1, 'Pears'), (1, 'Bananas'),
  (2, 'Apples'), (2, 'Peaches'), (2, 'Pears'), (2, 'Bananas'),
  (3, 'Apples'), (3, 'Peaches'), (3, 'Pears'), (3, 'Bananas'),
  (4, 'Apples'), (4, 'Peaches'), (4, 'Pears'), (4, 'Bananas')]
&quot;&quot;&quot;</span>

nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  print([(i, f) for i in nums for f in fruit if f[0] == &quot;P&quot;])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  fruitP = []
  for i in nums:
    for f in fruit:
      if f[0] == &quot;P&quot;:
        fruitP.append((i, f))

  print(fruitP)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [(1, 'Peaches'), (1, 'Pears'),
  (2, 'Peaches'), (2, 'Pears'),
  (3, 'Peaches'), (3, 'Pears'),
  (4, 'Peaches'), (4, 'Pears')]
&quot;&quot;&quot;</span>

nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  print([(i, f) for i in nums for f in fruit if f[0] == &quot;P&quot; if i%2 == 1])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlpy&quot;&quot;&quot;
  fruitPodd = []
  for i in nums:
    for f in fruit:
      if f[0] == &quot;P&quot; and i%2 == 1:
        fruitPodd.append((i, f))

  print(fruitPodd)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [(1, 'Peaches'), (1, 'Pears'), (3, 'Peaches'), (3, 'Pears')]
&quot;&quot;&quot;</span>

nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  print([i for i in zip(nums, fruit) if i[0] %2== 0])
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlpy&quot;&quot;&quot;
  fruitEvenZip = []

  for i in zip(nums, fruit):
    if i[0] %2 == 0:
      fruitEvenZip.append(i)

  print(fruitEvenZip)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [(2, 'Peaches'), (4, 'Bananas')]
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Python's List Comprehension Cons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Python's List Comprehension are useful for small and simple lists, but become extremely hard to understand the more complex they become,
  unlike just using a for loop, which is yes more verbose, but also easier to understand and read,
  especially if you haven't viewed the code with with a list comprehension for a while.

  Here is a **good** example of a **bad** one liner:
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  listLLL = [[[1,2,3],[4,5,6],[7,8,9]]]
  flatten_keep_evens = [item for listLL in listLLL for listL in listLL for item in listL if item % 2 == 0]

  print(flatten_keep_evens)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [2, 4, 6, 8]
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
The above **good** example of a **bad** one liner, 
can be greatly improved by indentation(like a for loop) like this:
&quot;&quot;&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  doubleNestedLLL = [[[1,2,3], [4,5,6], [7,8,9]]]
  flatenedEvens = [
      element
      for nestedLL in doubleNestedLLL
      for elementsL in nestedLL
      for element in elementsL
      if not element % 2
  ]

  print(flatenedEvens)
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  [2, 4, 6, 8]
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Nim's sugar `collect` Pros&quot;</span>
nbSubSection <span class="hljs-string">&quot;Long one liners are bad&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Nim does not do list comprehensions as one liners like Python does,
they work very much the same as a for loop, but reduce a bit of typing,
by not having to declare/initialize a sequence before hand, but at the moment of usage.
Then we also don't need to call `.add + elementWeWant`, but just the `elementWeWant`. 
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Sugar `collect` also works on Sets and Tables&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Nim's sugar's collect also works on hashSets and Tables, unlike Python.
Nim's collect macro does not have the drawbacks of Python's list comprehensions,
while being much more powerful, because `collect` also works on other types.
These types being, Sets, HashSets and Tables.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`collect` with Sets&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> normalSet = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}

  <span class="hljs-keyword">var</span> evenNumbers = collect:
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> normalSet:
      <span class="hljs-keyword">if</span> num <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        num

  <span class="hljs-keyword">echo</span> evenNumbers

nbSubSection <span class="hljs-string">&quot;`collect` with hashSets&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/sets

  <span class="hljs-keyword">let</span> keyValueSet = [(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&quot;Key 3&quot;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&quot;Key 4&quot;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&quot;Key 5&quot;</span>, <span class="hljs-number">5</span>)].toOrderedSet

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Normal version:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> oddKeys: <span class="hljs-type">HashSet</span>[(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)]

  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValueSet:
    <span class="hljs-keyword">if</span> tup[<span class="hljs-number">1</span>] <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
      oddKeys.incl tup

  <span class="hljs-keyword">echo</span> oddKeys

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **`collect` version:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> oddKeysCollect = collect:
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValueSet:
      <span class="hljs-keyword">if</span> tup[<span class="hljs-number">1</span>] <span class="hljs-keyword">mod</span> <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:
        tup

  <span class="hljs-keyword">echo</span> oddKeysCollect

nbSubSection <span class="hljs-string">&quot;`collect` with Tables&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/tables

  <span class="hljs-keyword">let</span> characterClassEquipment = {<span class="hljs-string">&quot;Paladin&quot;</span>: @[<span class="hljs-string">&quot;Maul&quot;</span>, <span class="hljs-string">&quot;Breastplate&quot;</span>], 
                                <span class="hljs-string">&quot;Wizard&quot;</span>: @[<span class="hljs-string">&quot;Staff&quot;</span>, <span class="hljs-string">&quot;Robe&quot;</span>], <span class="hljs-string">&quot;Druid&quot;</span>: @[<span class="hljs-string">&quot;Staff&quot;</span>],
                                <span class="hljs-string">&quot;Fighter&quot;</span>: @[<span class="hljs-string">&quot;Sword&quot;</span>, <span class="hljs-string">&quot;Shield&quot;</span>, <span class="hljs-string">&quot;Plate Armour&quot;</span>]}.toOrderedTable
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Normal version:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> staffWielders = initOrderedTable[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">seq</span>[<span class="hljs-built_in">string</span>]]() <span class="hljs-comment">#Do NOT forget `()` at the end</span>

  <span class="hljs-keyword">for</span> class, items <span class="hljs-keyword">in</span> characterClassEquipment:
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
      <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;Staff&quot;</span>:
        staffWielders[class] = items <span class="hljs-comment">#`table.add key, value` is now deprecated(marked for future removal)</span>

  <span class="hljs-keyword">echo</span> staffWielders

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **`collect` version:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> staffWieldersCollect = collect:
    <span class="hljs-keyword">for</span> class, items <span class="hljs-keyword">in</span> characterClassEquipment:
      <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;Staff&quot;</span>:
          {class: items} <span class="hljs-comment">#Kind of bizzare way of returning</span>
  
  <span class="hljs-keyword">echo</span> staffWieldersCollect

nbSection <span class="hljs-string">&quot;Performance Benchmarks&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now i will show you performance benchmarks of 3 variants of making a new list,
  in both Python and Nim. This is NOT a benchmark of the languages.
  This is only meant to see the difference of the 3 variants.

  My relevant computer specs used for this benchmark:
  - **CPU**: Ryzen 2700x
  - **RAM**: G.Skill Ripjaws V 16GB (2x8GB) DDR4 F4-3200C16D-16GVKB

  The 3 variants are as follow:
  - **add** and **append**
  - **index** - **[]**
  - **collect** and **list comprehension**

  All 3 variants of the 2 versions of Nim and Python,
  create a new list by filling a pre-initialized to size 10000 sequence/array,
  with arbitrary data, that is then benchmarked 10000 times,
  in order to account for slight variations that occur.
  The resulting time elapsed is then divided back by 10000,
  to get the mostly correct/aproximate time elapsed for our variations.

  This is eased for Nim by the usage of a custom template,
  while Python has an official module specifically for this purpose.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Nim's 3 variants&quot;</span>
nbCodeSkip: <span class="hljs-comment">#Skip - No benching when writting the script!</span>
  <span class="hljs-keyword">import</span> std/times, std/os, std/strutils, std/sequtils, std/sugar

  <span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, timesToRun: <span class="hljs-built_in">int</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = cpuTime()

      <span class="hljs-keyword">for</span> run <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.timesToRun:
        code

      <span class="hljs-keyword">let</span> elapsed = cpuTime() - t0
      <span class="hljs-keyword">let</span> elapsedProcessed = elapsed / timesToRun
      <span class="hljs-keyword">let</span> elapsedProcessedStr = elapsedProcessed.formatFloat(format = ffDecimal, precision = <span class="hljs-number">12</span>)
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] x &quot;</span>, timesToRun, <span class="hljs-string">&quot; = &quot;</span>, elapsedProcessedStr, <span class="hljs-string">&quot;s&quot;</span>

  benchmark <span class="hljs-string">&quot;add    &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>
    <span class="hljs-keyword">var</span> list: <span class="hljs-built_in">seq</span>[num.typeof]

    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
      list.add j

  benchmark <span class="hljs-string">&quot;index  &quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-comment">#Initializing a seq of 10000 ups the time by about 3x</span>
    <span class="hljs-keyword">var</span> list = newSeqWith(num, <span class="hljs-number">0</span>) <span class="hljs-comment">#size, default value</span>

    <span class="hljs-keyword">for</span> index, ele <span class="hljs-keyword">in</span> list.pairs:
      list[index] = index

  benchmark <span class="hljs-string">&quot;collect&quot;</span>, <span class="hljs-number">10000</span>:
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">10000</span>

    <span class="hljs-keyword">var</span> list = collect:
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.num:
        i
<span class="hljs-comment">#Using template for Python because i don't wanna wait for the benches when writting the script!</span>
nbPythonShowOnlyOutput: <span class="hljs-string">&quot;&quot;&quot; 
CPU Time [add    ] x 10000 = 0.000166400000s
CPU Time [index  ] x 10000 = 0.000138800000s
CPU Time [collect] x 10000 = 0.000165400000s
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Python's 3 variants&quot;</span>
nbPythonShowOnlyCode: <span class="hljs-string">hlPy&quot;&quot;&quot;
  from timeit import timeit

  def fAppend():
      num = 10000
      li = []
      for i in range(num):
          li.append(i)

  def fIndex():
      num = 10000
      li = [0] * num
      for i in range(num):
          li[i] = i

  def fLComprehension():
      num = 10000
      li = [i for i in range(num)]

  def main(x):
      print(timeit(stmt = fAppend, number = x) / x)
      print(timeit(stmt = fIndex, number = x) / x)
      print(timeit(stmt = fLComprehension, number = x) / x)

  main(10000) 
&quot;&quot;&quot;</span>
nbPythonShowOnlyOutput: <span class="hljs-string">hlPy&quot;&quot;&quot;
  CPU Time [append       ] x 10000 = 0.00065512317
  CPU Time [index        ] x 10000 = 0.0003905595900000001
  CPU Time [comprehension] x 10000 = 0.0002650251300000001
&quot;&quot;&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
&lt;h6&gt;(You may run the above benchmarks yourself to double check the data. 
But the results will vary by your CPU and RAM speeds.)&lt;/h6&gt;
&quot;&quot;&quot;</span>

nbUoSection <span class="hljs-string">&quot;Outro - Afterwords&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also follow me on twitter of the same name, and support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of offline tutorial.
&quot;&quot;&quot;</span>
nbUoSection <span class="hljs-string">&quot;Thanks to my past and current Patrons&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Past Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Current Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- jaap groot (from October 2023)
- Dimitri Lesnoff (from October 2023)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Compiler Information&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;My and General Links&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Links to this video's subject:&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Sugar module's collect macro](https://nim-lang.org/docs/sugar.html#collect.m%2Cuntyped &quot;sugar.collect&quot;)
- [Python's List Comprehensions](https://www.w3schools.com/python/python_lists_comprehension.asp &quot;Python's List Comprehensions&quot;)
- [Python's map() function](https://www.w3schools.com/python/ref_func_map.asp &quot;Python's map() function&quot;)
- [Python's filter() function](https://www.w3schools.com/python/ref_func_filter.asp &quot;Python's filter() function&quot;)
- [Python's benchmarking timeit module's timeit() function](https://docs.python.org/3/library/timeit.html &quot;Python's benchmarking timeit module's timeit() function&quot;)
- [Nim's formatFloat func](https://nim-lang.org/docs/strutils.html#formatFloat%2Cfloat%2CFloatFormatMode%2Crange%5B%5D%2Cchar &quot;Nim's formatFloat func&quot;)
- [Nim's cpuTime from the Times module](https://nim-lang.org/docs/times.html#cpuTime &quot;Nim's cpuTime from the Times module&quot;)
&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>