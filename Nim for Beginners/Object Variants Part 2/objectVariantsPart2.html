<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Nim for Beginners\Object Variants Part 2\objectVariantsPart2.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..\..">üè°</a></span>
  <span><code>Nim for Beginners\Object Variants Part 2\objectVariantsPart2.nim</code></span>
  <span><a href="https://github.com/Kiloneie/kiloneie.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle; fill: #fff" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ol>
<li><a href="#object-variants-vs-inheritance">Object Variants vs Inheritance</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#object-variants">Object Variants</a></li>
<li><a href="#child-a-to-child-b-conversion">Child A to Child B conversion</a></li>
<li><a href="#performance-comparison">Performance comparison</a></li>
<li><a href="#when-to-use-object-variants-vs-inheritance?">When to use Object Variants vs Inheritance?</a></li>
<li><a href="#extra-information">Extra Information</a></li>
</ol>
      <meta name = "viewport" content = "width=device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #myBtn {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }

      #myBtn:hover {background-color: #555;}
      </style>
      <body>

      <button onclick = "topFunction()" id = "myBtn" title = "Go to top">Top</button>

      <script>
      // Get the button
      let mybutton = document.getElementById("myBtn");

      // When the user scrolls down 20px from the top of the document, show the button
      window.onscroll = function() {scrollFunction()};

      function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
          mybutton.style.display = "block";
        } else {mybutton.style.display = "none";}
      }

      // When the user clicks on the button, scroll to the top of the document
      function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      }
      </script>
    
<h2>INTRO - GREETING</h2>
<p>Nim for Beginners: Object Variants Part 2</p>
<h2>INTRO - FOREWORDS</h2>
<p>(What is the purpose of this video ?) <br></p>
<p>In this video i will teach you about object variants, what they are and how to use them,
as well as compare them against objects with inheritance.</p>
<p>The code for this video and it's script/documentation styled with nimib,
is in the links in the description as a form of offline tutorial.</p>
<p><a name = "object-variants-vs-inheritance"></a></p>
<h1>Object Variants vs Inheritance</h1>
<hr />
<p>Object variants are always stored in memory in it's full size.
Now this allows object variants, variants of an object to be stored in containers such as sequences.
This also allows changing variants into other variants, which is NOT possible with inheritance.</p>
<p><a name = "inheritance"></a></p>
<h1>Inheritance</h1>
<hr />
<p>First of, we will &quot;import random&quot; for later use.
Then under a &quot;type&quot; section, we will make the parent of inheritance called EnemyI,
&quot;I&quot; affix for inheritance so we will be able to distinguish between inheritance code,
and object variance code later on. We will give this object &quot;x&quot; and &quot;y&quot; fields of type float,
as well as &quot;parent&quot; field of type &quot;EnemyI&quot;. This will make it so that any child of
the parent &quot;EnemyI&quot; will be able to have a parent, and then when the parent object
is added into a collection like a sequence along with it's child objects,
Nim will be able to determine which overloaded &quot;method&quot; statement to use at runtime,
when the program is running. More on that later.</p>
<p>Finally we will create the children &quot;BanditI&quot; and &quot;WolfI&quot; with &quot;attackMoves&quot;
as it's fields of type sequence of the appropriate enumerator.
<br><br>
So let's begin:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> random

<span class="hljs-keyword">type</span>
  <span class="hljs-type">EnemyI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
    x, y: <span class="hljs-built_in">float</span>
    parent: <span class="hljs-type">EnemyI</span> <span class="hljs-comment">#For dynamic dispatch of methods</span>

  <span class="hljs-type">HumanoidAttackMovesI</span> = <span class="hljs-keyword">enum</span>
    backstabI, eviscerateI

  <span class="hljs-type">AnimalAttackMovesI</span> = <span class="hljs-keyword">enum</span>
    biteI, clawI

  <span class="hljs-type">BanditI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">EnemyI</span> 
    attackMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesI</span>]

  <span class="hljs-type">WolfI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">EnemyI</span>
    attackMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesI</span>]</code></pre>
<p>Now here we are going to use &quot;methods&quot; over procs, because methods enable dynamic dispatch,
selecting the appropriate function(proc, method etc), at runtime, when the program is running,
instead of doing it at compile time with <b>procs</b>, when writting our code</p>
<ul>
<li>Methods require objects as parameters<br></li>
<li>Base methods should be BASE and as minimal as possible, in other words
the method using base pragma that targets the parent should be as minimal as possible<br></li>
<li>Base pragma is implicitly placed, but YOU should place it manually just in case<br></li>
<li>Pragmas in Nim are similar to the C programming language's pre-processor parameters,
they are used to change the behaviour of code to a different one.
There are many pragmas in Nim.</li>
</ul>
<p>When writting methods, procs, templates, etc, that only have a short bit of code,
we can write the code of that proc, method, etc, in the same line.
Now let's continue with methods with that in mind.<br></p>
<p>First let's write methods as constructors for our &quot;parent&quot; of EnemyI, BanditI and WolfI.
These constructors will be essentially useless because again, methods require objects
as parameters, so we can't give them the parameters we want to make creation of these
objects via constructors easier, object variants will be able to do that:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">EnemyI</span>): <span class="hljs-type">EnemyI</span> {.base.} = b
<span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">BanditI</span>): <span class="hljs-type">BanditI</span> {.base.} = b
<span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">WolfI</span>): <span class="hljs-type">WolfI</span> {.base.} = b</code></pre>
<p>Now we are going to make 3 methods for a hypothetical attack for all 3 objects.
First of AGAIN as i said above, the parent object, EnemyI requires it's attack method,
to be as barebones/simple as possible, because it's function in this code will be to
simply be a parent, it's child objects will have more functionality:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">EnemyI</span>): <span class="hljs-built_in">string</span> {.base.} = <span class="hljs-string">&quot;...&quot;</span>

<span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">BanditI</span>): <span class="hljs-built_in">string</span> =
  randomize() <span class="hljs-comment">#Unless you use randomize, every program run will result in the same random numbers</span>
  <span class="hljs-keyword">let</span> max = this.attackMoves.<span class="hljs-keyword">high</span>
  <span class="hljs-literal">result</span> = $this.attackMoves[rand(<span class="hljs-number">0.</span>.max)] <span class="hljs-comment">#0..max -&gt; so we don't make an illegal storage access</span></code></pre>
<p>Now we are going to copy paste the bandit's attackI method and simply change it's
parameter of BanditI to WolfI. By naming a proc/method and more, with the same name
we overload that method/proc. Overloading means that the compiler will determine which
of the same named overloaded procs/methods is to be used</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">WolfI</span>): <span class="hljs-built_in">string</span> =
  randomize()
  <span class="hljs-keyword">let</span> max = this.attackMoves.<span class="hljs-keyword">high</span>
  <span class="hljs-literal">result</span> = $this.attackMoves[rand(<span class="hljs-number">0.</span>.max)]</code></pre>
<p>Now we will make a variable that will use the parent object of EnemyI,
a sequence to store 100 of randomly picked and stored BanditI and WolfI objects,
as well as the parent object, and the display that sequence</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> overlordI = <span class="hljs-type">EnemyI</span>() <span class="hljs-comment">#Parent object</span>
<span class="hljs-keyword">var</span> enemiesI: <span class="hljs-built_in">seq</span>[<span class="hljs-type">EnemyI</span>]

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-number">99</span>:
  <span class="hljs-keyword">let</span> x = rand(<span class="hljs-number">0.</span>.<span class="hljs-number">1</span>)

  <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:
    enemiesI.add newEnemyI(<span class="hljs-type">BanditI</span>(x: e.toFloat, y: e.toFloat, attackMoves: @[backstabI], parent: overlordI))
  <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:
    enemiesI.add newEnemyI(<span class="hljs-type">WolfI</span>(x: e.toFloat, y: e.toFloat, attackMoves: @[biteI], parent: overlordI))</code></pre>
<p>Earlier we made a variable to use the parent object of EnemyI, now we are going to store
it into our sequence in order to satisfy/meet the requirements of dynamic dispatch</p>
<pre><code class="nohighlight hljs nim">enemiesI.add overlordI <span class="hljs-comment">#Used simply to meet the requirements of methods, otherwise we could use procs instead</span>

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> enemiesI:
  <span class="hljs-keyword">echo</span> e.attackI

<span class="hljs-comment">#Now let's run this. Okay it works, end of this section(nimib restriction)</span></code></pre><pre class="nb-output">backstabI
backstabI
backstabI
backstabI
backstabI
biteI
backstabI
backstabI
biteI
backstabI
biteI
biteI
biteI
backstabI
biteI
backstabI
biteI
biteI
biteI
biteI
biteI
backstabI
biteI
biteI
backstabI
backstabI
backstabI
biteI
backstabI
backstabI
backstabI
biteI
biteI
biteI
biteI
biteI
backstabI
backstabI
biteI
biteI
biteI
biteI
biteI
backstabI
backstabI
biteI
backstabI
backstabI
backstabI
biteI
biteI
biteI
biteI
biteI
backstabI
backstabI
biteI
backstabI
biteI
backstabI
biteI
backstabI
backstabI
backstabI
backstabI
backstabI
biteI
backstabI
backstabI
backstabI
backstabI
backstabI
backstabI
backstabI
biteI
biteI
biteI
biteI
backstabI
biteI
backstabI
biteI
backstabI
backstabI
backstabI
biteI
biteI
biteI
biteI
biteI
backstabI
biteI
biteI
backstabI
backstabI
biteI
backstabI
biteI
biteI
biteI
...</pre>
<p><a name = "object-variants"></a></p>
<h1>Object Variants</h1>
<hr />
<p>Now we are going to write the above code with <b>inheritance</b> and <b>methods</b>,
into a version that uses Object Variants and procs instead. We are going to mostly
copy paste what we wrote before, but without the inheritance part like
&quot;ref object of RootObj&quot; and change the affix of &quot;I&quot; when naming things into a &quot;V&quot;
for object variants, and NOT put the parent object into the sequence,
because it will not work, it will crash.<br></p>
<p>First of we are going to use the &quot;type&quot; section to make an enumerator named Enemies,
with &quot;bandit&quot; and &quot;wolf&quot; for it's enumerations just like we did for the attack moves
for the bandit and the wolf objects of inheritance above.
Also copy paste the enumerators for HumanoidAttackMoves and AnimalAttackMoves,
but with &quot;V&quot; for it's affix:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">Enemies</span> = <span class="hljs-keyword">enum</span>
    bandit, wolf

  <span class="hljs-type">HumanoidAttackMovesV</span> = <span class="hljs-keyword">enum</span>
    backstabV, eviscerateV

  <span class="hljs-type">AnimalAttackMovesV</span> = <span class="hljs-keyword">enum</span>
    biteV, clawV</code></pre>
<p>Now we will create our &quot;EnemyV&quot; object which will have 2 variants of itself,
instead of 2 children. To do this all we have to do is use our &quot;Enemies&quot; enumerator,
as a discriminator/selector in a case statement and then using different names
for the fields of the bandit and wolf attack moves. We must use unique field names,
because to Nim this code is still under the same object: EnemyV</p>
<p>(another &quot;type&quot; section is used here because of the &quot;nimib&quot; module restrictions,
which i am using to write the script/documentation of this video, and onwards from now on)</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">EnemyV</span> = <span class="hljs-keyword">object</span>
    x, y: <span class="hljs-built_in">float</span>

    <span class="hljs-keyword">case</span> kind: <span class="hljs-type">Enemies</span>
      <span class="hljs-keyword">of</span> bandit:
        attackMovesB: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesV</span>]
      <span class="hljs-keyword">of</span> wolf:
        attackMovesW: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesV</span>]</code></pre>
<p>Now let's create our constructors which unlike the ones we made and used for inheritance,
will actually make the construction of our objects a bit easier. We can give them
the parameters they require, so we will give them x, y and attack moves parameters,
and return a completed object with the &quot;result&quot; variable filled with our parameters
like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> newEnemyV(x, y: <span class="hljs-built_in">float</span>, aMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesV</span>]): <span class="hljs-type">EnemyV</span> =
  <span class="hljs-literal">result</span> = <span class="hljs-type">EnemyV</span>(x: x, y: y, kind: bandit, attackMovesB: aMoves)

<span class="hljs-keyword">proc</span> newEnemyV(x, y: <span class="hljs-built_in">float</span>, aMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesV</span>]): <span class="hljs-type">EnemyV</span> =
  <span class="hljs-literal">result</span> = <span class="hljs-type">EnemyV</span>(x: x, y: y, kind: wolf, attackMovesW: aMoves)</code></pre>
<p>Now we need to to make a proc that does what the 2 attack methods did for inheritance.
So instead of using 2 methods, with object variants we can simply use a &quot;case&quot; statement
instead. So let's copy paste the 2 methods and put them together into a single proc,
by using a &quot;case&quot; statement like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> attackV(this: <span class="hljs-type">EnemyV</span>): <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">case</span> this.kind:
    <span class="hljs-keyword">of</span> bandit:
      randomize()
      <span class="hljs-keyword">let</span> max = this.attackMovesB.<span class="hljs-keyword">high</span>
      <span class="hljs-literal">result</span> = $this.attackMovesB[rand(<span class="hljs-number">0.</span>.max)]
    <span class="hljs-keyword">of</span> wolf:
      randomize()
      <span class="hljs-keyword">let</span> max = this.attackMovesW.<span class="hljs-keyword">high</span>
      <span class="hljs-literal">result</span> = $this.attackMovesW[rand(<span class="hljs-number">0.</span>.max)]</code></pre>
<p>Now we make the sequence, fill it and display it like before, except that
we won't be adding the base object variant, EnemyV object without a kind field specified,
because it will crash our program, you can't mix the base object with it's variants.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> enemiesV: <span class="hljs-built_in">seq</span>[<span class="hljs-type">EnemyV</span>]

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-number">99</span>:
  <span class="hljs-keyword">let</span> x = rand(<span class="hljs-number">0.</span>.<span class="hljs-number">1</span>)

  <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:
    enemiesV.add newEnemyV(e.toFloat, e.toFloat, @[backstabV])
  <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:
    enemiesV.add newEnemyV(e.toFloat, e.toFloat, @[biteV])

<span class="hljs-keyword">var</span> overlordV = <span class="hljs-type">EnemyV</span>()
<span class="hljs-comment">#[ enemiesV.add overlordV ]#</span> <span class="hljs-comment">#This will crash, overlord.attackV ...</span>

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> enemiesV:
  <span class="hljs-keyword">echo</span> e.attackV</code></pre><pre class="nb-output">biteV
biteV
biteV
backstabV
backstabV
backstabV
biteV
biteV
backstabV
biteV
backstabV
biteV
biteV
backstabV
backstabV
backstabV
biteV
biteV
backstabV
backstabV
biteV
biteV
backstabV
backstabV
biteV
biteV
biteV
backstabV
biteV
biteV
biteV
backstabV
backstabV
biteV
biteV
backstabV
biteV
backstabV
backstabV
biteV
backstabV
backstabV
biteV
backstabV
backstabV
backstabV
biteV
biteV
biteV
backstabV
biteV
biteV
backstabV
biteV
biteV
biteV
backstabV
biteV
backstabV
backstabV
biteV
biteV
biteV
biteV
biteV
backstabV
backstabV
backstabV
biteV
biteV
biteV
backstabV
backstabV
backstabV
biteV
biteV
backstabV
biteV
biteV
backstabV
backstabV
backstabV
biteV
backstabV
biteV
biteV
backstabV
backstabV
backstabV
backstabV
biteV
biteV
backstabV
biteV
biteV
biteV
backstabV
backstabV
backstabV
backstabV</pre>
<p><a name = "child-a-to-child-b-conversion"></a></p>
<h1>Child A to Child B conversion</h1>
<hr />
<p>Both object variants and inheritance allow for variant to base and child to parent,
and vice versa conversion, but only <b>object variants</b> allow for variant to variant
conversion. Inheritance does not allow this.</p>
<p><b>Variant to variant conversion</b><br>
I will demonstrate this with a simpler than above example like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">VariantEnemies</span> = <span class="hljs-keyword">enum</span>
    outlaw, spider

  <span class="hljs-type">VariantEnemy</span> = <span class="hljs-keyword">object</span>
    x, y: <span class="hljs-built_in">float</span>

    <span class="hljs-keyword">case</span> kind: <span class="hljs-type">VariantEnemies</span>
      <span class="hljs-keyword">of</span> outlaw:
        stealth: <span class="hljs-built_in">bool</span>
      <span class="hljs-keyword">of</span> spider:
        poisonous: <span class="hljs-built_in">bool</span>

<span class="hljs-keyword">var</span> o = <span class="hljs-type">VariantEnemy</span>(kind: outlaw)
<span class="hljs-keyword">var</span> s = <span class="hljs-type">VariantEnemy</span>(kind: spider)

o = s <span class="hljs-comment">#Variant to variant conversion</span>
<span class="hljs-keyword">echo</span> s

<span class="hljs-comment">#Variant to base conversion</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-type">VariantEnemy</span>()
<span class="hljs-keyword">echo</span> b

b = s
<span class="hljs-keyword">echo</span> o</code></pre><pre class="nb-output">(x: 0.0, y: 0.0, kind: spider, poisonous: false)
(x: 0.0, y: 0.0, kind: outlaw, stealth: false)
(x: 0.0, y: 0.0, kind: spider, poisonous: false)</pre>
<p>As you can see the output of the base object is a variant of kind &quot;outlaw&quot;, that is
because the default value of &quot;kind&quot; is 0, and 0 is also the integer value of &quot;outlaw&quot;
enumeration. So conversion between variants and the base object with no kind,
works perfectly.</p>
<p><b>Child to child conversion</b><br></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">ChildEnemy</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
    x, y: <span class="hljs-built_in">float</span>

  <span class="hljs-type">Outlaw</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">ChildEnemy</span>
    stealth: <span class="hljs-built_in">bool</span>

  <span class="hljs-type">Spider</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">ChildEnemy</span>
    poisonous: <span class="hljs-built_in">bool</span>

<span class="hljs-keyword">var</span> oI = <span class="hljs-type">Outlaw</span>()
<span class="hljs-keyword">var</span> oI2: <span class="hljs-type">ChildEnemy</span> = <span class="hljs-type">Outlaw</span>(stealth: <span class="hljs-literal">true</span>)
<span class="hljs-keyword">var</span> sI = <span class="hljs-type">Spider</span>() <span class="hljs-comment">#Must include :ParentName for child to parent and reverse, conversion</span></code></pre>
<p>Now that we got our definitions and variables set, i will demonstrate that
well child to child conversion for normal objects and inheritance is possible,
but only on a quick glance. The conversion is only possible if a variable is first
defined as the parent and then given the values of one of it's child objects,
like &quot;oI2&quot;. All this does is, fill the values of the object's fields and nothing more.
So let's echo both our outlaw variables to see their details:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> oI[], <span class="hljs-string">&quot; &quot;</span>, oI.<span class="hljs-keyword">type</span>
<span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span></code></pre><pre class="nb-output">(stealth: false, x: 0.0, y: 0.0) Outlaw
(x: 0.0, y: 0.0) ChildEnemy</pre>
<p>As you can see &quot;oI&quot; is of type &quot;outlaw&quot;, but &quot;oI2&quot; is of type ChildEnemy.
Again, like i said this is no a real conversion, it just fills the fields that are
compatible, both have.</p>
<p>Now let's try converting &quot;oI2&quot; to type Spider()</p>
<pre><code class="nohighlight hljs nim">oI2 = <span class="hljs-type">Spider</span>(oI2)
<span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span></code></pre><pre class="nb-output">(x: 0.0, y: 0.0) ChildEnemy</pre>
<p>Make sure you are using compiler setting of --gc:orc in the config.nims file,
otherwise with the currently default refc garbage collector soon to be replaced with gc:orc,
you will get an object conversion error.</p>
<p>Now let's run this:<br>
As you can see nothing happened, outlaw2(oI2(inheritance)) is still of type ChildEnemy,
because child to child conversion is not possible.
Only child to parent and parent to child conversion is possible.</p>
<p>Now lastly let's try the child to parent conversion</p>
<pre><code class="nohighlight hljs nim">oI2 = <span class="hljs-type">ChildEnemy</span>(oI2) <span class="hljs-comment">#Only child to parent and back is actually possible</span>
<span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span></code></pre><pre class="nb-output">(x: 0.0, y: 0.0) ChildEnemy</pre>
<p>As i said earlier in this section, since we made &quot;oI2&quot; as ChildEnemy first,
and given it it's empty value of Outlaw(), it remained of type ChildEnemy.
No real/actual conversion for inheritance is possible.
Even the compiler will tell you that(try it).</p>
<p>There is a way to do this though, by using &quot;casts&quot;, but that is the subject of another
video, casts in super short version are basically a &quot;view&quot; into another data type,
they are also considered unsafe, meaning you could easily cause problems with incorrect
usage.</p>
<p><b>Storing into containers</b><br>
As i have shown earlier, object variants have a problem with storing it's &quot;base&quot;,
object along with it's variants into containers such as sequences, but inheritance
does not have that problem. Though i do not see a reason why one would need to do this.</p>
<p><a name = "performance-comparison"></a></p>
<h1>Performance comparison</h1>
<hr />
<p>Object variants are faster:
Inheritance works best with refs(and ptr), at this point inheritance should be very fast,
probably even faster than object variants, but then you are required to use methods.
Methods are dynamic dispatch and it is slow,
therefore with a complex Parent - Child hierarchy, you will have many methods,
and with many method calls, it will be much slower than object variants with procs.</p>
<p>Here in the following link are the results of a performance profiler program called
<b>valgrind:</b> that i used to get performance results from the earlier object variants
vs inheritance code.<br><br>
<b>Performance comparison:</b> <a href="https://postimg.cc/rRz2dHFf" title="Callgrind results on the left and cachegrind results on the right">Valgrind</a>
<br>
(i forgot to remove the screenshoting program from the screenshot)</p>
<p><a name = "when-to-use-object-variants-vs-inheritance?"></a></p>
<h1>When to use Object Variants vs Inheritance?</h1>
<hr />
<p>Use methods if you want unbounded polymorphism,
(can add new logic/functionality without having to go update a master list of things,
useful if you're expecting to be adding new things all the time,
or if you're making a library and want users to be able to make their own kinds)
otherwise use object variants.</p>
<p>Procs use static dispatch, compiler will match a proc to the FIRST matching object call.
With inheritance if the first appropriate match is the parent,
all of it's children's calls will be ignored, the parent's call will be used instead.</p>
<p>Dynamic dispatch is achieved with methods, the matching will be done at run-time,
allowing more flexibility at the cost of performance. Methods will not stop at the
parent of inheritance, but find the most appropriate matching child.</p>
<p><a name = "extra-information"></a></p>
<h1>Extra Information</h1>
<hr />
<p><b>Explanation of base pragma:</b><br>
Base is like virtual in C++.
It marks that a method can be overloaded in subclasses and dynamically dispatched.
First, dynamic dispatching pretty much requires ref,
because it requires a situation where the runtime type of the object isn't known at compile time.
The pragma seems to be inserted implicitly.</p>
<p>Base pragma was required back when Nim had multi methods.
Now it's still useful, C# uses an explicit &quot;override&quot; keyword to override methods,
override in Nim is the default, but the downside is that &quot;base&quot; methods have to be annotated.</p>
<h2>OUTRO - AFTERWORDS</h2>
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it,
you can also follow me on twitter of the same name, and support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code for this video will be from now on inside the script/documentation
page styled with nimib, as a form of offline tutorial,
the link is in the description, have fun.</p>
<h3>Thanks to my past and current Patrons</h3>
<p><b>Past Patrons:</b></p>
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei</li>
</ul>
<p><b>Current Patrons</b></p>
<ul>
<li>None</li>
</ul>
<p><b>Compiler information</b></p>
<ul>
<li>Version used: E.G. 1.6.8</li>
<li>Compiler settings used: --gc:orc</li>
<li>Timestamps:
<ul>
<li>00:15 Start of video example</li>
</ul>
</li>
</ul>
<p><b>LINKS:</b></p>
<ul>
<li><a href="https://twitter.com/Kiloneie" title="My Twitter">Twitter</a></li>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li>Video's script/documentation styled with nimib as a form of offline tutorial:</li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<p><b>LINKS to this video's subject:</b></p>
<ul>
<li><a href="https://nim-lang.org/docs/manual.html#types-object-variants" title="Object Variants">Object Variants</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-keyword">import</span> nimib, std/strutils <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>
nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> 
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection</span>

<span class="hljs-keyword">template</span> nbSubSection(name:<span class="hljs-built_in">string</span>) =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width=device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #myBtn {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }

      #myBtn:hover {background-color: #555;}
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;myBtn&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
      // Get the button
      let mybutton = document.getElementById(&quot;myBtn&quot;);

      // When the user scrolls down 20px from the top of the document, show the button
      window.onscroll = function() {scrollFunction()};

      function scrollFunction() {
        if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
          mybutton.style.display = &quot;block&quot;;
        } else {mybutton.style.display = &quot;none&quot;;}
      }

      // When the user clicks on the button, scroll to the top of the document
      function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Do NOT forget to have the .html file OPEN at all times, otherwise </span>
  <span class="hljs-comment">#live preview will NOT work! ANY live preview!</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
## INTRO - GREETING
Nim for Beginners: Object Variants Part 2
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
## INTRO - FOREWORDS
(What is the purpose of this video ?) &lt;br&gt;

In this video i will teach you about object variants, what they are and how to use them,
as well as compare them against objects with inheritance.

The code for this video and it's script/documentation styled with nimib,
is in the links in the description as a form of offline tutorial.

&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Object Variants vs Inheritance&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Object variants are always stored in memory in it's full size.
Now this allows object variants, variants of an object to be stored in containers such as sequences.
This also allows changing variants into other variants, which is NOT possible with inheritance. 
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Inheritance&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
First of, we will &quot;import random&quot; for later use.
Then under a &quot;type&quot; section, we will make the parent of inheritance called EnemyI,
&quot;I&quot; affix for inheritance so we will be able to distinguish between inheritance code,
and object variance code later on. We will give this object &quot;x&quot; and &quot;y&quot; fields of type float,
as well as &quot;parent&quot; field of type &quot;EnemyI&quot;. This will make it so that any child of
the parent &quot;EnemyI&quot; will be able to have a parent, and then when the parent object
is added into a collection like a sequence along with it's child objects,
Nim will be able to determine which overloaded &quot;method&quot; statement to use at runtime,
when the program is running. More on that later.

Finally we will create the children &quot;BanditI&quot; and &quot;WolfI&quot; with &quot;attackMoves&quot;
as it's fields of type sequence of the appropriate enumerator.
&lt;br&gt;&lt;br&gt;
So let's begin:

&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">import</span> random

  <span class="hljs-keyword">type</span>
    <span class="hljs-type">EnemyI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      x, y: <span class="hljs-built_in">float</span>
      parent: <span class="hljs-type">EnemyI</span> <span class="hljs-comment">#For dynamic dispatch of methods</span>

    <span class="hljs-type">HumanoidAttackMovesI</span> = <span class="hljs-keyword">enum</span>
      backstabI, eviscerateI

    <span class="hljs-type">AnimalAttackMovesI</span> = <span class="hljs-keyword">enum</span>
      biteI, clawI

    <span class="hljs-type">BanditI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">EnemyI</span> 
      attackMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesI</span>]

    <span class="hljs-type">WolfI</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">EnemyI</span>
      attackMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesI</span>]

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now here we are going to use &quot;methods&quot; over procs, because methods enable dynamic dispatch,
selecting the appropriate function(proc, method etc), at runtime, when the program is running,
instead of doing it at compile time with &lt;b&gt;procs&lt;/b&gt;, when writting our code
- Methods require objects as parameters&lt;br&gt;
- Base methods should be BASE and as minimal as possible, in other words
  the method using base pragma that targets the parent should be as minimal as possible&lt;br&gt;
- Base pragma is implicitly placed, but YOU should place it manually just in case&lt;br&gt;
- Pragmas in Nim are similar to the C programming language's pre-processor parameters,
  they are used to change the behaviour of code to a different one. 
  There are many pragmas in Nim.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
When writting methods, procs, templates, etc, that only have a short bit of code,
we can write the code of that proc, method, etc, in the same line.
Now let's continue with methods with that in mind.&lt;br&gt;

First let's write methods as constructors for our &quot;parent&quot; of EnemyI, BanditI and WolfI.
These constructors will be essentially useless because again, methods require objects
as parameters, so we can't give them the parameters we want to make creation of these
objects via constructors easier, object variants will be able to do that:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">EnemyI</span>): <span class="hljs-type">EnemyI</span> {.base.} = b
  <span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">BanditI</span>): <span class="hljs-type">BanditI</span> {.base.} = b
  <span class="hljs-keyword">method</span> newEnemyI(b: <span class="hljs-type">WolfI</span>): <span class="hljs-type">WolfI</span> {.base.} = b

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we are going to make 3 methods for a hypothetical attack for all 3 objects.
First of AGAIN as i said above, the parent object, EnemyI requires it's attack method,
to be as barebones/simple as possible, because it's function in this code will be to
simply be a parent, it's child objects will have more functionality: 
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">EnemyI</span>): <span class="hljs-built_in">string</span> {.base.} = <span class="hljs-string">&quot;...&quot;</span>

  <span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">BanditI</span>): <span class="hljs-built_in">string</span> =
    randomize() <span class="hljs-comment">#Unless you use randomize, every program run will result in the same random numbers</span>
    <span class="hljs-keyword">let</span> max = this.attackMoves.<span class="hljs-keyword">high</span>
    <span class="hljs-literal">result</span> = $this.attackMoves[rand(<span class="hljs-number">0.</span>.max)] <span class="hljs-comment">#0..max -&gt; so we don't make an illegal storage access</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we are going to copy paste the bandit's attackI method and simply change it's
parameter of BanditI to WolfI. By naming a proc/method and more, with the same name
we overload that method/proc. Overloading means that the compiler will determine which
of the same named overloaded procs/methods is to be used
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">method</span> attackI(this: <span class="hljs-type">WolfI</span>): <span class="hljs-built_in">string</span> =
    randomize()
    <span class="hljs-keyword">let</span> max = this.attackMoves.<span class="hljs-keyword">high</span>
    <span class="hljs-literal">result</span> = $this.attackMoves[rand(<span class="hljs-number">0.</span>.max)]

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we will make a variable that will use the parent object of EnemyI,
a sequence to store 100 of randomly picked and stored BanditI and WolfI objects,
as well as the parent object, and the display that sequence
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">var</span> overlordI = <span class="hljs-type">EnemyI</span>() <span class="hljs-comment">#Parent object</span>
  <span class="hljs-keyword">var</span> enemiesI: <span class="hljs-built_in">seq</span>[<span class="hljs-type">EnemyI</span>]

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-number">99</span>:
    <span class="hljs-keyword">let</span> x = rand(<span class="hljs-number">0.</span>.<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:
      enemiesI.add newEnemyI(<span class="hljs-type">BanditI</span>(x: e.toFloat, y: e.toFloat, attackMoves: @[backstabI], parent: overlordI))
    <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:
      enemiesI.add newEnemyI(<span class="hljs-type">WolfI</span>(x: e.toFloat, y: e.toFloat, attackMoves: @[biteI], parent: overlordI))

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Earlier we made a variable to use the parent object of EnemyI, now we are going to store
it into our sequence in order to satisfy/meet the requirements of dynamic dispatch
&quot;&quot;&quot;</span>

nbCode:
  enemiesI.add overlordI <span class="hljs-comment">#Used simply to meet the requirements of methods, otherwise we could use procs instead</span>

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> enemiesI:
    <span class="hljs-keyword">echo</span> e.attackI

  <span class="hljs-comment">#Now let's run this. Okay it works, end of this section(nimib restriction)</span>

nbSection <span class="hljs-string">&quot;Object Variants&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we are going to write the above code with &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;methods&lt;/b&gt;,
into a version that uses Object Variants and procs instead. We are going to mostly
copy paste what we wrote before, but without the inheritance part like 
&quot;ref object of RootObj&quot; and change the affix of &quot;I&quot; when naming things into a &quot;V&quot;
for object variants, and NOT put the parent object into the sequence,
because it will not work, it will crash.&lt;br&gt;

First of we are going to use the &quot;type&quot; section to make an enumerator named Enemies,
with &quot;bandit&quot; and &quot;wolf&quot; for it's enumerations just like we did for the attack moves
for the bandit and the wolf objects of inheritance above.
Also copy paste the enumerators for HumanoidAttackMoves and AnimalAttackMoves,
but with &quot;V&quot; for it's affix:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Enemies</span> = <span class="hljs-keyword">enum</span>
      bandit, wolf

    <span class="hljs-type">HumanoidAttackMovesV</span> = <span class="hljs-keyword">enum</span>
      backstabV, eviscerateV

    <span class="hljs-type">AnimalAttackMovesV</span> = <span class="hljs-keyword">enum</span>
      biteV, clawV

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we will create our &quot;EnemyV&quot; object which will have 2 variants of itself,
instead of 2 children. To do this all we have to do is use our &quot;Enemies&quot; enumerator,
as a discriminator/selector in a case statement and then using different names
for the fields of the bandit and wolf attack moves. We must use unique field names,
because to Nim this code is still under the same object: EnemyV

(another &quot;type&quot; section is used here because of the &quot;nimib&quot; module restrictions,
which i am using to write the script/documentation of this video, and onwards from now on)

&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">EnemyV</span> = <span class="hljs-keyword">object</span>
      x, y: <span class="hljs-built_in">float</span>

      <span class="hljs-keyword">case</span> kind: <span class="hljs-type">Enemies</span>
        <span class="hljs-keyword">of</span> bandit:
          attackMovesB: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesV</span>]
        <span class="hljs-keyword">of</span> wolf:
          attackMovesW: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesV</span>]

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now let's create our constructors which unlike the ones we made and used for inheritance,
will actually make the construction of our objects a bit easier. We can give them 
the parameters they require, so we will give them x, y and attack moves parameters,
and return a completed object with the &quot;result&quot; variable filled with our parameters
like this:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> newEnemyV(x, y: <span class="hljs-built_in">float</span>, aMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">HumanoidAttackMovesV</span>]): <span class="hljs-type">EnemyV</span> =
    <span class="hljs-literal">result</span> = <span class="hljs-type">EnemyV</span>(x: x, y: y, kind: bandit, attackMovesB: aMoves)

  <span class="hljs-keyword">proc</span> newEnemyV(x, y: <span class="hljs-built_in">float</span>, aMoves: <span class="hljs-built_in">seq</span>[<span class="hljs-type">AnimalAttackMovesV</span>]): <span class="hljs-type">EnemyV</span> =
    <span class="hljs-literal">result</span> = <span class="hljs-type">EnemyV</span>(x: x, y: y, kind: wolf, attackMovesW: aMoves)

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we need to to make a proc that does what the 2 attack methods did for inheritance.
So instead of using 2 methods, with object variants we can simply use a &quot;case&quot; statement
instead. So let's copy paste the 2 methods and put them together into a single proc,
by using a &quot;case&quot; statement like this:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> attackV(this: <span class="hljs-type">EnemyV</span>): <span class="hljs-built_in">string</span> =
    <span class="hljs-keyword">case</span> this.kind:
      <span class="hljs-keyword">of</span> bandit:
        randomize()
        <span class="hljs-keyword">let</span> max = this.attackMovesB.<span class="hljs-keyword">high</span>
        <span class="hljs-literal">result</span> = $this.attackMovesB[rand(<span class="hljs-number">0.</span>.max)]
      <span class="hljs-keyword">of</span> wolf:
        randomize()
        <span class="hljs-keyword">let</span> max = this.attackMovesW.<span class="hljs-keyword">high</span>
        <span class="hljs-literal">result</span> = $this.attackMovesW[rand(<span class="hljs-number">0.</span>.max)]

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now we make the sequence, fill it and display it like before, except that
we won't be adding the base object variant, EnemyV object without a kind field specified,
because it will crash our program, you can't mix the base object with it's variants.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">var</span> enemiesV: <span class="hljs-built_in">seq</span>[<span class="hljs-type">EnemyV</span>]

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-number">99</span>:
    <span class="hljs-keyword">let</span> x = rand(<span class="hljs-number">0.</span>.<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:
      enemiesV.add newEnemyV(e.toFloat, e.toFloat, @[backstabV])
    <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:
      enemiesV.add newEnemyV(e.toFloat, e.toFloat, @[biteV])

  <span class="hljs-keyword">var</span> overlordV = <span class="hljs-type">EnemyV</span>()
  <span class="hljs-comment">#[ enemiesV.add overlordV ]#</span> <span class="hljs-comment">#This will crash, overlord.attackV ...</span>

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> enemiesV:
    <span class="hljs-keyword">echo</span> e.attackV

nbSection <span class="hljs-string">&quot;Child A to Child B conversion&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Both object variants and inheritance allow for variant to base and child to parent,
and vice versa conversion, but only &lt;b&gt;object variants&lt;/b&gt; allow for variant to variant
conversion. Inheritance does not allow this.

&lt;b&gt;Variant to variant conversion&lt;/b&gt;&lt;br&gt;
I will demonstrate this with a simpler than above example like this:

&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">VariantEnemies</span> = <span class="hljs-keyword">enum</span>
      outlaw, spider

    <span class="hljs-type">VariantEnemy</span> = <span class="hljs-keyword">object</span>
      x, y: <span class="hljs-built_in">float</span>

      <span class="hljs-keyword">case</span> kind: <span class="hljs-type">VariantEnemies</span>
        <span class="hljs-keyword">of</span> outlaw:
          stealth: <span class="hljs-built_in">bool</span>
        <span class="hljs-keyword">of</span> spider:
          poisonous: <span class="hljs-built_in">bool</span>

  <span class="hljs-keyword">var</span> o = <span class="hljs-type">VariantEnemy</span>(kind: outlaw)
  <span class="hljs-keyword">var</span> s = <span class="hljs-type">VariantEnemy</span>(kind: spider)

  o = s <span class="hljs-comment">#Variant to variant conversion</span>
  <span class="hljs-keyword">echo</span> s

  <span class="hljs-comment">#Variant to base conversion</span>
  <span class="hljs-keyword">var</span> b = <span class="hljs-type">VariantEnemy</span>()
  <span class="hljs-keyword">echo</span> b

  b = s
  <span class="hljs-keyword">echo</span> o 

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
As you can see the output of the base object is a variant of kind &quot;outlaw&quot;, that is
because the default value of &quot;kind&quot; is 0, and 0 is also the integer value of &quot;outlaw&quot;
enumeration. So conversion between variants and the base object with no kind,
works perfectly.  
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;

&lt;b&gt;Child to child conversion&lt;/b&gt;&lt;br&gt;

&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">ChildEnemy</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      x, y: <span class="hljs-built_in">float</span>

    <span class="hljs-type">Outlaw</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">ChildEnemy</span>
      stealth: <span class="hljs-built_in">bool</span>

    <span class="hljs-type">Spider</span> = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">ChildEnemy</span>
      poisonous: <span class="hljs-built_in">bool</span>

  <span class="hljs-keyword">var</span> oI = <span class="hljs-type">Outlaw</span>()
  <span class="hljs-keyword">var</span> oI2: <span class="hljs-type">ChildEnemy</span> = <span class="hljs-type">Outlaw</span>(stealth: <span class="hljs-literal">true</span>)
  <span class="hljs-keyword">var</span> sI = <span class="hljs-type">Spider</span>() <span class="hljs-comment">#Must include :ParentName for child to parent and reverse, conversion</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Now that we got our definitions and variables set, i will demonstrate that
well child to child conversion for normal objects and inheritance is possible,
but only on a quick glance. The conversion is only possible if a variable is first
defined as the parent and then given the values of one of it's child objects,
like &quot;oI2&quot;. All this does is, fill the values of the object's fields and nothing more.
So let's echo both our outlaw variables to see their details:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">echo</span> oI[], <span class="hljs-string">&quot; &quot;</span>, oI.<span class="hljs-keyword">type</span>
  <span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
As you can see &quot;oI&quot; is of type &quot;outlaw&quot;, but &quot;oI2&quot; is of type ChildEnemy.
Again, like i said this is no a real conversion, it just fills the fields that are
compatible, both have.

Now let's try converting &quot;oI2&quot; to type Spider()
&quot;&quot;&quot;</span>

nbCode:
  oI2 = <span class="hljs-type">Spider</span>(oI2)
  <span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Make sure you are using compiler setting of --gc:orc in the config.nims file,
otherwise with the currently default refc garbage collector soon to be replaced with gc:orc,
you will get an object conversion error.

Now let's run this:&lt;br&gt;
As you can see nothing happened, outlaw2(oI2(inheritance)) is still of type ChildEnemy,
because child to child conversion is not possible.
Only child to parent and parent to child conversion is possible.

Now lastly let's try the child to parent conversion
&quot;&quot;&quot;</span>

nbCode:
  oI2 = <span class="hljs-type">ChildEnemy</span>(oI2) <span class="hljs-comment">#Only child to parent and back is actually possible</span>
  <span class="hljs-keyword">echo</span> oI2[], <span class="hljs-string">&quot; &quot;</span>, oI2.<span class="hljs-keyword">type</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
As i said earlier in this section, since we made &quot;oI2&quot; as ChildEnemy first,
and given it it's empty value of Outlaw(), it remained of type ChildEnemy.
No real/actual conversion for inheritance is possible.
Even the compiler will tell you that(try it).

There is a way to do this though, by using &quot;casts&quot;, but that is the subject of another
video, casts in super short version are basically a &quot;view&quot; into another data type,
they are also considered unsafe, meaning you could easily cause problems with incorrect
usage.
&quot;&quot;&quot;</span>


nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;

&lt;b&gt;Storing into containers&lt;/b&gt;&lt;br&gt;
As i have shown earlier, object variants have a problem with storing it's &quot;base&quot;,
object along with it's variants into containers such as sequences, but inheritance
does not have that problem. Though i do not see a reason why one would need to do this.

&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Performance comparison&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Object variants are faster:
Inheritance works best with refs(and ptr), at this point inheritance should be very fast,
probably even faster than object variants, but then you are required to use methods.
Methods are dynamic dispatch and it is slow,
therefore with a complex Parent - Child hierarchy, you will have many methods,
and with many method calls, it will be much slower than object variants with procs.

Here in the following link are the results of a performance profiler program called
&lt;b&gt;valgrind:&lt;/b&gt; that i used to get performance results from the earlier object variants
vs inheritance code.&lt;br&gt;&lt;br&gt; 
&lt;b&gt;Performance comparison:&lt;/b&gt; [Valgrind](https://postimg.cc/rRz2dHFf &quot;Callgrind results on the left and cachegrind results on the right&quot;) 
&lt;br&gt;
(i forgot to remove the screenshoting program from the screenshot)


&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;When to use Object Variants vs Inheritance?&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
Use methods if you want unbounded polymorphism, 
(can add new logic/functionality without having to go update a master list of things, 
useful if you're expecting to be adding new things all the time, 
or if you're making a library and want users to be able to make their own kinds)
otherwise use object variants.

Procs use static dispatch, compiler will match a proc to the FIRST matching object call. 
With inheritance if the first appropriate match is the parent, 
all of it's children's calls will be ignored, the parent's call will be used instead.

Dynamic dispatch is achieved with methods, the matching will be done at run-time, 
allowing more flexibility at the cost of performance. Methods will not stop at the 
parent of inheritance, but find the most appropriate matching child.

&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Extra Information&quot;</span>
nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;

&lt;b&gt;Explanation of base pragma:&lt;/b&gt;&lt;br&gt; 
Base is like virtual in C++. 
It marks that a method can be overloaded in subclasses and dynamically dispatched.
First, dynamic dispatching pretty much requires ref, 
because it requires a situation where the runtime type of the object isn't known at compile time.
The pragma seems to be inserted implicitly.

Base pragma was required back when Nim had multi methods. 
Now it's still useful, C# uses an explicit &quot;override&quot; keyword to override methods, 
override in Nim is the default, but the downside is that &quot;base&quot; methods have to be annotated.

&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMdf&quot;&quot;&quot;
## OUTRO - AFTERWORDS

  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it, 
    you can also follow me on twitter of the same name, and support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code for this video will be from now on inside the script/documentation
    page styled with nimib, as a form of offline tutorial, 
    the link is in the description, have fun.

### Thanks to my past and current Patrons
&lt;b&gt;Past Patrons:&lt;/b&gt;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei

&lt;b&gt;Current Patrons&lt;/b&gt;
- None

&lt;b&gt;Compiler information&lt;/b&gt;
- Version used: E.G. 1.6.8
- Compiler settings used: --gc:orc
- Timestamps:
  - 00:15 Start of video example


&lt;b&gt;LINKS:&lt;/b&gt;
- [Twitter](https://twitter.com/Kiloneie &quot;My Twitter&quot;)
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- Video's script/documentation styled with nimib as a form of offline tutorial:
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)

&lt;b&gt;LINKS to this video's subject:&lt;/b&gt;
- [Object Variants](https://nim-lang.org/docs/manual.html#types-object-variants &quot;Object Variants&quot;)
&quot;&quot;&quot;</span>

nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>