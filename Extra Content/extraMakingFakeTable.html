<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>FAQ Restructuring\Extra\extraMakingFakeTable.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.9" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..\..">üè°</a></span>
  <span><code>FAQ Restructuring\Extra\extraMakingFakeTable.nim</code></span>
  <span></span>
</div>
<hr>
</header><main>
<h2>Table of Contents:</h2>
<ul>
<li>1. <a href="#creating-a-fake-table-using-hashsets">Creating a fake Table using hashSets</a>
<ul>
<li>1.1. <a href="#why-?">Why ?</a></li>
<li>1.2. <a href="#how-?">How ?</a></li>
</ul>
</li>
<li>2. <a href="#fake-table,-but-better-?">Fake Table, but better ?</a>
<ul>
<li>2.1. <a href="#`keyvalue`-and-`faketable`-definition"><code>KeyValue</code> and <code>FakeTable</code> Definition</a></li>
<li>2.2. <a href="#`hash`-proc-overload-with-an-iterator"><code>hash</code> proc overload WITH an iterator</a></li>
<li>2.3. <a href="#overloading-the-custom-`elements`-iterator-for-the-`hash`-proc">Overloading the custom <code>elements</code> iterator for the <code>hash</code> proc</a></li>
<li>2.4. <a href="#`hash`-proc-overload-without-an-iterator"><code>hash</code> proc overload WITHOUT an iterator</a></li>
<li>2.5. <a href="#making-a-constructor-proc-for-`faketable`">Making a constructor proc for <code>FakeTable</code></a></li>
<li>2.6. <a href="#making-a-`orderedset`-version-of-our-constructor-proc">Making a <code>OrderedSet</code> version of our constructor proc</a></li>
</ul>
</li>
<li>3. <a href="#overloading">Overloading</a>
<ul>
<li>3.1. <a href="#`contains`-alias-for-`in`-overload"><code>contains</code> alias for <code>in</code> overload</a></li>
<li>3.2. <a href="#&#96;[]&#96;-overload">`[]` overload</a></li>
<li>3.3. <a href="#&#96;+&#96;---union---operator-overload">`+` - union - operator overload</a></li>
<li>3.4. <a href="#&#96;-&#96;---difference---operator-overload">`-` - difference - operator overload</a></li>
<li>3.5. <a href="#optional-semicolon-`;`">Optional Semicolon <code>;</code></a></li>
<li>3.6. <a href="#&#96;*&#96;---intersection---operator-overload">`*` - intersection - operator overload</a></li>
<li>3.7. <a href="#&#96;<&#96;---subset-of---operator-overload">`&lt;` - subset of - operator overload</a></li>
<li>3.8. <a href="#&#96;<=&#96;---subset-relation---operator-overload">`&lt;=` - subset relation - operator overload</a></li>
<li>3.9. <a href="#&#96;==&#96;---equality---operator-overload">`==` - equality - operator overload</a></li>
<li>3.10. <a href="#`excl`-proc-overload"><code>excl</code> proc overload</a></li>
<li>3.11. <a href="#`missingorexcl`-proc-overload"><code>missingOrExcl</code> proc overload</a></li>
</ul>
</li>
</ul>
      <meta name = "viewport" content = "width = device-width, initial-scale = 1">
      <style>
      body {} <!-- This is a comment, this needs to be here body {} -->

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      </style>
      <body>

      <button onclick = "topFunction()" id = "toTop" title = "Go to top">Top</button>
      <button onclick = "topFunction()" id = "toTopMobile" title = "Go to top">Top</button>

      <script>
        // Get the button
        let myButton = document.getElementById("toTop");
        let myButtonMobile = document.getElementById("toTopMobile");
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName("body"); //gives a query object

        //myButton.style.color = "red"; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop > 20 || document.documentElement.scrollTop > 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if ("maxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints > 0;
          } 
        else if ("msMaxTouchPoints" in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints > 0;
          } 
        else 
          {
            var mQ = window.matchMedia && matchMedia("(pointer:coarse)");

            if (mQ && mQ.media === "(pointer:coarse)") 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
              currentButton.style.display = "block";
            } else {currentButton.style.display = "none";}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      </script>
    
<h2>INTRO - GREETING</h2>
<ul>
<li>TITLE: Extra Content - Creating a fake Table using hashSets and Generics</li>
</ul>
<h2>INTRO - FOREWORDS</h2>
<p><b>(What is the purpose of this written tutorial ?)</b></p>
<ul>
<li>In this extra tutorial we will create a fakeTable using hashSets,
which will function like a hashTable. By making this fake Table,
i will teach you <code>generics</code>, <code>overloading</code> much more in depth,
than the old 4 minutes long <code>Procedure Overloading</code> video.</li>
</ul>
<p><a name = "creating-a-fake-table-using-hashsets"></a></p>
<h1>1. Creating a fake Table using hashSets</h1>
<hr />
<p><a name = "why-?"></a></p>
<h2>¬†¬†1.1. Why ?</h2>
<hr />
<p>To have a hash Table with <code>Set operations</code> you have seen the previous <code>Sets</code> video,
which can make your life quite a bit easier.</p>
<p><a name = "how-?"></a></p>
<h2>¬†¬†1.2. How ?</h2>
<hr />
<p>In order to create this fakeTable using hashSets,
we will have to use <code>tuples</code>.
Tuples, because they are a 2x field data structure just like Tables are.
We will also have to use <code>generics</code> to overload existing procs and operators that Sets use,
in order for the (key, value) tuples, to be able to be of any Nim's data type,
without having to overload an insane number of times.</p>
<p><a name = "fake-table,-but-better-?"></a></p>
<h1>2. Fake Table, but better ?</h1>
<hr />
<p>First of, we need to define our FakeTable and then overload the <code>hash</code> proc,
and make a custom <code>iterator</code> that uses that overloaded <code>hash</code> proc,
just like in the previous video of <code>hashSets, more on hash Tables and Hashing</code>,
but with generics.</p>
<p><a name = "`keyvalue`-and-`faketable`-definition"></a></p>
<h2>¬†¬†2.1. <code>KeyValue</code> and <code>FakeTable</code> Definition</h2>
<hr />
<p>First the definition of our tuple to serve as our (key, value),
followed by <code>FakeTable</code>, which is also easier to read and write than,
<code>HashSet[KeyValue[K, V]]</code></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/hashes, std/sets

<span class="hljs-keyword">type</span>
  <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-keyword">tuple</span>
    key: <span class="hljs-type">K</span>
    value: <span class="hljs-type">V</span>
  
  <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">HashSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

  <h6>(From now on, when you see fakeTable or fake Table, i mean the idea, implementation of a "fake table",
  and NOT the `FakeTable` type)</h6>
<p><a name = "`hash`-proc-overload-with-an-iterator"></a></p>
<h2>¬†¬†2.2. <code>hash</code> proc overload WITH an iterator</h2>
<hr />
<p>Now the <code>hash</code> proc overload which is almost exactly the same as in the previous video,
except for the generic part and the &quot;runnableExamples&quot;:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

  <span class="hljs-keyword">for</span> xAtom <span class="hljs-keyword">in</span> fakeTable.elements:
    h = h !&amp; xAtom <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
  <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

    keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
    keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>In order to achieve a fakeTable with hashSets, we must again use hashSets,
and so this <code>hash</code> proc takes a <code>HashSet</code> of type <code>KeyValue</code> with generic parameters of <code>K, V</code>,
so that this fakeTable can function like a Table, which can use just about any data type.</p>
<p>The <code>runnableExamples:</code> part is ignored by the <code>debug</code>(what we are using) and the <code>release</code> versions,
of our programs. It's simply an area meant for examples of the proc, iterator etc.</p>
<p><a name = "overloading-the-custom-`elements`-iterator-for-the-`hash`-proc"></a></p>
<h2>¬†¬†2.3. Overloading the custom <code>elements</code> iterator for the <code>hash</code> proc</h2>
<hr />
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">iterator</span> elements[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">yield</span> hash(tup.key)
    <span class="hljs-keyword">yield</span> hash(tup.value)</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>Again the first changes to this custom iterator are the generic parts.
The second change is because we are giving this iterator,
instead of fields of an object, a <code>FakeTable</code> type which is a <code>HashSet</code> container of type <code>KeyValue</code>, our tuple.
And so we must first <code>unwrap</code> this <code>FakeTable</code> with a simple <code>for loop</code>,
to get the tuple elements, and then it works as before, hashing the 2x fields of our <code>KeyValue</code> tuple instead of an object.</p>
<p><strong>Now let's try that <code>runnableExamples:</code>'s example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">keyValue.elements: 277569625
keyValue.elements: -103088068849849363
keyValue.elements: 2624693060
keyValue.elements: 9147201994791625791</pre></code></pre>

<p>Here we go, both fields of the 2x tuples hashed.</p>
<p><a name = "`hash`-proc-overload-without-an-iterator"></a></p>
<h2>¬†¬†2.4. <code>hash</code> proc overload WITHOUT an iterator</h2>
<hr />
<p>It does not take the <code>FakeTable</code> type, because that would mean it would require an iterator:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyValue: <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
  <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

  h = h !&amp; hash(keyValue.key) <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
  h = h !&amp; hash(keyValue.value)
  <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

    keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
    keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValue:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hashing tuple: &quot;</span>, tup
      <span class="hljs-keyword">echo</span> tup.hash</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><a name = "making-a-constructor-proc-for-`faketable`"></a></p>
<h2>¬†¬†2.5. Making a constructor proc for <code>FakeTable</code></h2>
<hr />
<p>Now let's make a <code>constructor proc</code> to make creation/initialization of our <code>FakeTable</code>,
easier and faster than having to write <code>HashSet[KeyValue[K, V]]</code>,
AND, to actually use a <code>FakeTable</code> type, since <code>HashSet[KeyValue[K, V]]</code>,
is NOT a <code>FakeTable</code></p>
<p>This proc will once again be a generic, since a Table's key and value can be of almost any data type,
we need 2x generic arguments <code>[K, V]</code> for the (key, value) fields of our <code>KeyValue</code> tuple.
Then we give it 2x arguments of type <code>typedesc</code>, which is short for <code>typedescription</code>.
<code>typedesc</code> which is a meta type to denote a type description and is required to make our fakeTable.
If we instead make our 2x arguments: &quot;keyType: K, valueType: V&quot;,
when we will try to use this proc, the Nim's VS Code extension will tell us that we have,
a variable with <code>typedesc type, typedesc type</code>, instead of <code>type, type</code>.
This is because we are giving types to our proc to make our HashSet[KeyValue[type, type]],
and not some operation working with values of types already <code>initialized</code> outside of the <code>proc</code></p>
<p>And then we simply use the initialization proc for hashSets <code>initHashSet</code> of type KeyValue[type, type],
to initialize our fakeTable of type <code>FakeTable</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> newFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-literal">result</span> = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]() <span class="hljs-comment">#Have to use `result =` with `runnableExamples:` present</span>

  runnableExamples:
    <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
    fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>Now let's run the runnable example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)

<span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: 'a', value: 10)} FakeTable[system.char, system.int]</pre></code></pre>

<p>As you can see, initializing our fakeTable is much simpler than the original of:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()</code></pre>
<p><a name = "making-a-`orderedset`-version-of-our-constructor-proc"></a></p>
<h2>¬†¬†2.6. Making a <code>OrderedSet</code> version of our constructor proc</h2>
<hr />
<p>First we make another type just like with we did for our FakeTable type,
but instead of using a <code>HashSet</code>, we use a <code>OrderedSet</code>.
And then lastly, we simply rename the return type to <code>FakeOrderedTable</code></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">type</span>
  <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">OrderedSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]

<span class="hljs-keyword">proc</span> newOrderedFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  initOrderedSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]()

  runnableExamples:
    <span class="hljs-keyword">var</span> fakeOrderedTable = newOrderedFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
    fakeOrderedTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">echo</span> fakeOrderedTable, <span class="hljs-string">&quot; &quot;</span>, fakeOrderedTable.typeof</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><a name = "overloading"></a></p>
<h1>3. Overloading</h1>
<hr />
<p>Now let's move on to overloading ALL of the operations normal <code>sets</code> can use,
here is the list from the <code>sets video</code>:</p>
<ul>
<li><span style="color:pink"><b>incl</b></span>(A, e)	same as A = A + e</li>
<li><span style="color:pink"><b>excl</b></span>(A, e)	same as A = A - e</li>
<li><span style="color:pink"><b>card</b></span>(A)	the cardinality of A (number of elements in A)</li>
<li><span style="color:pink"><b>contains</b></span>(A, e)	A contains element e</li>
<li>e <span style="color:pink"><b>in</b></span> A	set membership (A contains element e)</li>
<li>e <span style="color:pink"><b>notin</b></span> A	A does not contain element e</li>
<li>a <span style="color:pink"><b>*</b></span> b	Intersection</li>
<li>a <span style="color:pink"><b>+</b></span> b	Union</li>
<li>a <span style="color:pink"><b>-</b></span> b	Difference</li>
<li>a <span style="color:pink"><b>==</b></span> b	Set equality</li>
<li>a <span style="color:pink"><b>&lt;=</b></span> b	subset relation (a is subset of b or equal to b)</li>
<li>a <span style="color:pink"><b>&lt;</b></span> b	Check if a is a subset of b</li>
</ul>
<p><strong>As well as:</strong></p>
<ul>
<li>`[]`(<code>[]</code> with apostrophes) so that we can find the value of a key, by supplying the key.
Otherwise we have to supply the entire <code>tuple</code>.</li>
</ul>
<p><strong>And</strong> <code>missingOrExcl(HashSet, key)</code> as an extra(only for hashSets, not normal Sets)</p>
<p><a name = "`contains`-alias-for-`in`-overload"></a></p>
<h2>¬†¬†3.1. <code>contains</code> alias for <code>in</code> overload</h2>
<hr />
<p>Let's start with <code>contains(container, key)</code>, which is an alias for the <code>in</code> operator.
So that we can easily find a <code>key</code> inside our <code>FakeTable</code>'s <code>KeyValue</code> tuple,
and with that <code>key</code>, it's `value:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># `in` is an alias for `contains`, </span>
<span class="hljs-keyword">proc</span> contains[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">if</span> tup.key == k:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>As you can see, we make it a <code>generic</code> proc that takes our <code>FakeTable</code> type,
unwraps the <code>fakeTable</code>, and then checks every <code>KeyValue</code> tuple's first field of <code>key</code>,
against <code>k</code>, the key we are looking for, and then returns true or false if it found it or not.</p>
<p><strong>Here is an example of it's usage:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fakeTableContains = newFakeTable(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)

fakeTableContains.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>) <span class="hljs-comment">#elements as tuples</span>
fakeTableContains.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>) <span class="hljs-comment">#elements as tuples</span>

<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Key 2&quot;</span> <span class="hljs-keyword">in</span> fakeTableContains:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SUCCESS: Key 2 is in fakeTableContains&quot;</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">SUCCESS: Key 2 is in fakeTableContains</pre></code></pre>

<p><a name = "&#96;[]&#96;-overload"></a></p>
<h2>¬†¬†3.2. `[]` overload</h2>
<hr />
<p>Now let's overload the `[]`(<code>[]</code> with apostrophes),
to again, be able to easily find a <code>key</code> inside our <code>FakeTable</code>'s <code>KeyValue</code> tuple,
and with that <code>key</code>, it's `value:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `[]`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-type">V</span> {.inline.} =
  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
    <span class="hljs-keyword">if</span> tup.key == k:
      <span class="hljs-keyword">return</span> tup.value</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>Very similar to the <code>contains</code>(<code>in</code> is the alias) overload.
The strange part here is the <code>{.inline.}</code> pragma,
which is simply there to mark it for the compiler(which will warn us) and us,
that we should not call this proc <code>[]</code> directly,
as in like a proc <code>[](arg1, arg2)</code>.</p>
<p><strong>Here is the example of what that overload enables us:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> fakeTableContains
<span class="hljs-keyword">echo</span> fakeTableContains[<span class="hljs-string">&quot;Key 1&quot;</span>]</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: &quot;Key 2&quot;, value: 202), (key: &quot;Key 1&quot;, value: 101)}
101</pre></code></pre>

<p><strong>NOTE:</strong> All of these overloads have to focus on the <code>key</code> part of the <code>KeyValue</code> tuple,
in order to achieve the functionality of a <code>Table</code>.
Meaning, these overloads must make it so that we only work with the <code>keys</code>,
and not <code>tuples</code>.</p>
<p><a name = "&#96;+&#96;---union---operator-overload"></a></p>
<h2>¬†¬†3.3. `+` - union - operator overload</h2>
<hr />
<p>Now let's overload the <code>+</code> operator(proc), which is the <code>union</code> between Set1 and Set2,
meaning both sets.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key != tupB.key:
        <span class="hljs-literal">result</span>.incl tupA
        <span class="hljs-literal">result</span>.incl tupB</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>The overload proc's head, could also put both arguments together like this:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-keyword">discard</span></code></pre>
<p><strong>How it works:</strong> Well, first of we unwrap the first <code>FakeTable</code>(HashSet[KeyValue[K, V]]) with a for loop,
then we unwrap the second with another for loop on the second <code>FakeTable</code> of <code>b</code>,
in order to -&gt; elementOfSet1.key != elementOfSet1.key -&gt; elementOfSet1.key != elementOfSet<code>2</code>.key -&gt;
and so on, until we compare every element's key of <code>a</code> against every element's key of <code>b</code>,
in order to find only the <code>keys</code>, both <code>FakeTables</code> share,
to return a <code>result</code> of the <code>union</code> of both <code>FakeTables</code>.</p>
<p>Remember that <code>sets</code> do not allow for duplicate keys.
Checking without the <code>.key</code> part, could result in duplicate keys,
because, even though our <code>FakeTable</code> is a <code>HashSet</code> which doesn't allow for duplicate elements,
it can only do so, if the <code>(key, value)</code> tuple elements we have in it,
have both fields of our <code>KeyValue</code> tuple <code>(key, value)</code> exactly the same,
as another <code>KeyValue</code> tuple <code>(key, value)</code>.
Tuples are only equal if both tuples have both fields identical.</p>
<p>This is why we must provide &quot;help&quot; to our <code>FakeTable</code>'s overload procs.</p>
<p><strong>Now let's finally see an example of the <code>+</code> operator(proc) overload:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> fTableA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> fTableB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

fTableA.incl (<span class="hljs-string">'A'</span>, <span class="hljs-number">1</span>)
fTableA.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)

fTableB.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)
fTableB.incl (<span class="hljs-string">'C'</span>, <span class="hljs-number">3</span>)

<span class="hljs-keyword">echo</span> fTableA + fTableB</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: 'C', value: 3), (key: 'B', value: 2), (key: 'A', value: 1)}</pre></code></pre>

<p>Here we go, all the elements of both <code>FakeTables</code>, without duplicates.</p>
<p><a name = "&#96;-&#96;---difference---operator-overload"></a></p>
<h2>¬†¬†3.4. `-` - difference - operator overload</h2>
<hr />
<p>Now let's overload the <code>-</code> operator(proc) - Difference - Returns the elements that <code>fTableA</code> has,
but <code>fTableB</code> does not.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `-`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">var</span> tempA = a
  <span class="hljs-keyword">var</span> tempB = b

  <span class="hljs-comment">#De-duplication</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key == tupB.key:
        tempA.excl(tupA)
        tempB.excl(tupB)

  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> tempA:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> tempB:
      <span class="hljs-keyword">if</span> tupA.key != tupB.key:
        <span class="hljs-keyword">if</span> tupA <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
          <span class="hljs-keyword">discard</span>
        <span class="hljs-keyword">else</span>:
          <span class="hljs-literal">result</span>.incl tupA</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>First of, we copy the 2 <code>FakeTable</code>s of <code>a</code> and <code>b</code> into temporary variables of <code>tempA</code> and <code>tempB</code>,
because want to de-duplicate the <code>FakeTable</code>s and only return different elements,
and we can't do that with the <code>FakeTables</code> we supplied to the 2x arguments of <code>a</code> and <code>b</code>,
because you can't modify arguments received.
We also can't use <code>var</code> before <code>FakeTable</code> as in <code>a: var FakeTable</code>,
because we would be modifying the original <code>FakeTable</code>s, which we don't want to do.</p>
<p>So the second part marked with the <code>#De-duplication comment</code>,
is where we unwrap both of the <code>FakeTables</code>,
and check all the <code>keys</code> of the <code>KeyValue</code> tuples for identical keys/duplicates,
and then remove them from both, because this isn't just to find and remove duplicates,
but also because the <code>-</code> operator(proc), is supposed to only return the elements,
that are not in <code>FakeTable</code> <code>b</code> - any duplicates/shared elements.</p>
<p>And lastly, the third part then unwraps both <code>temp</code> <code>FakeTable</code>s,
and looks for <code>different keys</code>, and also checks the <code>result</code> variable,
because checking if the keys are not equal and then including <code>tupA</code>,
the remaining keys WILL be different, and if both <code>FakeTable</code>s have 2x elements each,
then both of the elements of <code>tupA</code>, would be added twice,
requiring further de-duplication. Checking the <code>result</code> variable, fixes that.</p>
<p><strong>Here is an example of manually going trough this overloaded <code>-</code> operator(proc):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">discard</span> <span class="hljs-comment">#nimib requires a return</span>
<span class="hljs-comment">#a b c #a: FakeTable</span>
<span class="hljs-comment">#c d e #b: FakeTable</span>
<span class="hljs-comment">#De-duplication</span>
<span class="hljs-comment">#a b</span>
<span class="hljs-comment">#d e</span>
<span class="hljs-comment">#1 a != d -&gt; yes adding `a`</span>
<span class="hljs-comment">#2 a != e -&gt; yes adding `a` -&gt; duplicated `a` -&gt; hashSet detects that, removes it. BUT tuples != if not all fields are equal</span>
<span class="hljs-comment">#3 b != d -&gt; yes adding `b`</span>
<span class="hljs-comment">#4 b != e -&gt; yes adding `b`</span>
<span class="hljs-comment">#result = {'a', 'a', 'b', 'b'} -&gt; correct if we deduplicate... this could go on to infinity.</span>
<span class="hljs-comment">#So checking the `result` variable fixes the above problem</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>And here is the code for the above manual explanation:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> ftA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> ftB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

ftA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); ftA.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>); ftA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)
ftB.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>); ftB.incl (<span class="hljs-string">'d'</span>, <span class="hljs-number">40</span>); ftB.incl (<span class="hljs-string">'e'</span>, <span class="hljs-number">50</span>)

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA: &quot;</span>, ftA
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB: &quot;</span>, ftB

<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA - ftB = &quot;</span>, ftA - ftB</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">ftA: {(key: 'c', value: 30), (key: 'a', value: 10), (key: 'b', value: 20)}
ftB: {(key: 'c', value: 30), (key: 'd', value: 40), (key: 'e', value: 50)}
ftA - ftB = {(key: 'a', value: 10), (key: 'b', value: 20)}</pre></code></pre>

<p><strong>And the reverse:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB - ftA = &quot;</span>, ftB - ftA</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">ftB - ftA = {(key: 'd', value: 40), (key: 'e', value: 50)}</pre></code></pre>

<p><a name = "optional-semicolon-`;`"></a></p>
<h2>¬†¬†3.5. Optional Semicolon <code>;</code></h2>
<hr />
<p>In the above code i have also used <code>;</code> which is optional in Nim,
and allows for multiple operations to be used on a single line.
I think it's quite useful for such small operations that work the same,
to be put on a single line, instead of heavily spreading vertically.
I don't recommend using the optional semicolon <code>;</code> for large operations,
or different ones, most people don't like that,
and it will hurt clarity and readability. But again, for same operations of such small scale, yes.</p>
<p><a name = "&#96;*&#96;---intersection---operator-overload"></a></p>
<h2>¬†¬†3.6. `*` - intersection - operator overload</h2>
<hr />
<p>Now we will overload the <code>*</code> operator(proc) - intersection - returns only shared elements.
This one is very simple, simply compare the keys, and add one of them into the <code>result</code>(since both are the same):</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `*`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
    <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
      <span class="hljs-keyword">if</span> tupA.key == tupB.key:
        <span class="hljs-literal">result</span>.incl tupA</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>Example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> ftA * ftB</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: 'c', value: 30)}</pre></code></pre>

<p><a name = "&#96;<&#96;---subset-of---operator-overload"></a></p>
<h2>¬†¬†3.7. `&lt;` - subset of - operator overload</h2>
<hr />
<p>Next is <code>&lt;</code> operator(proc) overload - <code>a</code> subset of <code>b</code>
First of, when using this operator, the <code>subset</code> HAS to be smaller than the set(FakeTable) we are comparing against.</p>
<p>Which is easily achieved by first checking the lengths of the 2x <code>FakeTable</code>s:
<code>if a.len &gt;= b.len: return false</code>, <code>else:</code> we continue.
Then we set the <code>result</code> variable to <code>false</code>, unwrap the 2x <code>FakeTable</code>s,
make a <code>block subsetA</code> statement, so that we can easily break out of the second loop once we find an identical key,
after setting the <code>result</code> variable to <code>true</code>Àô.</p>
<p><strong>This is for 2x reasons:</strong> The first is for reasons of speed, we are checking every element of <code>FakeTable</code> <code>a</code>,
against every element of <code>FakeTable</code> <code>b</code>, there are no duplicates, so once found, it's a waste to continue.</p>
<p>And secondly, because we have to set the <code>result</code> variable to <code>false</code> if the keys are not identical,
so that once loop 2 ends, and loop 1 is about to start another run of loop 2 with the next element,
and we found no matching <code>keys</code>, then <code>FakeTable</code> <code>a</code> is NOT a subset of <code>FakeTable</code> <code>Àôb</code>.
And because of that, if we don't break out back to loop 1 using the <code>labeled block</code> statement,
we could find a matching key, but then on the second element override it to false!</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `&lt;`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">if</span> a.len &gt;= b.len:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">block</span> subsetA:
        <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">if</span> tupA.key == tupB.key:
            <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
          <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>Here is an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">#ftA has 'a', 'b', 'c'</span>
<span class="hljs-keyword">var</span> subsetOfA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

subsetOfA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
subsetOfA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

<span class="hljs-keyword">echo</span> ftA
<span class="hljs-keyword">echo</span> subsetOfA
<span class="hljs-keyword">echo</span> subsetOfA &lt; ftA

<span class="hljs-keyword">var</span> subsetofA2 = ftA
<span class="hljs-keyword">echo</span> subsetofA2 &lt; ftA</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: 'c', value: 30), (key: 'a', value: 10), (key: 'b', value: 20)}
{(key: 'c', value: 30), (key: 'a', value: 10)}
true
false</pre></code></pre>

<p><code>subsetofA2 is false because it is equal in size of </code>ftA`, again, has to be smaller.</p>
<p><a name = "&#96;<=&#96;---subset-relation---operator-overload"></a></p>
<h2>¬†¬†3.8. `&lt;=` - subset relation - operator overload</h2>
<hr />
<p>The <code>&lt;=</code>(subset relation) operator(proc), does the exact same as <code>&lt;</code>(subset of) operator,
except that the subset can be equal in size.</p>
<p><strong>Here is the code to overload <code>&lt;=</code> operator(proc):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `&lt;=`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-comment">#Checking only the keys</span>
  <span class="hljs-keyword">if</span> system.`&lt;=`(a.len, b.len): <span class="hljs-comment">#Can't do this: if a.len &lt;= b.len: -&gt; for some reason this overload calls itself instead of the system &lt;=</span>
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">block</span> subsetA:
        <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">if</span> tupA.key == tupB.key:
            <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
          <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>The only real change here compared to the <code>&lt;</code> overload,
is that instead of checking for the <code>subset</code> to be smaller,
we check for smaller or equal.
Here i found a bit of a problem. For some reason when using the <code>&lt;=</code> operator,
Nim calls the version we are in right now, instead of the <code>system</code> module one.
So in order to tell it to use the correct one,
we have to explicitly specify that with <code>system.</code> + <strong>`&lt;=`</strong> + <code>(a.len, b.len)</code>,
instead of simply <code>a.len &lt;= b.len</code>.</p>
<p><a name = "&#96;==&#96;---equality---operator-overload"></a></p>
<h2>¬†¬†3.9. `==` - equality - operator overload</h2>
<hr />
<p><strong>Now let's also overload the <code>==</code> operator(proc)</strong>,
so that we are no longer comparing tuples, which require both fields to be equal for equivalence.
With this overload we would only require the <code>keys</code>.</p>
<p>With this overload, we also have to use the <code>system.</code> way of explicitly calling the system module's <code>==</code> operator.
I am pretty sure, that the reason this happens, is for reasons of <code>recursion</code>,
proc calling itself, like in the famous fibonacci sequence.</p>
<p>In this overload's code i've also used the <code>in</code> alias of the <code>contains</code> overload we have done earlier,
to make this easier, as well as a <code>continue</code> statement, instead of reversing that logic with a <code>notin</code> template.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> `==`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
  <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">#until false</span>

  <span class="hljs-keyword">if</span> system.`==`(a.len, b.len): <span class="hljs-comment">#Cannot use: if a.len == b.len: -&gt; because of reasons of recursion</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">if</span> tupA.key <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">continue</span>
      <span class="hljs-keyword">else</span>:
        <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>: 
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p><strong>And an example:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> a = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> b = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">var</span> c = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

a.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); a.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
b.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); b.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)

c.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); c.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

<span class="hljs-keyword">echo</span> a == b
<span class="hljs-keyword">echo</span> a == c</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">true
false</pre></code></pre>

<p><a name = "`excl`-proc-overload"></a></p>
<h2>¬†¬†3.10. <code>excl</code> proc overload</h2>
<hr />
<p><strong>Now let's overload the <code>excl</code> proc(for Sets/HashSets)</strong>, in order to simplify removal of <code>KeyValue</code> tuples,
based on the <code>key</code> provided. <code>del</code> is the proc for doing this for <code>Tables</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> excl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>) =
  <span class="hljs-comment">#Since excluding/removing an element of a container while iterating over it with a `for` loop is an error,</span>
    <span class="hljs-comment">#iterating over a copy, and using the copy's data to remove from the original will avoid that problem</span>
  <span class="hljs-keyword">var</span> temp = fakeTable

  <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> temp:
    <span class="hljs-keyword">if</span> tup.key == k:
      fakeTable.excl(tup)</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>We have to use the <code>var</code> keyword in the overload's definition/head for our <code>FakeTable</code> in order to remove a <code>key</code>,
from the supplied <code>FakeTable</code>. Without <code>var</code> you only copy the argument's data.</p>
<p><strong>Example(using variables from above):</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> a
a.excl(<span class="hljs-string">'a'</span>)
<span class="hljs-keyword">echo</span> a</code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">{(key: 'a', value: 10), (key: 'b', value: 20)}
{(key: 'b', value: 20)}</pre></code></pre>

<p><a name = "`missingorexcl`-proc-overload"></a></p>
<h2>¬†¬†3.11. <code>missingOrExcl</code> proc overload</h2>
<hr />
<p><strong>Now we will overload the <code>missingOrExcl</code> proc, that is available only to hashSets, NOT normal Sets.</strong>
<code>missingOrExcl</code> again, first excludes a <code>key</code> from a <code>HashSet</code>, and tells you if the <code>key</code> was already missing:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> missingOrExcl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
  <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> fakeTable:
    fakeTable.excl(k)
    <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"></code></pre>

<p>Quite simple with the <code>excl</code> and <code>contains</code> proc overloads.
Without them, it would of been quite longer and harder to understand.</p>
<p><strong>Here is an example from the <code>sets</code> module's example for <code>missingOrExcl</code> for <code>HashSet</code>s:</strong></p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> s = newFakeTable(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)
s.incl (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); s.incl (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); s.incl (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>); s.incl (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);

<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">4</span>) <span class="hljs-comment">#should be: true</span>
<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: false</span>
<span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: true</span></code></pre><pre><code class=\"language-markdown\" style = "color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;"><pre class="nb-output">true
false
true</pre></code></pre>

<h1>Outro - Afterwords</h1>
<hr />
<p>Okay, that's it for this video, thanks for watching like, share and subscribe,
aswell as click the bell icon if you liked it and want more,
you can also follow me on twitter of the same name, and support me on Patreon.
If you had any problems with any part of the video,
let me know in the comment section,
the code of this video, script and documentation, are in the link in the description,
as a form of offline tutorial.</p>
<h1>Thanks to my past and current Patrons</h1>
<hr />
<h2>Past Patrons</h2>
<hr />
<ul>
<li>Goose_Egg: From April 4th 2021 to May 10th 2022</li>
<li>Davide Galilei(1x month)</li>
</ul>
<h2>Current Patrons</h2>
<hr />
<ul>
<li>jaap groot (from October 2023)</li>
<li>Dimitri Lesnoff (from October 2023)</li>
</ul>
<h2>Compiler Information</h2>
<hr />
<ul>
<li>Version used: E.G. 2.0.2</li>
<li>Compiler settings used: none, ORC is now the default memory management option</li>
</ul>
<h2>My and General Links</h2>
<hr />
<ul>
<li><a href="https://www.patreon.com/Kiloneie?fan_landing=true" title="Patreon">Patreon</a></li>
<li><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf" title="Visual Studio Code Shortcuts">Visual Studio Code Shortcuts</a></li>
</ul>
<h2>Links to this video's subject</h2>
<hr />
<ul>
<li><a href="https://nim-lang.org/docs/sets.html" title="Sets(hashSets)">Sets(hashSets)</a></li>
<li><a href="https://nim-lang.org/docs/hashes.html" title="Hashes">Hashes</a></li>
<li><a href="https://nim-lang.org/docs/tables.html" title="Tables(hashTables)">Tables(hashTables)</a></li>
</ul>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-comment">#Do NOT use {} inside nbText: hlMdF&quot;&quot;&quot; &quot;&quot;&quot; fields, sometimes it will error, not always</span>
<span class="hljs-comment">#When using - to make a line a list item, you cannot have ANY one of the lines be an empty line</span>
<span class="hljs-comment">#Use spaces by a factor of 2x for indentation in levels</span>
<span class="hljs-comment"># *text* italic</span>
<span class="hljs-comment"># **text** for bold instead of &lt;b&gt;&lt;/b&gt;</span>
<span class="hljs-comment"># ***text*** italic bold</span>
<span class="hljs-comment">#Link 1 - &lt;a href = &quot;link&quot;&gt;&lt;/a&gt;</span>
<span class="hljs-comment">#Link 2 - [name](link)</span>
<span class="hljs-comment">#Link 3 `name &lt;link&gt;`_ -&gt; without a name works too</span>
<span class="hljs-comment">#nbCodeSkip -&gt; skips the output/echo calls from the file, everything else remains the same</span>
<span class="hljs-comment">#nbCodeInBlock -&gt; opens up a new scope like the &quot;block&quot; statement, useful for when you don't want to use different variable names etc</span>
<span class="hljs-comment">#https://pietroppeter.github.io/nimib/allblocks.html</span>

<span class="hljs-comment">#https://nim-lang.org/docs/manual.html#lexical-analysis-raw-string-literals raw strings r&quot;&quot;</span>

<span class="hljs-keyword">import</span> nimib, std/strutils <span class="hljs-comment">#You can use nimib's custom styling or HTML &amp; CSS</span>

nbInit()
nb.darkMode()
<span class="hljs-comment">#nbShow() #This will auto open this file in the browser, but it does not check if it is already open</span>
  <span class="hljs-comment">#so it keeps bloody opening one after another, i just want a way to update changes quickly</span>

<span class="hljs-comment"># customize source highlighting:</span>
nb.context[<span class="hljs-string">&quot;highlight&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css&quot;&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment"># a custom text block that shows markdown source</span>
<span class="hljs-keyword">template</span> nbTextWithSource*(body: <span class="hljs-built_in">untyped</span>) =
  newNbBlock(<span class="hljs-string">&quot;nbTextWithSource&quot;</span>, <span class="hljs-literal">false</span>, nb, nb.blk, body):
    nb.blk.output = body
  nb.blk.context[<span class="hljs-string">&quot;code&quot;</span>] = body

nb.renderPlans[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = @[<span class="hljs-string">&quot;mdOutputToHtml&quot;</span>]
nb.partials[<span class="hljs-string">&quot;nbTextWithSource&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;{{&amp;outputToHtml}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot;&gt;{{code}}&lt;/code&gt;&lt;/pre&gt;&quot;&quot;&quot;</span>

<span class="hljs-comment">#Overriding nimib's nbCode -&gt; with a version that has horizontal scroll for overflowing output</span>
<span class="hljs-keyword">import</span> nimib / [capture]

<span class="hljs-keyword">template</span> nbCode(body: <span class="hljs-built_in">untyped</span>) =
  newNbCodeBlock(<span class="hljs-string">&quot;nbCode&quot;</span>, body): <span class="hljs-comment">#Writes to stdout `lineNumb typeOfNBblock: a bit of first line</span>
    captureStdout(nb.blk.output):
      body

nb.partials[<span class="hljs-string">&quot;nbCode&quot;</span>] = <span class="hljs-string">&quot;&quot;&quot;
{{&gt;nbCodeSource}}
&lt;pre&gt;&lt;code class=\&quot;language-markdown\&quot; style = &quot;color:white;background-color: rgba(255, 255, 255, 0);font-size: 12px;&quot;&gt;{{&gt;nbCodeOutput}}&lt;/code&gt;&lt;/pre&gt;
&quot;&quot;&quot;</span> 
nb.renderPlans[<span class="hljs-string">&quot;nbCode&quot;</span>] = @[<span class="hljs-string">&quot;highlightCode&quot;</span>] <span class="hljs-comment"># default partial automatically escapes output (code is escaped when highlighting)</span>

<span class="hljs-comment"># how to add a ToC</span>
<span class="hljs-keyword">var</span>
  nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;## Table of Contents:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">var</span> index = (section: <span class="hljs-number">0</span>, subsection: <span class="hljs-number">0</span>)

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  index.section.inc
  index.subsection = <span class="hljs-number">0</span> <span class="hljs-comment">#Reset on a new nbSection</span>

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;. &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;- &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span> <span class="hljs-comment">#&amp;#92; is HTML code for &quot;\&quot;, you can also &quot;\\&quot; or r&quot;\&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbSubSection(name:<span class="hljs-built_in">string</span>) =
  index.subsection.inc

  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; <span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span> &amp; $index.section &amp; <span class="hljs-string">&quot;.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">&quot;. &quot;</span>  &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span> <span class="hljs-comment">#&amp;nbsp; is inline HTML for a single white space(nothing in markdown)</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;  - &quot;</span> &amp; $index.section &amp; <span class="hljs-string">r&quot;\.&quot;</span> &amp; $index.subsection &amp; <span class="hljs-string">r&quot;\. &quot;</span> &amp; <span class="hljs-string">&quot;&lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>
  <span class="hljs-comment">#If you get an error from the above line, addToc must be ran before any nbSection </span>

<span class="hljs-keyword">template</span> nbUoSection(name: <span class="hljs-built_in">string</span>) =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string"># &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-keyword">template</span> nbUoSubSection(name: <span class="hljs-built_in">string</span>) =
  nbText <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>

<span class="hljs-comment">#Updating the same file is shown instantly once deployed via Github Page on PC. </span>
  <span class="hljs-comment">#Mobile takes either a random amount of time, or NOT at all!</span>
<span class="hljs-keyword">template</span> addButtonBackToTop() =
  nbRawHtml: <span class="hljs-string">hlHtml&quot;&quot;&quot;
      &lt;meta name = &quot;viewport&quot; content = &quot;width = device-width, initial-scale = 1&quot;&gt;
      &lt;style&gt;
      body {} &lt;!-- This is a comment, this needs to be here body {} --&gt;

      #toTop {
        display: none;
        position: fixed;
        bottom: 20px;
        right: 30px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTop:hover {background-color: #555;}

      #toTopMobile {
        display: none;
        position: fixed;
        bottom: -5px;
        right: -5px;
        z-index: 99;
        font-size: 18px;
        border: none;
        outline: none;
        background-color: #1A222D;
        opacity: .2;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 4px;
      }
      #toTopMobile:hover {background-color: #555;}
      
      &lt;/style&gt;
      &lt;body&gt;

      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTop&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;
      &lt;button onclick = &quot;topFunction()&quot; id = &quot;toTopMobile&quot; title = &quot;Go to top&quot;&gt;Top&lt;/button&gt;

      &lt;script&gt;
        // Get the button
        let myButton = document.getElementById(&quot;toTop&quot;);
        let myButtonMobile = document.getElementById(&quot;toTopMobile&quot;);
        var currentButton = myButton

        var hasTouchScreen = false;

        //var contentBody = document.getElementsByTagName(&quot;body&quot;); //gives a query object

        //myButton.style.color = &quot;red&quot;; //This works
        //myButton.textContent = contentBody; //This also works .innerHTML, .innerText
        //document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20
        //Above could be used to position the button relativly ?

        // Detecting if the device is a mobile device
        if (&quot;maxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.maxTouchPoints &gt; 0;
          } 
        else if (&quot;msMaxTouchPoints&quot; in navigator) 
          {
            hasTouchScreen = navigator.msMaxTouchPoints &gt; 0;
          } 
        else 
          {
            var mQ = window.matchMedia &amp;&amp; matchMedia(&quot;(pointer:coarse)&quot;);

            if (mQ &amp;&amp; mQ.media === &quot;(pointer:coarse)&quot;) 
              {
                hasTouchScreen = !!mQ.matches;
              } 
            else if ('orientation' in window) 
              {
                hasTouchScreen = true; // deprecated, but good fallback
              } 
            else 
              {
                // Only as a last resort, fall back to user agent sniffing
                var UA = navigator.userAgent;
                hasTouchScreen = (
                    /\b(BlackBerry|webOS|iPhone|IEMobile)\b/i.test(UA) ||
                    /\b(Android|Windows Phone|iPad|iPod)\b/i.test(UA)
                    );
              }
          }

        if (hasTouchScreen)
            currentButton = myButtonMobile

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function() 
          {
            scrollFunction()
          };

        function scrollFunction() 
          {
            if (document.body.scrollTop &gt; 20 || document.documentElement.scrollTop &gt; 20) {
              currentButton.style.display = &quot;block&quot;;
            } else {currentButton.style.display = &quot;none&quot;;}
          }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
          document.body.scrollTop = 0;
          document.documentElement.scrollTop = 0;
        }
      &lt;/script&gt;
    &quot;&quot;&quot;</span>

<span class="hljs-comment">#TABLE OF CONTENTS - MUST BE RUN BEFORE ANY nbSection !!!</span>
addToc() 
addButtonBackToTop()

<span class="hljs-comment">#Use Live Preview Extension and set the Auto Refresh Preview set to &quot;On changes to Saved Files&quot;</span>
  <span class="hljs-comment">#And Server Keep Alive After Embedded Preview Close set to 0, </span>
  <span class="hljs-comment">#so that we no longer need the preview embedded window, we now have it in the browser!</span>
    <span class="hljs-comment">#Live SERVER Extension no longer works, even with the .html file kept open</span>

<span class="hljs-comment">###############</span>
<span class="hljs-comment">#START OF FILE#</span>
<span class="hljs-comment">###############</span>

<span class="hljs-comment">#Adding hlMd or hlMdf enables nimiboost's markdown highlight mode</span>
nbText: <span class="hljs-string">hlMdF&quot;&quot;&quot;
## INTRO - GREETING
- TITLE: Extra Content - Creating a fake Table using hashSets and Generics

## INTRO - FOREWORDS
&lt;b&gt;(What is the purpose of this written tutorial ?)&lt;/b&gt;
- In this extra tutorial we will create a fakeTable using hashSets,
  which will function like a hashTable. By making this fake Table,
  i will teach you `generics`, `overloading` much more in depth,
  than the old 4 minutes long `Procedure Overloading` video.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Creating a fake Table using hashSets&quot;</span>

nbSubSection <span class="hljs-string">&quot;Why ?&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  To have a hash Table with `Set operations` you have seen the previous `Sets` video,
  which can make your life quite a bit easier.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;How ?&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In order to create this fakeTable using hashSets,
    we will have to use `tuples`.
    Tuples, because they are a 2x field data structure just like Tables are.
    We will also have to use `generics` to overload existing procs and operators that Sets use, 
    in order for the (key, value) tuples, to be able to be of any Nim's data type, 
    without having to overload an insane number of times.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Fake Table, but better ?&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  First of, we need to define our FakeTable and then overload the `hash` proc,
  and make a custom `iterator` that uses that overloaded `hash` proc,
  just like in the previous video of `hashSets, more on hash Tables and Hashing`,
  but with generics.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`KeyValue` and `FakeTable` Definition&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  First the definition of our tuple to serve as our (key, value),
  followed by `FakeTable`, which is also easier to read and write than,
  `HashSet[KeyValue[K, V]]`
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">import</span> std/hashes, std/sets

  <span class="hljs-keyword">type</span>
    <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-keyword">tuple</span>
      key: <span class="hljs-type">K</span>
      value: <span class="hljs-type">V</span>
    
    <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">HashSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]
nbText: <span class="hljs-string">&quot;&quot;&quot;
  &lt;h6&gt;(From now on, when you see fakeTable or fake Table, i mean the idea, implementation of a &quot;fake table&quot;,
  and NOT the `FakeTable` type)&lt;/h6&gt;
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`hash` proc overload WITH an iterator&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  Now the `hash` proc overload which is almost exactly the same as in the previous video,
  except for the generic part and the &quot;runnableExamples&quot;:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> xAtom <span class="hljs-keyword">in</span> fakeTable.elements:
      h = h !&amp; xAtom <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
    <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

      keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
      keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

      <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In order to achieve a fakeTable with hashSets, we must again use hashSets,
  and so this `hash` proc takes a `HashSet` of type `KeyValue` with generic parameters of `K, V`,
  so that this fakeTable can function like a Table, which can use just about any data type.

  The `runnableExamples:` part is ignored by the `debug`(what we are using) and the `release` versions,
  of our programs. It's simply an area meant for examples of the proc, iterator etc.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;Overloading the custom `elements` iterator for the `hash` proc&quot;</span>
nbCode:
  <span class="hljs-keyword">iterator</span> elements[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">yield</span> hash(tup.key)
      <span class="hljs-keyword">yield</span> hash(tup.value)
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Again the first changes to this custom iterator are the generic parts.
  The second change is because we are giving this iterator,
  instead of fields of an object, a `FakeTable` type which is a `HashSet` container of type `KeyValue`, our tuple.
  And so we must first `unwrap` this `FakeTable` with a simple `for loop`,
  to get the tuple elements, and then it works as before, hashing the 2x fields of our `KeyValue` tuple instead of an object.

  **Now let's try that `runnableExamples:`'s example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

  keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
  keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> keyValue.elements:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;keyValue.elements: &quot;</span>, e
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here we go, both fields of the 2x tuples hashed.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`hash` proc overload WITHOUT an iterator&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  It does not take the `FakeTable` type, because that would mean it would require an iterator:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> hash[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyValue: <span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">Hash</span> =
    <span class="hljs-keyword">var</span> h: <span class="hljs-type">Hash</span> = <span class="hljs-number">0</span>

    h = h !&amp; hash(keyValue.key) <span class="hljs-comment"># !&amp; mixes a hash value &quot;h&quot; with &quot;val&quot; to produce a new hash value - only requires for use in overloading hash() proc for use in new data types</span>
    h = h !&amp; hash(keyValue.value)
    <span class="hljs-literal">result</span> = !$h <span class="hljs-comment"># !$ finishes the computation of the hash value - only required for use in overloading hash() proc for use in new data types</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

      keyValue.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>)
      keyValue.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>)

      <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> keyValue:
        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hashing tuple: &quot;</span>, tup
        <span class="hljs-keyword">echo</span> tup.hash

nbSubSection <span class="hljs-string">&quot;Making a constructor proc for `FakeTable`&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's make a `constructor proc` to make creation/initialization of our `FakeTable`,
  easier and faster than having to write `HashSet[KeyValue[K, V]]`,
  AND, to actually use a `FakeTable` type, since `HashSet[KeyValue[K, V]]`,
  is NOT a `FakeTable`

  This proc will once again be a generic, since a Table's key and value can be of almost any data type,
  we need 2x generic arguments `[K, V]` for the (key, value) fields of our `KeyValue` tuple.
  Then we give it 2x arguments of type `typedesc`, which is short for `typedescription`.
  `typedesc` which is a meta type to denote a type description and is required to make our fakeTable.
  If we instead make our 2x arguments: &quot;keyType: K, valueType: V&quot;,
  when we will try to use this proc, the Nim's VS Code extension will tell us that we have,
  a variable with `typedesc type, typedesc type`, instead of `type, type`.
  This is because we are giving types to our proc to make our HashSet[KeyValue[type, type]],
  and not some operation working with values of types already `initialized` outside of the `proc`

  And then we simply use the initialization proc for hashSets `initHashSet` of type KeyValue[type, type],
  to initialize our fakeTable of type `FakeTable`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> newFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-literal">result</span> = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]() <span class="hljs-comment">#Have to use `result =` with `runnableExamples:` present</span>

    runnableExamples:
      <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
      fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
      <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Now let's run the runnable example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fakeTable = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  fakeTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)

  <span class="hljs-keyword">echo</span> fakeTable, <span class="hljs-string">&quot; &quot;</span>, fakeTable.typeof
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, initializing our fakeTable is much simpler than the original of:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">var</span> keyValue = initHashSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>]]()

nbSubSection <span class="hljs-string">&quot;Making a `OrderedSet` version of our constructor proc&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  First we make another type just like with we did for our FakeTable type,
  but instead of using a `HashSet`, we use a `OrderedSet`.
  And then lastly, we simply rename the return type to `FakeOrderedTable`
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] = <span class="hljs-type">OrderedSet</span>[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]

  <span class="hljs-keyword">proc</span> newOrderedFakeTable[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](keyType: typedesc[<span class="hljs-type">K</span>], valueType: typedesc[<span class="hljs-type">V</span>]): <span class="hljs-type">FakeOrderedTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    initOrderedSet[<span class="hljs-type">KeyValue</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]]()

    runnableExamples:
      <span class="hljs-keyword">var</span> fakeOrderedTable = newOrderedFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
      fakeOrderedTable.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
      <span class="hljs-keyword">echo</span> fakeOrderedTable, <span class="hljs-string">&quot; &quot;</span>, fakeOrderedTable.typeof

nbSection <span class="hljs-string">&quot;Overloading&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's move on to overloading ALL of the operations normal `sets` can use,
  here is the list from the `sets video`:

  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;incl&lt;/b&gt;&lt;/span&gt;(A, e)	same as A = A + e
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;excl&lt;/b&gt;&lt;/span&gt;(A, e)	same as A = A - e
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;card&lt;/b&gt;&lt;/span&gt;(A)	the cardinality of A (number of elements in A)
  -  &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;contains&lt;/b&gt;&lt;/span&gt;(A, e)	A contains element e
  -  e &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;in&lt;/b&gt;&lt;/span&gt; A	set membership (A contains element e)
  -  e &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;notin&lt;/b&gt;&lt;/span&gt; A	A does not contain element e
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;*&lt;/b&gt;&lt;/span&gt; b	Intersection
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;+&lt;/b&gt;&lt;/span&gt; b	Union
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;-&lt;/b&gt;&lt;/span&gt; b	Difference
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;==&lt;/b&gt;&lt;/span&gt; b	Set equality
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;&lt;=&lt;/b&gt;&lt;/span&gt; b	subset relation (a is subset of b or equal to b)
  -  a &lt;span style=&quot;color:pink&quot;&gt;&lt;b&gt;&lt;&lt;/b&gt;&lt;/span&gt; b	Check if a is a subset of b

  **As well as:**
  - \`[]\`(`[]` with apostrophes) so that we can find the value of a key, by supplying the key.
    Otherwise we have to supply the entire `tuple`.

  **And** `missingOrExcl(HashSet, key)` as an extra(only for hashSets, not normal Sets)
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;`contains` alias for `in` overload&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  Let's start with `contains(container, key)`, which is an alias for the `in` operator.
  So that we can easily find a `key` inside our `FakeTable`'s `KeyValue` tuple,
  and with that `key`, it's `value:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment"># `in` is an alias for `contains`, </span>
  <span class="hljs-keyword">proc</span> contains[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">if</span> tup.key == k:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  As you can see, we make it a `generic` proc that takes our `FakeTable` type,
  unwraps the `fakeTable`, and then checks every `KeyValue` tuple's first field of `key`,
  against `k`, the key we are looking for, and then returns true or false if it found it or not.

  **Here is an example of it's usage:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fakeTableContains = newFakeTable(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>)

  fakeTableContains.incl (<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">101</span>) <span class="hljs-comment">#elements as tuples</span>
  fakeTableContains.incl (<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">202</span>) <span class="hljs-comment">#elements as tuples</span>

  <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Key 2&quot;</span> <span class="hljs-keyword">in</span> fakeTableContains:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;SUCCESS: Key 2 is in fakeTableContains&quot;</span>

nbSubSection <span class="hljs-string">&quot;&amp;#96;[]&amp;#96; overload&quot;</span> <span class="hljs-comment">#&amp;#96; is inline HTML for ` backticks - cannot use double backticks here</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's overload the \`[]\`(`[]` with apostrophes),
  to again, be able to easily find a `key` inside our `FakeTable`'s `KeyValue` tuple,
  and with that `key`, it's `value:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `[]`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-type">V</span> {.inline.} =
    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> fakeTable:
      <span class="hljs-keyword">if</span> tup.key == k:
        <span class="hljs-keyword">return</span> tup.value

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Very similar to the `contains`(`in` is the alias) overload.
  The strange part here is the `{.inline.}` pragma,
  which is simply there to mark it for the compiler(which will warn us) and us,
  that we should not call this proc `[]` directly,
  as in like a proc `[](arg1, arg2)`.

  **Here is the example of what that overload enables us:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> fakeTableContains
  <span class="hljs-keyword">echo</span> fakeTableContains[<span class="hljs-string">&quot;Key 1&quot;</span>]

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **NOTE:** All of these overloads have to focus on the `key` part of the `KeyValue` tuple,
  in order to achieve the functionality of a `Table`.
  Meaning, these overloads must make it so that we only work with the `keys`,
  and not `tuples`.
&quot;&quot;&quot;</span>

nbSubsection <span class="hljs-string">&quot;&amp;#96;+&amp;#96; - union - operator overload&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now let's overload the `+` operator(proc), which is the `union` between Set1 and Set2,
  meaning both sets.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key != tupB.key:
          <span class="hljs-literal">result</span>.incl tupA
          <span class="hljs-literal">result</span>.incl tupB
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The overload proc's head, could also put both arguments together like this:
&quot;&quot;&quot;</span>
nbCodeSkip:
  <span class="hljs-keyword">proc</span> `+`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-keyword">discard</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **How it works:** Well, first of we unwrap the first `FakeTable`(HashSet[KeyValue[K, V]]) with a for loop,
  then we unwrap the second with another for loop on the second `FakeTable` of `b`,
  in order to -&gt; elementOfSet1.key != elementOfSet1.key -&gt; elementOfSet1.key != elementOfSet`2`.key -&gt; 
  and so on, until we compare every element's key of `a` against every element's key of `b`,
  in order to find only the `keys`, both `FakeTables` share,
  to return a `result` of the `union` of both `FakeTables`.

  Remember that `sets` do not allow for duplicate keys.
  Checking without the `.key` part, could result in duplicate keys,
  because, even though our `FakeTable` is a `HashSet` which doesn't allow for duplicate elements,
  it can only do so, if the `(key, value)` tuple elements we have in it,
  have both fields of our `KeyValue` tuple `(key, value)` exactly the same,
  as another `KeyValue` tuple `(key, value)`.
  Tuples are only equal if both tuples have both fields identical.

  This is why we must provide &quot;help&quot; to our `FakeTable`'s overload procs.

  **Now let's finally see an example of the `+` operator(proc) overload:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> fTableA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> fTableB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  fTableA.incl (<span class="hljs-string">'A'</span>, <span class="hljs-number">1</span>)
  fTableA.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)

  fTableB.incl (<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>)
  fTableB.incl (<span class="hljs-string">'C'</span>, <span class="hljs-number">3</span>)

  <span class="hljs-keyword">echo</span> fTableA + fTableB

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Here we go, all the elements of both `FakeTables`, without duplicates.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;&amp;#96;-&amp;#96; - difference - operator overload&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  Now let's overload the `-` operator(proc) - Difference - Returns the elements that `fTableA` has,
  but `fTableB` does not.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `-`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">var</span> tempA = a
    <span class="hljs-keyword">var</span> tempB = b

    <span class="hljs-comment">#De-duplication</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key == tupB.key:
          tempA.excl(tupA)
          tempB.excl(tupB)

    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> tempA:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> tempB:
        <span class="hljs-keyword">if</span> tupA.key != tupB.key:
          <span class="hljs-keyword">if</span> tupA <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
            <span class="hljs-keyword">discard</span>
          <span class="hljs-keyword">else</span>:
            <span class="hljs-literal">result</span>.incl tupA
nbText: <span class="hljs-string">&quot;&quot;&quot;
  First of, we copy the 2 `FakeTable`s of `a` and `b` into temporary variables of `tempA` and `tempB`,
  because want to de-duplicate the `FakeTable`s and only return different elements,
  and we can't do that with the `FakeTables` we supplied to the 2x arguments of `a` and `b`,
  because you can't modify arguments received.
  We also can't use `var` before `FakeTable` as in `a: var FakeTable`,
  because we would be modifying the original `FakeTable`s, which we don't want to do.

  So the second part marked with the `#De-duplication comment`,
  is where we unwrap both of the `FakeTables`,
  and check all the `keys` of the `KeyValue` tuples for identical keys/duplicates,
  and then remove them from both, because this isn't just to find and remove duplicates,
  but also because the `-` operator(proc), is supposed to only return the elements,
  that are not in `FakeTable` `b` - any duplicates/shared elements.

  And lastly, the third part then unwraps both `temp` `FakeTable`s,
  and looks for `different keys`, and also checks the `result` variable,
  because checking if the keys are not equal and then including `tupA`,
  the remaining keys WILL be different, and if both `FakeTable`s have 2x elements each,
  then both of the elements of `tupA`, would be added twice,
  requiring further de-duplication. Checking the `result` variable, fixes that.

  **Here is an example of manually going trough this overloaded `-` operator(proc):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">discard</span> <span class="hljs-comment">#nimib requires a return</span>
  <span class="hljs-comment">#a b c #a: FakeTable</span>
  <span class="hljs-comment">#c d e #b: FakeTable</span>
  <span class="hljs-comment">#De-duplication</span>
  <span class="hljs-comment">#a b</span>
  <span class="hljs-comment">#d e</span>
  <span class="hljs-comment">#1 a != d -&gt; yes adding `a`</span>
  <span class="hljs-comment">#2 a != e -&gt; yes adding `a` -&gt; duplicated `a` -&gt; hashSet detects that, removes it. BUT tuples != if not all fields are equal</span>
  <span class="hljs-comment">#3 b != d -&gt; yes adding `b`</span>
  <span class="hljs-comment">#4 b != e -&gt; yes adding `b`</span>
  <span class="hljs-comment">#result = {'a', 'a', 'b', 'b'} -&gt; correct if we deduplicate... this could go on to infinity.</span>
  <span class="hljs-comment">#So checking the `result` variable fixes the above problem</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **And here is the code for the above manual explanation:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> ftA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> ftB = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  ftA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); ftA.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>); ftA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)
  ftB.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>); ftB.incl (<span class="hljs-string">'d'</span>, <span class="hljs-number">40</span>); ftB.incl (<span class="hljs-string">'e'</span>, <span class="hljs-number">50</span>)

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA: &quot;</span>, ftA
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB: &quot;</span>, ftB

  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftA - ftB = &quot;</span>, ftA - ftB
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **And the reverse:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ftB - ftA = &quot;</span>, ftB - ftA

nbSubSection <span class="hljs-string">&quot;Optional Semicolon `;`&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  In the above code i have also used `;` which is optional in Nim,
  and allows for multiple operations to be used on a single line.
  I think it's quite useful for such small operations that work the same,
  to be put on a single line, instead of heavily spreading vertically.
  I don't recommend using the optional semicolon `;` for large operations,
  or different ones, most people don't like that,
  and it will hurt clarity and readability. But again, for same operations of such small scale, yes.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;&amp;#96;*&amp;#96; - intersection - operator overload&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Now we will overload the `*` operator(proc) - intersection - returns only shared elements.
  This one is very simple, simply compare the keys, and add one of them into the `result`(since both are the same):
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `*`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>] =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
      <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
        <span class="hljs-keyword">if</span> tupA.key == tupB.key:
          <span class="hljs-literal">result</span>.incl tupA

nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> ftA * ftB

nbSubSection <span class="hljs-string">&quot;&amp;#96;&lt;&amp;#96; - subset of - operator overload&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Next is `&lt;` operator(proc) overload - `a` subset of `b`
  First of, when using this operator, the `subset` HAS to be smaller than the set(FakeTable) we are comparing against.

  Which is easily achieved by first checking the lengths of the 2x `FakeTable`s:
    `if a.len &gt;= b.len: return false`, `else:` we continue.
  Then we set the `result` variable to `false`, unwrap the 2x `FakeTable`s,
  make a `block subsetA` statement, so that we can easily break out of the second loop once we find an identical key,
  after setting the `result` variable to `true`Àô.

  **This is for 2x reasons:** The first is for reasons of speed, we are checking every element of `FakeTable` `a`,
  against every element of `FakeTable` `b`, there are no duplicates, so once found, it's a waste to continue.

  And secondly, because we have to set the `result` variable to `false` if the keys are not identical,
  so that once loop 2 ends, and loop 1 is about to start another run of loop 2 with the next element,
  and we found no matching `keys`, then `FakeTable` `a` is NOT a subset of `FakeTable` `Àôb`.
  And because of that, if we don't break out back to loop 1 using the `labeled block` statement,
  we could find a matching key, but then on the second element override it to false!
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `&lt;`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">if</span> a.len &gt;= b.len:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">block</span> subsetA:
          <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
            <span class="hljs-keyword">if</span> tupA.key == tupB.key:
              <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
              <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
            <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Here is an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment">#ftA has 'a', 'b', 'c'</span>
  <span class="hljs-keyword">var</span> subsetOfA = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  subsetOfA.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>)
  subsetOfA.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

  <span class="hljs-keyword">echo</span> ftA
  <span class="hljs-keyword">echo</span> subsetOfA
  <span class="hljs-keyword">echo</span> subsetOfA &lt; ftA

  <span class="hljs-keyword">var</span> subsetofA2 = ftA
  <span class="hljs-keyword">echo</span> subsetofA2 &lt; ftA
nbText: <span class="hljs-string">&quot;&quot;&quot;
  `subsetofA2 is false because it is equal in size of `ftA`, again, has to be smaller.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;&amp;#96;&lt;=&amp;#96; - subset relation - operator overload&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The `&lt;=`(subset relation) operator(proc), does the exact same as `&lt;`(subset of) operator,
  except that the subset can be equal in size.

  **Here is the code to overload `&lt;=` operator(proc):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `&lt;=`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-comment">#Checking only the keys</span>
    <span class="hljs-keyword">if</span> system.`&lt;=`(a.len, b.len): <span class="hljs-comment">#Can't do this: if a.len &lt;= b.len: -&gt; for some reason this overload calls itself instead of the system &lt;=</span>
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">block</span> subsetA:
          <span class="hljs-keyword">for</span> tupB <span class="hljs-keyword">in</span> b:
            <span class="hljs-keyword">if</span> tupA.key == tupB.key:
              <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>
              <span class="hljs-keyword">break</span> subsetA <span class="hljs-comment">#1 so if we find &quot;true&quot;, we don't keep on checking(the Set could be gigantic), AND so that if the results would be false, true, false, we don't overwrite the true on the third check.</span>
            <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> == <span class="hljs-literal">false</span>: <span class="hljs-comment">#2 we end up here after the break, if false, then it's not a subset, otherwise next tupA</span>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#This is here, again like #1, so we don't keep on checking.</span>
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  The only real change here compared to the `&lt;` overload,
  is that instead of checking for the `subset` to be smaller,
  we check for smaller or equal.
  Here i found a bit of a problem. For some reason when using the `&lt;=` operator,
  Nim calls the version we are in right now, instead of the `system` module one.
  So in order to tell it to use the correct one,
  we have to explicitly specify that with `system.` + **\`&lt;=\`** + `(a.len, b.len)`,
  instead of simply `a.len &lt;= b.len`.
&quot;&quot;&quot;</span>

nbSubSection <span class="hljs-string">&quot;&amp;#96;==&amp;#96; - equality - operator overload&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  **Now let's also overload the `==` operator(proc)**,
  so that we are no longer comparing tuples, which require both fields to be equal for equivalence.
  With this overload we would only require the `keys`.

  With this overload, we also have to use the `system.` way of explicitly calling the system module's `==` operator.
  I am pretty sure, that the reason this happens, is for reasons of `recursion`,
  proc calling itself, like in the famous fibonacci sequence.

  In this overload's code i've also used the `in` alias of the `contains` overload we have done earlier,
  to make this easier, as well as a `continue` statement, instead of reversing that logic with a `notin` template.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> `==`[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](a, b: <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>]): <span class="hljs-built_in">bool</span> =
    <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">#until false</span>

    <span class="hljs-keyword">if</span> system.`==`(a.len, b.len): <span class="hljs-comment">#Cannot use: if a.len == b.len: -&gt; because of reasons of recursion</span>
      <span class="hljs-keyword">for</span> tupA <span class="hljs-keyword">in</span> a:
        <span class="hljs-keyword">if</span> tupA.key <span class="hljs-keyword">in</span> b:
          <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">else</span>:
          <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>: 
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **And an example:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> a = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> b = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)
  <span class="hljs-keyword">var</span> c = newFakeTable(<span class="hljs-built_in">char</span>, <span class="hljs-built_in">int</span>)

  a.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); a.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)
  b.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); b.incl (<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>)

  c.incl (<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>); c.incl (<span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>)

  <span class="hljs-keyword">echo</span> a == b
  <span class="hljs-keyword">echo</span> a == c

nbSubSection <span class="hljs-string">&quot;`excl` proc overload&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  **Now let's overload the `excl` proc(for Sets/HashSets)**, in order to simplify removal of `KeyValue` tuples,
  based on the `key` provided. `del` is the proc for doing this for `Tables`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> excl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>) =
    <span class="hljs-comment">#Since excluding/removing an element of a container while iterating over it with a `for` loop is an error,</span>
      <span class="hljs-comment">#iterating over a copy, and using the copy's data to remove from the original will avoid that problem</span>
    <span class="hljs-keyword">var</span> temp = fakeTable

    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> temp:
      <span class="hljs-keyword">if</span> tup.key == k:
        fakeTable.excl(tup)

nbText: <span class="hljs-string">&quot;&quot;&quot;
  We have to use the `var` keyword in the overload's definition/head for our `FakeTable` in order to remove a `key`,
  from the supplied `FakeTable`. Without `var` you only copy the argument's data.

  **Example(using variables from above):**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">echo</span> a
  a.excl(<span class="hljs-string">'a'</span>)
  <span class="hljs-keyword">echo</span> a

nbSubSection <span class="hljs-string">&quot;`missingOrExcl` proc overload&quot;</span>
nbText <span class="hljs-string">&quot;&quot;&quot;
  **Now we will overload the `missingOrExcl` proc, that is available only to hashSets, NOT normal Sets.**
  `missingOrExcl` again, first excludes a `key` from a `HashSet`, and tells you if the `key` was already missing:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> missingOrExcl[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>](fakeTable: <span class="hljs-keyword">var</span> <span class="hljs-type">FakeTable</span>[<span class="hljs-type">K</span>, <span class="hljs-type">V</span>], k: <span class="hljs-type">K</span>): <span class="hljs-built_in">bool</span> =
    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> fakeTable:
      fakeTable.excl(k)
      <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">else</span>: <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
  Quite simple with the `excl` and `contains` proc overloads. 
  Without them, it would of been quite longer and harder to understand.

  **Here is an example from the `sets` module's example for `missingOrExcl` for `HashSet`s:**
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">var</span> s = newFakeTable(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)
  s.incl (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); s.incl (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); s.incl (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>); s.incl (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);

  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">4</span>) <span class="hljs-comment">#should be: true</span>
  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: false</span>
  <span class="hljs-keyword">echo</span> s.missingOrExcl(<span class="hljs-number">6</span>) <span class="hljs-comment">#should be: true</span>

nbUoSection <span class="hljs-string">&quot;Outro - Afterwords&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
  Okay, that's it for this video, thanks for watching like, share and subscribe, 
    aswell as click the bell icon if you liked it and want more, 
    you can also follow me on twitter of the same name, and support me on Patreon. 
    If you had any problems with any part of the video, 
    let me know in the comment section, 
    the code of this video, script and documentation, are in the link in the description,
    as a form of offline tutorial.
&quot;&quot;&quot;</span>
nbUoSection <span class="hljs-string">&quot;Thanks to my past and current Patrons&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Past Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Goose_Egg: From April 4th 2021 to May 10th 2022
- Davide Galilei(1x month)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Current Patrons&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- jaap groot (from October 2023)
- Dimitri Lesnoff (from October 2023)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Compiler Information&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- Version used: E.G. 2.0.2
- Compiler settings used: none, ORC is now the default memory management option
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;My and General Links&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Patreon](https://www.patreon.com/Kiloneie?fan_landing=true &quot;Patreon&quot;)
- [Visual Studio Code Shortcuts](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf &quot;Visual Studio Code Shortcuts&quot;)
&quot;&quot;&quot;</span>
nbUoSubSection <span class="hljs-string">&quot;Links to this video's subject&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
- [Sets(hashSets)](https://nim-lang.org/docs/sets.html &quot;Sets(hashSets)&quot;)
- [Hashes](https://nim-lang.org/docs/hashes.html &quot;Hashes&quot;)
- [Tables(hashTables)](https://nim-lang.org/docs/tables.html &quot;Tables(hashTables)&quot;)
&quot;&quot;&quot;</span>
nbSave()</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>